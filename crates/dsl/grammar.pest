WHITESPACE = _{ " " | "\t" | NEWLINE }

// Block comment support (optional).
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

num = @{ int }
    int = { ("+" | "-")? ~ digit+ }
    digit = { '0'..'9' }

// A generic "symbol" covers node names like `typed_parameter`, `identifier`, etc.
symbol = @{
    (ASCII_ALPHANUMERIC | "_" | "+" | "-" | "*" | "/" | "%" | "^" | "=" | "<" | ">" | "!")+
}

// Tree-sitter captures: `@name`, `@val`, etc.
capture = @{
    "@" ~ (ASCII_ALPHANUMERIC | "_")+
}

// Quantifiers for repetition: `(node)*`, `(node)?`, `(node)+`
quantifier = @{ "*" | "+" | "?" }

// Key-value pairs: e.g. `(key value)`
key_value = {
    "(" ~ symbol ~ WHITESPACE* ~ (capture | symbol) ~ WHITESPACE* ~ ")"
}

// Special form: `(emit ...)`
emit = {
    "(" ~ WHITESPACE* ~ "emit" ~ WHITESPACE*
    ~ symbol                    // Output node type
    ~ WHITESPACE*
    ~ expr*                     // Emit arguments (key-value pairs, sub-expressions, etc.)
    ~ WHITESPACE*
    ~ ")"
}

// Special form: `(capture ...)`
capture_form = {
    "(" ~ WHITESPACE* ~ "capture" ~ WHITESPACE*
    ~ expr*                      // Capture content (sub-expression or special form)
    ~ WHITESPACE*
    ~ ")"
}

// Logical forms like `(and ...)`, `(or ...)`, `(not ...)`
logical = {
    "(" ~ WHITESPACE*
    ~ logical_operator          // e.g., "and", "or", "not"
    ~ WHITESPACE+
    ~ expr+                     // Sub-expressions (operands)
    ~ WHITESPACE*
    ~ ")"
}

logical_operator = { "and" | "or" | "not" }

// A standard S-expression, extended with optional capture & quantifier:
//
// - `(identifier)` is a normal sub-expression
// - `(identifier)@capture` merges node + capture
// - `(identifier)@capture*` merges node + capture + quantifier
//
// The rule allows WHITESPACE* between `)` and `@` so `(identifier) @val` 
// also parses correctly as one expression.
sexpr = {
    "("
    ~ WHITESPACE* 
    ~ expr*        // Zero or more sub-expressions inside the parentheses
    ~ WHITESPACE*
    ~ ")"
    ~ WHITESPACE*  // Allow a space before capture
    ~ capture?     // Optional capture token
    ~ WHITESPACE*
    ~ quantifier?  // Optional *, +, or ?
}

// A curly‐brace expression, if you need it for Q-expressions or similar constructs.
// Not always necessary, but shown here for completeness.
qexpr = {
    "{" 
    ~ WHITESPACE*
    ~ expr*
    ~ WHITESPACE*
    ~ "}"
}

// The primary expression type: could be
// - a symbol (like `typed_parameter`, `identifier`)
// - a key-value pair (`key value`)
// - an S-expression (`(identifier)@name`)
// - a curly‐brace expression (optional, depending on your usage).
// - special forms like `emit` and `capture`
// - logical forms like `(and ...)`, `(or ...)`, `(not ...)`
expr = {
    emit
  | capture_form
  | key_value
  | logical
  | sexpr
  | qexpr
  | num
  | capture          // Add capture explicitly
  | symbol
}

// The top-level rule: parse exactly one expression (or more if desired).
program = { SOI ~ (expr | COMMENT | WHITESPACE)* ~ EOI }
