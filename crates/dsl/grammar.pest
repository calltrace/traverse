// Define what constitutes whitespace. The `_` prefix indicates that whitespace will be skipped and not included in the parse tree.
WHITESPACE = _{ " " | "\t" | NEWLINE }

// Define block comments. The `_` prefix ensures comments are skipped. This rule matches any content between `/*` and `*/`.
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Define a set of ASCII alphanumeric characters by combining alphabetic and digit characters.
ASCII_ALPHANUMERIC = { ASCII_ALPHA | ASCII_DIGIT }

// Define uppercase and lowercase alphabetic characters.
ASCII_ALPHA = { 'a'..'z' | 'A'..'Z' }

// Define digit characters from 0 to 9.
ASCII_DIGIT = { '0'..'9' }

// Define a numeric value, which is an integer with an optional sign.
num = @{ int }
    // An integer consists of an optional '+' or '-' followed by one or more digits.
    int = { ("+" | "-")? ~ digit+ }
    // Define a single digit.
    digit = { '0'..'9' }

// Define a generic symbol used for node names like `typed_parameter`, `identifier`, etc.
// The `@` prefix makes this rule atomic, preventing backtracking within it.
symbol = @{
    (ASCII_ALPHANUMERIC | "_" | "+" | "-" | "*" | "/" | "%" | "^" | "=" | "<" | ">" | "!")+
}

// Define a capture pattern similar to Tree-sitter captures, such as `@name` or `@val`.
// The `@` prefix makes this rule atomic.
capture = @{
    "@" ~ (ASCII_ALPHANUMERIC | "_")+
}

// Define quantifiers for repetition in expressions, such as `(node)*`, `(node)?`, `(node)+`.
// The `@` prefix makes this rule atomic.
quantifier = @{ "*" | "+" | "?" }

// Define key-value pairs, e.g., `(key value)`. 
// A key-value pair starts with `(`, followed by a symbol (key), optional whitespace, 
// then a value which can be a capture, another symbol, or a nested key-value pair,
// optional whitespace, and ends with `)`.
key_value = {
    "(" ~ symbol ~ WHITESPACE* ~ (capture | symbol | key_value) ~ WHITESPACE* ~ ")"
}

// Define the `emit` special form, used for output nodes. 
// It allows key-value pairs and nested `emit` forms.
// Structure example:
// (emit output_node_type
//     (key1 @variable1)
//     (emit nested_output_node_type
//         (key2 @variable2)
//     )
// )
emit = {
    "(" ~ WHITESPACE* ~ "emit" ~ WHITESPACE*      // Start with '(' followed by 'emit' keyword and optional whitespace
    ~ symbol                                      // Output node type symbol
    ~ WHITESPACE*                                 // Optional whitespace
    ~ key_value+                                  // One or more key-value pairs
    ~ WHITESPACE*                                 // Optional whitespace
    ~ emit*                                       // Zero or more nested `emit` forms
    ~ WHITESPACE*                                 // Optional whitespace
    ~ ")"                                         // Closing ')'
}

// Define the `capture` special form, used for producing key-value pairs from node values.
// It can be referenced from `emit` forms and supports optional quantifiers like *, +, or ?.
// Structure example:
// (capture input_node_type
//     (key1 @variable1)
//     (key2 @variable2)
// )
capture_form = {
    "(" ~ WHITESPACE* ~ "capture" ~ WHITESPACE*    // Start with '(' followed by 'capture' keyword and optional whitespace
    ~ symbol                                        // Input node type symbol
    ~ WHITESPACE*                                   // Optional whitespace
    ~ key_value*                                    // Zero or more key-value pairs we want to capture from the current match
    ~ WHITESPACE*                                   // Optional whitespace
    ~ capture_form?                                 // Optional nested `capture` form to capture from nested nodes
    ~ WHITESPACE*                                   // Optional whitespace
    ~ quantifier?                                   // Optional quantifier (*, +, ?)
    ~ WHITESPACE*                                   // Optional whitespace
    ~ do_form?                                      // Optional `do` form for processing captured values
    ~ WHITESPACE*                                   // Optional whitespace
    ~ ")"                                           // Closing ')'
}

// Define the `do` special form, used for executing a block of code.
// Structure example:
// (do 
//     { expr1 } 
//     { expr2 } 
// )
do_form = {
    "(" ~ WHITESPACE* ~ "do" ~ WHITESPACE*          // Start with '(' followed by 'do' keyword and optional whitespace
    ~ qexpr+                                         // One or more Q-expressions inside '{ }'
    ~ WHITESPACE*                                    // Optional whitespace
    ~ ")"                                            // Closing ')'
}

// Define the `when` special form, used for conditional emission.
// It evaluates a condition and, if true, executes the contained `emit` forms.
// Structure example:
// (when (and @var1 @var2)
//     (emit conditional_output1
//         (key4 @var1)
//     )
//     (emit conditional_output2
//         (key5 @var2)
//     )
// )
when_form = {
    "(" ~ WHITESPACE* ~ "when" ~ WHITESPACE*        // Start with '(' followed by 'when' keyword and optional whitespace
    ~ (logical | qexpr)                              // Either a logical expression or a Q-expression as the condition
    ~ WHITESPACE*                                    // Optional whitespace
    ~ emit+                                       // One or more `emit` forms for conditional output
    ~ WHITESPACE*                                    // Optional whitespace
    ~ ")"                                            // Closing ')'
}

// Define logical constructs like `(and @var1 @var2)`, `(or @var1 @var2)`, `(not @var1)`.
// These constructs allow combining conditions using logical operators.
logical = {
    "(" ~ WHITESPACE*                                // Start with '(' and optional whitespace
    ~ logical_operator                               // Logical operator: 'and', 'or', 'not'
    ~ WHITESPACE*                                    // Optional whitespace
    ~ (num | symbol | capture | logical)+            // One or more operands: number, symbol, capture, or nested logical construct
    ~ WHITESPACE*                                    // Optional whitespace
    ~ ")"                                            // Closing ')'
}

// Define logical operators: 'and', 'or', 'not'.
logical_operator = { "and" | "or" | "not" }

// Define a standard S-expression. Allows for zero or more sub-expressions inside parentheses.
// It can optionally include a capture and a quantifier after the closing ')'.
sexpr = {
    "(" ~ WHITESPACE*                                // Start with '(' and optional whitespace
    ~ (expr | capture)+                                          // Zero or more expressions inside
    ~ WHITESPACE*                                    // Optional whitespace
    ~ ")" ~ WHITESPACE*                              // Closing ')' and optional whitespace
    ~ quantifier?                                    // Optional quantifier after the capture -- TODO: Remove?
}

// Define a curly-brace expression, used for Q-expressions or similar constructs.
// Structure example:
// { expr1 expr2 }
qexpr = {
    "{" ~ WHITESPACE*                                // Start with '{' and optional whitespace
    ~ expr*                                          // Zero or more expressions inside
    ~ WHITESPACE*                                    // Optional whitespace
    ~ "}"                                            // Closing '}'
}

// Define the primary expression type, which can be a symbol, number, S-expression, or Q-expression.
expr = {
    sexpr                                           // S-expression
  | qexpr                                           // Q-expression
  | num                                             // Number
  | symbol                                          // Symbol
}

// Define the top-level parsing rule, `program`. 
// It expects the entire input (from Start of Input `SOI` to End of Input `EOI`) to consist of zero or more
// `emit`, `when_form`, `capture_form`, and `do_form` constructs, interleaved with comments or whitespace.
program = { 
    SOI ~ (
        (
            (emit | when_form) ~ WHITESPACE* ~ capture_form* ~ WHITESPACE* 
        ) 
        | COMMENT 
        | WHITESPACE
    )* ~ EOI 
}
