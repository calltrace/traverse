use std::collections::HashSet;
/// Traverse Runner CLI (trvr)
///
/// This module implements a command-line interface for running DDlog applications generated by trvc.
/// It parses source files with tree-sitter, converts them to facts, and outputs DDlog commands.
///
/// The CLI follows a standard workflow:
/// 1. Parse and validate command-line arguments
/// 2. Read input source files
/// 3. Parse source files with tree-sitter and convert to facts
/// 4. Output DDlog commands
///
use std::fs;
use std::io::{self, Write};
use std::path::{Path, PathBuf};
use std::process;

use clap::Parser;
use backend::facts::{DDLogCommand, TreeSitterToDDLog};
use language::{Language, Mermaid, Solidity};
use tracing;
use tracing_subscriber;

#[derive(Debug, clap::ValueEnum, Clone)]
pub enum SourceType {
    Solidity,
    Mermaid,
}

impl SourceType {
    fn to_tree_sitter_language(&self) -> impl Language {
        match self {
            SourceType::Solidity => Solidity,
            SourceType::Mermaid => unimplemented!("Mermaid language support not yet implemented"),
        }
    }
}

#[derive(Parser, Debug)]
#[command(
    name = "trvr",
    author = "Traverse Team",
    version,
    about = "Traverse Runner - Parse source files and generate DDlog commands",
    long_about = None
)]
struct Args {
    /// Paths to source files to analyze
    #[arg(short = 's', long = "source", value_name = "FILE", required = true)]
    source_paths: Vec<PathBuf>,

    /// Type of the source files
    #[arg(short = 't', long = "type", value_enum, required = true)]
    source_type: SourceType,

    /// Output file for the DDlog commands (if not provided, outputs to stdout)
    #[arg(short = 'o', long = "output", value_name = "FILE")]
    output_path: Option<PathBuf>,

    /// Enable tracing for debugging
    #[arg(long = "trace", default_value = "false")]
    enable_tracing: bool,
    
    /// Exclude specific relations from the output
    #[arg(short = 'e', long = "exclude", value_name = "RELATION")]
    excluded_relations: Vec<String>,
    
    /// Print the tree structure of the parsed source
    #[arg(long = "print-tree", default_value = "false")]
    print_tree: bool,
}

impl Args {
    fn validate(&self) -> Result<(), io::Error> {
        // Validate that all source files exist
        for path in &self.source_paths {
            if !path.exists() {
                return Err(io::Error::new(
                    io::ErrorKind::NotFound,
                    format!("Source file does not exist: {}", path.display()),
                ));
            }
        }

        Ok(())
    }
}

fn main() {
    // Parse command line arguments
    let args = Args::parse();

    // Setup tracing if enabled
    if args.enable_tracing {
        tracing_subscriber::fmt::init();
    }

    // Validate arguments
    if let Err(err) = args.validate() {
        eprintln!("Error: {}", err);
        process::exit(1);
    }

    // Get the appropriate language for the source type
    let language = args.source_type.to_tree_sitter_language();
    
    // Create a set of excluded relations
    let excluded_relations = args.excluded_relations.iter().cloned().collect::<HashSet<String>>();

    // Process each source file
    let mut all_commands = Vec::new();
    all_commands.push(DDLogCommand::Start);
    
    for source_path in &args.source_paths {
        println!("Processing source file: {}", source_path.display());
        
        // Read the source file
        let source_content = match fs::read_to_string(source_path) {
            Ok(content) => content,
            Err(err) => {
                eprintln!("Error reading source file {}: {}", source_path.display(), err);
                process::exit(1);
            }
        };
        
        // Create a TreeSitterToDDLog converter
        let converter = TreeSitterToDDLog::new(&source_content, &language)
            .with_excluded_relations(excluded_relations.clone());
        
        // Print tree structure if requested
        if args.print_tree {
            println!("Tree structure for {}:", source_path.display());
            println!("{}", converter.dump_tree());
        }
        
        // Extract DDLog commands
        let mut commands = converter.extract_commands_with_fact_nodes(None);
        
        // Remove the Start and CommitDumpChanges commands as we'll add them once for all files
        if !commands.is_empty() && commands[0] == DDLogCommand::Start {
            commands.remove(0);
        }
        if !commands.is_empty() && commands.last() == Some(&DDLogCommand::CommitDumpChanges) {
            commands.pop();
        }
        
        // Add the commands to our collection
        all_commands.extend(commands);
    }
    
    // Add the final CommitDumpChanges command
    all_commands.push(DDLogCommand::CommitDumpChanges);
    
    // Output the commands
    if let Some(output_path) = &args.output_path {
        // Write to file
        match fs::File::create(output_path) {
            Ok(file) => {
                let mut writer = io::BufWriter::new(file);
                for command in &all_commands {
                    writeln!(writer, "{}", command).expect("Failed to write to output file");
                }
                println!("DDlog commands written to: {}", output_path.display());
            }
            Err(err) => {
                eprintln!("Error creating output file {}: {}", output_path.display(), err);
                process::exit(1);
            }
        }
    } else {
        // Write to stdout
        for command in &all_commands {
            println!("{}", command);
        }
    }
    
    println!("Processing completed successfully!");
}
