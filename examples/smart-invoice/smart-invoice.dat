start;
insert SourceFile(1, 0, "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";\nimport {IWRAPPED} from \"./interfaces/IWRAPPED.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/// @title SmartInvoiceFactoryBundler\n/// @notice A contract for creating and managing SmartInvoice escrow with customizable settings.\ncontract SmartInvoiceFactoryBundler is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice Address of the SmartInvoiceFactory\n    ISmartInvoiceFactory public escrowFactory;\n\n    /// @notice Address of the wrapped native token (e.g., WETH)\n    IWRAPPED public wrappedNativeToken;\n\n    /// @notice Error emitted when escrow creation fails\n    error EscrowNotCreated();\n\n    /// @notice Error emitted when the fund amount is invalid\n    error InvalidFundAmount();\n\n    /// @notice Event emitted when a new escrow is created\n    /// @param escrow Address of the newly created escrow\n    /// @param token Address of the token used for payment\n    /// @param amount The total fund amount transferred to the escrow\n    event EscrowCreated(\n        address indexed escrow,\n        address indexed token,\n        uint256 amount\n    );\n\n    /// @notice Struct representing the details of an escrow\n    struct EscrowData {\n        address client;\n        address resolver;\n        uint8 resolverType;\n        address token;\n        uint256 terminationTime;\n        bytes32 details;\n        address provider;\n        address providerReceiver;\n        bool requireVerification;\n        bytes32 escrowType;\n    }\n\n    /// @notice Constructor to initialize the contract with the factory and wrapped token addresses\n    /// @param _escrowFactory Address of the SmartInvoiceFactory\n    /// @param _wrappedNativeToken Address of the wrapped native token (e.g., WETH)\n    constructor(address _escrowFactory, address _wrappedNativeToken) {\n        escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n        wrappedNativeToken = IWRAPPED(_wrappedNativeToken);\n    }\n\n    /// @notice Internal function to decode and process escrow data\n    /// @param _escrowData Encoded data required for escrow setup\n    /// @return Returns the decoded EscrowData struct\n    function _decodeEscrowData(\n        bytes calldata _escrowData\n    ) internal pure returns (EscrowData memory) {\n        (\n            address client,\n            address resolver,\n            uint8 resolverType,\n            address token,\n            uint256 terminationTime,\n            bytes32 details,\n            address provider,\n            address providerReceiver,\n            bool requireVerification,\n            bytes32 escrowType\n        ) = abi.decode(\n                _escrowData,\n                (\n                    address,\n                    address,\n                    uint8,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    address,\n                    bool,\n                    bytes32\n                )\n            );\n\n        return\n            EscrowData({\n                client: client,\n                resolver: resolver,\n                resolverType: resolverType,\n                token: token,\n                terminationTime: terminationTime,\n                details: details,\n                provider: provider,\n                providerReceiver: providerReceiver,\n                requireVerification: requireVerification,\n                escrowType: escrowType\n            });\n    }\n\n    /// @notice Internal function to deploy a new escrow contract with provided details and milestone amounts\n    /// @param _milestoneAmounts Array representing the milestone payment amounts\n    /// @param _escrowData Encoded escrow data\n    /// @param _fundAmount Total amount to be funded into the escrow\n    /// @return escrow Address of the newly deployed escrow\n    function deployEscrow(\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _escrowData,\n        uint256 _fundAmount\n    ) public payable nonReentrant returns (address escrow) {\n        // Decode the provided escrow data\n        EscrowData memory escrowData = _decodeEscrowData(_escrowData);\n\n        // Prepare the details for the escrow creation\n        bytes memory escrowDetails = abi.encode(\n            escrowData.client,\n            escrowData.resolverType,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            escrowData.requireVerification,\n            address(escrowFactory),\n            escrowData.providerReceiver\n        );\n\n        // Deploy the new escrow contract using the factory\n        escrow = escrowFactory.create(\n            escrowData.provider,\n            _milestoneAmounts,\n            escrowDetails,\n            escrowData.escrowType\n        );\n\n        // Ensure escrow creation was successful\n        if (escrow == address(0)) revert EscrowNotCreated();\n\n        if (escrowData.token == address(wrappedNativeToken) && msg.value > 0) {\n            // Ensure the fund amount is valid\n            if (msg.value != _fundAmount) revert InvalidFundAmount();\n\n            // Transfer the native fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            wrappedNativeToken.deposit{value: _fundAmount}();\n\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransfer(escrow, _fundAmount);\n        } else {\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransferFrom(\n                msg.sender,\n                escrow,\n                _fundAmount\n            );\n        }\n\n        // Emit an event for the escrow creation\n        emit EscrowCreated(escrow, escrowData.token, _fundAmount);\n    }\n}\n");
insert Comment(2, 1, "// SPDX-License-Identifier: MIT");
insert PragmaDirective(3, 1, "pragma solidity ^0.8.20;");
insert SolidityPragmaToken(4, 3, "solidity ^0.8.20");
insert SolidityVersionComparisonOperator(5, 4, " ^");
insert SolidityVersion(6, 4, "0.8.20");
insert ImportDirective(7, 1, "import {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";");
insert Identifier(8, 7, "ISmartInvoiceFactory");
insert ImportDirective(9, 1, "import {IWRAPPED} from \"./interfaces/IWRAPPED.sol\";");
insert Identifier(10, 9, "IWRAPPED");
insert ImportDirective(11, 1, "import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";");
insert Identifier(12, 11, "IERC20");
insert ImportDirective(13, 1, "import {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";");
insert Identifier(14, 13, "SafeERC20");
insert ImportDirective(15, 1, "import {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";");
insert Identifier(16, 15, "ReentrancyGuard");
insert Comment(17, 1, "/// @title SmartInvoiceFactoryBundler");
insert Comment(18, 1, "/// @notice A contract for creating and managing SmartInvoice escrow with customizable settings.");
insert ContractDeclaration(19, 1, "contract SmartInvoiceFactoryBundler is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice Address of the SmartInvoiceFactory\n    ISmartInvoiceFactory public escrowFactory;\n\n    /// @notice Address of the wrapped native token (e.g., WETH)\n    IWRAPPED public wrappedNativeToken;\n\n    /// @notice Error emitted when escrow creation fails\n    error EscrowNotCreated();\n\n    /// @notice Error emitted when the fund amount is invalid\n    error InvalidFundAmount();\n\n    /// @notice Event emitted when a new escrow is created\n    /// @param escrow Address of the newly created escrow\n    /// @param token Address of the token used for payment\n    /// @param amount The total fund amount transferred to the escrow\n    event EscrowCreated(\n        address indexed escrow,\n        address indexed token,\n        uint256 amount\n    );\n\n    /// @notice Struct representing the details of an escrow\n    struct EscrowData {\n        address client;\n        address resolver;\n        uint8 resolverType;\n        address token;\n        uint256 terminationTime;\n        bytes32 details;\n        address provider;\n        address providerReceiver;\n        bool requireVerification;\n        bytes32 escrowType;\n    }\n\n    /// @notice Constructor to initialize the contract with the factory and wrapped token addresses\n    /// @param _escrowFactory Address of the SmartInvoiceFactory\n    /// @param _wrappedNativeToken Address of the wrapped native token (e.g., WETH)\n    constructor(address _escrowFactory, address _wrappedNativeToken) {\n        escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n        wrappedNativeToken = IWRAPPED(_wrappedNativeToken);\n    }\n\n    /// @notice Internal function to decode and process escrow data\n    /// @param _escrowData Encoded data required for escrow setup\n    /// @return Returns the decoded EscrowData struct\n    function _decodeEscrowData(\n        bytes calldata _escrowData\n    ) internal pure returns (EscrowData memory) {\n        (\n            address client,\n            address resolver,\n            uint8 resolverType,\n            address token,\n            uint256 terminationTime,\n            bytes32 details,\n            address provider,\n            address providerReceiver,\n            bool requireVerification,\n            bytes32 escrowType\n        ) = abi.decode(\n                _escrowData,\n                (\n                    address,\n                    address,\n                    uint8,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    address,\n                    bool,\n                    bytes32\n                )\n            );\n\n        return\n            EscrowData({\n                client: client,\n                resolver: resolver,\n                resolverType: resolverType,\n                token: token,\n                terminationTime: terminationTime,\n                details: details,\n                provider: provider,\n                providerReceiver: providerReceiver,\n                requireVerification: requireVerification,\n                escrowType: escrowType\n            });\n    }\n\n    /// @notice Internal function to deploy a new escrow contract with provided details and milestone amounts\n    /// @param _milestoneAmounts Array representing the milestone payment amounts\n    /// @param _escrowData Encoded escrow data\n    /// @param _fundAmount Total amount to be funded into the escrow\n    /// @return escrow Address of the newly deployed escrow\n    function deployEscrow(\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _escrowData,\n        uint256 _fundAmount\n    ) public payable nonReentrant returns (address escrow) {\n        // Decode the provided escrow data\n        EscrowData memory escrowData = _decodeEscrowData(_escrowData);\n\n        // Prepare the details for the escrow creation\n        bytes memory escrowDetails = abi.encode(\n            escrowData.client,\n            escrowData.resolverType,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            escrowData.requireVerification,\n            address(escrowFactory),\n            escrowData.providerReceiver\n        );\n\n        // Deploy the new escrow contract using the factory\n        escrow = escrowFactory.create(\n            escrowData.provider,\n            _milestoneAmounts,\n            escrowDetails,\n            escrowData.escrowType\n        );\n\n        // Ensure escrow creation was successful\n        if (escrow == address(0)) revert EscrowNotCreated();\n\n        if (escrowData.token == address(wrappedNativeToken) && msg.value > 0) {\n            // Ensure the fund amount is valid\n            if (msg.value != _fundAmount) revert InvalidFundAmount();\n\n            // Transfer the native fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            wrappedNativeToken.deposit{value: _fundAmount}();\n\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransfer(escrow, _fundAmount);\n        } else {\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransferFrom(\n                msg.sender,\n                escrow,\n                _fundAmount\n            );\n        }\n\n        // Emit an event for the escrow creation\n        emit EscrowCreated(escrow, escrowData.token, _fundAmount);\n    }\n}");
insert Identifier(20, 19, "SmartInvoiceFactoryBundler");
insert InheritanceSpecifier(21, 19, "ReentrancyGuard");
insert UserDefinedType(22, 21, "ReentrancyGuard");
insert Identifier(23, 22, "ReentrancyGuard");
insert ContractBody(24, 19, "{\n    using SafeERC20 for IERC20;\n\n    /// @notice Address of the SmartInvoiceFactory\n    ISmartInvoiceFactory public escrowFactory;\n\n    /// @notice Address of the wrapped native token (e.g., WETH)\n    IWRAPPED public wrappedNativeToken;\n\n    /// @notice Error emitted when escrow creation fails\n    error EscrowNotCreated();\n\n    /// @notice Error emitted when the fund amount is invalid\n    error InvalidFundAmount();\n\n    /// @notice Event emitted when a new escrow is created\n    /// @param escrow Address of the newly created escrow\n    /// @param token Address of the token used for payment\n    /// @param amount The total fund amount transferred to the escrow\n    event EscrowCreated(\n        address indexed escrow,\n        address indexed token,\n        uint256 amount\n    );\n\n    /// @notice Struct representing the details of an escrow\n    struct EscrowData {\n        address client;\n        address resolver;\n        uint8 resolverType;\n        address token;\n        uint256 terminationTime;\n        bytes32 details;\n        address provider;\n        address providerReceiver;\n        bool requireVerification;\n        bytes32 escrowType;\n    }\n\n    /// @notice Constructor to initialize the contract with the factory and wrapped token addresses\n    /// @param _escrowFactory Address of the SmartInvoiceFactory\n    /// @param _wrappedNativeToken Address of the wrapped native token (e.g., WETH)\n    constructor(address _escrowFactory, address _wrappedNativeToken) {\n        escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n        wrappedNativeToken = IWRAPPED(_wrappedNativeToken);\n    }\n\n    /// @notice Internal function to decode and process escrow data\n    /// @param _escrowData Encoded data required for escrow setup\n    /// @return Returns the decoded EscrowData struct\n    function _decodeEscrowData(\n        bytes calldata _escrowData\n    ) internal pure returns (EscrowData memory) {\n        (\n            address client,\n            address resolver,\n            uint8 resolverType,\n            address token,\n            uint256 terminationTime,\n            bytes32 details,\n            address provider,\n            address providerReceiver,\n            bool requireVerification,\n            bytes32 escrowType\n        ) = abi.decode(\n                _escrowData,\n                (\n                    address,\n                    address,\n                    uint8,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    address,\n                    bool,\n                    bytes32\n                )\n            );\n\n        return\n            EscrowData({\n                client: client,\n                resolver: resolver,\n                resolverType: resolverType,\n                token: token,\n                terminationTime: terminationTime,\n                details: details,\n                provider: provider,\n                providerReceiver: providerReceiver,\n                requireVerification: requireVerification,\n                escrowType: escrowType\n            });\n    }\n\n    /// @notice Internal function to deploy a new escrow contract with provided details and milestone amounts\n    /// @param _milestoneAmounts Array representing the milestone payment amounts\n    /// @param _escrowData Encoded escrow data\n    /// @param _fundAmount Total amount to be funded into the escrow\n    /// @return escrow Address of the newly deployed escrow\n    function deployEscrow(\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _escrowData,\n        uint256 _fundAmount\n    ) public payable nonReentrant returns (address escrow) {\n        // Decode the provided escrow data\n        EscrowData memory escrowData = _decodeEscrowData(_escrowData);\n\n        // Prepare the details for the escrow creation\n        bytes memory escrowDetails = abi.encode(\n            escrowData.client,\n            escrowData.resolverType,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            escrowData.requireVerification,\n            address(escrowFactory),\n            escrowData.providerReceiver\n        );\n\n        // Deploy the new escrow contract using the factory\n        escrow = escrowFactory.create(\n            escrowData.provider,\n            _milestoneAmounts,\n            escrowDetails,\n            escrowData.escrowType\n        );\n\n        // Ensure escrow creation was successful\n        if (escrow == address(0)) revert EscrowNotCreated();\n\n        if (escrowData.token == address(wrappedNativeToken) && msg.value > 0) {\n            // Ensure the fund amount is valid\n            if (msg.value != _fundAmount) revert InvalidFundAmount();\n\n            // Transfer the native fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            wrappedNativeToken.deposit{value: _fundAmount}();\n\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransfer(escrow, _fundAmount);\n        } else {\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransferFrom(\n                msg.sender,\n                escrow,\n                _fundAmount\n            );\n        }\n\n        // Emit an event for the escrow creation\n        emit EscrowCreated(escrow, escrowData.token, _fundAmount);\n    }\n}");
insert UsingDirective(25, 24, "using SafeERC20 for IERC20;");
insert TypeAlias(26, 25, "SafeERC20");
insert Identifier(27, 26, "SafeERC20");
insert TypeName(28, 25, "IERC20");
insert UserDefinedType(29, 28, "IERC20");
insert Identifier(30, 29, "IERC20");
insert Comment(31, 24, "/// @notice Address of the SmartInvoiceFactory");
insert StateVariableDeclaration(32, 24, "ISmartInvoiceFactory public escrowFactory;");
insert TypeName(33, 32, "ISmartInvoiceFactory");
insert UserDefinedType(34, 33, "ISmartInvoiceFactory");
insert Identifier(35, 34, "ISmartInvoiceFactory");
insert Visibility(36, 32, "public");
insert Identifier(37, 32, "escrowFactory");
insert Comment(38, 24, "/// @notice Address of the wrapped native token (e.g., WETH)");
insert StateVariableDeclaration(39, 24, "IWRAPPED public wrappedNativeToken;");
insert TypeName(40, 39, "IWRAPPED");
insert UserDefinedType(41, 40, "IWRAPPED");
insert Identifier(42, 41, "IWRAPPED");
insert Visibility(43, 39, "public");
insert Identifier(44, 39, "wrappedNativeToken");
insert Comment(45, 24, "/// @notice Error emitted when escrow creation fails");
insert ErrorDeclaration(46, 24, "error EscrowNotCreated();");
insert Identifier(47, 46, "EscrowNotCreated");
insert Comment(48, 24, "/// @notice Error emitted when the fund amount is invalid");
insert ErrorDeclaration(49, 24, "error InvalidFundAmount();");
insert Identifier(50, 49, "InvalidFundAmount");
insert Comment(51, 24, "/// @notice Event emitted when a new escrow is created");
insert Comment(52, 24, "/// @param escrow Address of the newly created escrow");
insert Comment(53, 24, "/// @param token Address of the token used for payment");
insert Comment(54, 24, "/// @param amount The total fund amount transferred to the escrow");
insert EventDefinition(55, 24, "event EscrowCreated(\n        address indexed escrow,\n        address indexed token,\n        uint256 amount\n    );");
insert Identifier(56, 55, "EscrowCreated");
insert EventParameter(57, 55, "address indexed escrow");
insert TypeName(58, 57, "address");
insert PrimitiveType(59, 58, "address");
insert Identifier(60, 57, "escrow");
insert EventParameter(61, 55, "address indexed token");
insert TypeName(62, 61, "address");
insert PrimitiveType(63, 62, "address");
insert Identifier(64, 61, "token");
insert EventParameter(65, 55, "uint256 amount");
insert TypeName(66, 65, "uint256");
insert PrimitiveType(67, 66, "uint256");
insert Identifier(68, 65, "amount");
insert Comment(69, 24, "/// @notice Struct representing the details of an escrow");
insert StructDeclaration(70, 24, "struct EscrowData {\n        address client;\n        address resolver;\n        uint8 resolverType;\n        address token;\n        uint256 terminationTime;\n        bytes32 details;\n        address provider;\n        address providerReceiver;\n        bool requireVerification;\n        bytes32 escrowType;\n    }");
insert Identifier(71, 70, "EscrowData");
insert StructBody(72, 70, "{\n        address client;\n        address resolver;\n        uint8 resolverType;\n        address token;\n        uint256 terminationTime;\n        bytes32 details;\n        address provider;\n        address providerReceiver;\n        bool requireVerification;\n        bytes32 escrowType;\n    }");
insert StructMember(73, 72, "address client;");
insert TypeName(74, 73, "address");
insert PrimitiveType(75, 74, "address");
insert Identifier(76, 73, "client");
insert StructMember(77, 72, "address resolver;");
insert TypeName(78, 77, "address");
insert PrimitiveType(79, 78, "address");
insert Identifier(80, 77, "resolver");
insert StructMember(81, 72, "uint8 resolverType;");
insert TypeName(82, 81, "uint8");
insert PrimitiveType(83, 82, "uint8");
insert Identifier(84, 81, "resolverType");
insert StructMember(85, 72, "address token;");
insert TypeName(86, 85, "address");
insert PrimitiveType(87, 86, "address");
insert Identifier(88, 85, "token");
insert StructMember(89, 72, "uint256 terminationTime;");
insert TypeName(90, 89, "uint256");
insert PrimitiveType(91, 90, "uint256");
insert Identifier(92, 89, "terminationTime");
insert StructMember(93, 72, "bytes32 details;");
insert TypeName(94, 93, "bytes32");
insert PrimitiveType(95, 94, "bytes32");
insert Identifier(96, 93, "details");
insert StructMember(97, 72, "address provider;");
insert TypeName(98, 97, "address");
insert PrimitiveType(99, 98, "address");
insert Identifier(100, 97, "provider");
insert StructMember(101, 72, "address providerReceiver;");
insert TypeName(102, 101, "address");
insert PrimitiveType(103, 102, "address");
insert Identifier(104, 101, "providerReceiver");
insert StructMember(105, 72, "bool requireVerification;");
insert TypeName(106, 105, "bool");
insert PrimitiveType(107, 106, "bool");
insert Identifier(108, 105, "requireVerification");
insert StructMember(109, 72, "bytes32 escrowType;");
insert TypeName(110, 109, "bytes32");
insert PrimitiveType(111, 110, "bytes32");
insert Identifier(112, 109, "escrowType");
insert Comment(113, 24, "/// @notice Constructor to initialize the contract with the factory and wrapped token addresses");
insert Comment(114, 24, "/// @param _escrowFactory Address of the SmartInvoiceFactory");
insert Comment(115, 24, "/// @param _wrappedNativeToken Address of the wrapped native token (e.g., WETH)");
insert ConstructorDefinition(116, 24, "constructor(address _escrowFactory, address _wrappedNativeToken) {\n        escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n        wrappedNativeToken = IWRAPPED(_wrappedNativeToken);\n    }");
insert Parameter(117, 116, "address _escrowFactory");
insert TypeName(118, 117, "address");
insert PrimitiveType(119, 118, "address");
insert Identifier(120, 117, "_escrowFactory");
insert Parameter(121, 116, "address _wrappedNativeToken");
insert TypeName(122, 121, "address");
insert PrimitiveType(123, 122, "address");
insert Identifier(124, 121, "_wrappedNativeToken");
insert FunctionBody(125, 116, "{\n        escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n        wrappedNativeToken = IWRAPPED(_wrappedNativeToken);\n    }");
insert Statement(126, 125, "escrowFactory = ISmartInvoiceFactory(_escrowFactory);");
insert ExpressionStatement(127, 126, "escrowFactory = ISmartInvoiceFactory(_escrowFactory);");
insert Expression(128, 127, "escrowFactory = ISmartInvoiceFactory(_escrowFactory)");
insert AssignmentExpression(129, 128, "escrowFactory = ISmartInvoiceFactory(_escrowFactory)");
insert Expression(130, 129, "escrowFactory");
insert Identifier(131, 130, "escrowFactory");
insert Expression(132, 129, "ISmartInvoiceFactory(_escrowFactory)");
insert CallExpression(133, 132, "ISmartInvoiceFactory(_escrowFactory)");
insert Expression(134, 133, "ISmartInvoiceFactory");
insert Identifier(135, 134, "ISmartInvoiceFactory");
insert CallArgument(136, 133, "_escrowFactory");
insert Expression(137, 136, "_escrowFactory");
insert Identifier(138, 137, "_escrowFactory");
insert Statement(139, 125, "wrappedNativeToken = IWRAPPED(_wrappedNativeToken);");
insert ExpressionStatement(140, 139, "wrappedNativeToken = IWRAPPED(_wrappedNativeToken);");
insert Expression(141, 140, "wrappedNativeToken = IWRAPPED(_wrappedNativeToken)");
insert AssignmentExpression(142, 141, "wrappedNativeToken = IWRAPPED(_wrappedNativeToken)");
insert Expression(143, 142, "wrappedNativeToken");
insert Identifier(144, 143, "wrappedNativeToken");
insert Expression(145, 142, "IWRAPPED(_wrappedNativeToken)");
insert CallExpression(146, 145, "IWRAPPED(_wrappedNativeToken)");
insert Expression(147, 146, "IWRAPPED");
insert Identifier(148, 147, "IWRAPPED");
insert CallArgument(149, 146, "_wrappedNativeToken");
insert Expression(150, 149, "_wrappedNativeToken");
insert Identifier(151, 150, "_wrappedNativeToken");
insert Comment(152, 24, "/// @notice Internal function to decode and process escrow data");
insert Comment(153, 24, "/// @param _escrowData Encoded data required for escrow setup");
insert Comment(154, 24, "/// @return Returns the decoded EscrowData struct");
insert FunctionDefinition(155, 24, "function _decodeEscrowData(\n        bytes calldata _escrowData\n    ) internal pure returns (EscrowData memory) {\n        (\n            address client,\n            address resolver,\n            uint8 resolverType,\n            address token,\n            uint256 terminationTime,\n            bytes32 details,\n            address provider,\n            address providerReceiver,\n            bool requireVerification,\n            bytes32 escrowType\n        ) = abi.decode(\n                _escrowData,\n                (\n                    address,\n                    address,\n                    uint8,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    address,\n                    bool,\n                    bytes32\n                )\n            );\n\n        return\n            EscrowData({\n                client: client,\n                resolver: resolver,\n                resolverType: resolverType,\n                token: token,\n                terminationTime: terminationTime,\n                details: details,\n                provider: provider,\n                providerReceiver: providerReceiver,\n                requireVerification: requireVerification,\n                escrowType: escrowType\n            });\n    }");
insert Identifier(156, 155, "_decodeEscrowData");
insert Parameter(157, 155, "bytes calldata _escrowData");
insert TypeName(158, 157, "bytes");
insert PrimitiveType(159, 158, "bytes");
insert Identifier(160, 157, "_escrowData");
insert Visibility(161, 155, "internal");
insert StateMutability(162, 155, "pure");
insert ReturnTypeDefinition(163, 155, "returns (EscrowData memory)");
insert Parameter(164, 163, "EscrowData memory");
insert TypeName(165, 164, "EscrowData");
insert UserDefinedType(166, 165, "EscrowData");
insert Identifier(167, 166, "EscrowData");
insert FunctionBody(168, 155, "{\n        (\n            address client,\n            address resolver,\n            uint8 resolverType,\n            address token,\n            uint256 terminationTime,\n            bytes32 details,\n            address provider,\n            address providerReceiver,\n            bool requireVerification,\n            bytes32 escrowType\n        ) = abi.decode(\n                _escrowData,\n                (\n                    address,\n                    address,\n                    uint8,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    address,\n                    bool,\n                    bytes32\n                )\n            );\n\n        return\n            EscrowData({\n                client: client,\n                resolver: resolver,\n                resolverType: resolverType,\n                token: token,\n                terminationTime: terminationTime,\n                details: details,\n                provider: provider,\n                providerReceiver: providerReceiver,\n                requireVerification: requireVerification,\n                escrowType: escrowType\n            });\n    }");
insert Statement(169, 168, "(\n            address client,\n            address resolver,\n            uint8 resolverType,\n            address token,\n            uint256 terminationTime,\n            bytes32 details,\n            address provider,\n            address providerReceiver,\n            bool requireVerification,\n            bytes32 escrowType\n        ) = abi.decode(\n                _escrowData,\n                (\n                    address,\n                    address,\n                    uint8,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    address,\n                    bool,\n                    bytes32\n                )\n            );");
insert VariableDeclarationStatement(170, 169, "(\n            address client,\n            address resolver,\n            uint8 resolverType,\n            address token,\n            uint256 terminationTime,\n            bytes32 details,\n            address provider,\n            address providerReceiver,\n            bool requireVerification,\n            bytes32 escrowType\n        ) = abi.decode(\n                _escrowData,\n                (\n                    address,\n                    address,\n                    uint8,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    address,\n                    bool,\n                    bytes32\n                )\n            );");
insert VariableDeclarationTuple(171, 170, "(\n            address client,\n            address resolver,\n            uint8 resolverType,\n            address token,\n            uint256 terminationTime,\n            bytes32 details,\n            address provider,\n            address providerReceiver,\n            bool requireVerification,\n            bytes32 escrowType\n        )");
insert VariableDeclaration(172, 171, "address client");
insert TypeName(173, 172, "address");
insert PrimitiveType(174, 173, "address");
insert Identifier(175, 172, "client");
insert VariableDeclaration(176, 171, "address resolver");
insert TypeName(177, 176, "address");
insert PrimitiveType(178, 177, "address");
insert Identifier(179, 176, "resolver");
insert VariableDeclaration(180, 171, "uint8 resolverType");
insert TypeName(181, 180, "uint8");
insert PrimitiveType(182, 181, "uint8");
insert Identifier(183, 180, "resolverType");
insert VariableDeclaration(184, 171, "address token");
insert TypeName(185, 184, "address");
insert PrimitiveType(186, 185, "address");
insert Identifier(187, 184, "token");
insert VariableDeclaration(188, 171, "uint256 terminationTime");
insert TypeName(189, 188, "uint256");
insert PrimitiveType(190, 189, "uint256");
insert Identifier(191, 188, "terminationTime");
insert VariableDeclaration(192, 171, "bytes32 details");
insert TypeName(193, 192, "bytes32");
insert PrimitiveType(194, 193, "bytes32");
insert Identifier(195, 192, "details");
insert VariableDeclaration(196, 171, "address provider");
insert TypeName(197, 196, "address");
insert PrimitiveType(198, 197, "address");
insert Identifier(199, 196, "provider");
insert VariableDeclaration(200, 171, "address providerReceiver");
insert TypeName(201, 200, "address");
insert PrimitiveType(202, 201, "address");
insert Identifier(203, 200, "providerReceiver");
insert VariableDeclaration(204, 171, "bool requireVerification");
insert TypeName(205, 204, "bool");
insert PrimitiveType(206, 205, "bool");
insert Identifier(207, 204, "requireVerification");
insert VariableDeclaration(208, 171, "bytes32 escrowType");
insert TypeName(209, 208, "bytes32");
insert PrimitiveType(210, 209, "bytes32");
insert Identifier(211, 208, "escrowType");
insert Expression(212, 170, "abi.decode(\n                _escrowData,\n                (\n                    address,\n                    address,\n                    uint8,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    address,\n                    bool,\n                    bytes32\n                )\n            )");
insert CallExpression(213, 212, "abi.decode(\n                _escrowData,\n                (\n                    address,\n                    address,\n                    uint8,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    address,\n                    bool,\n                    bytes32\n                )\n            )");
insert Expression(214, 213, "abi.decode");
insert MemberExpression(215, 214, "abi.decode");
insert Identifier(216, 215, "abi");
insert Identifier(217, 215, "decode");
insert CallArgument(218, 213, "_escrowData");
insert Expression(219, 218, "_escrowData");
insert Identifier(220, 219, "_escrowData");
insert CallArgument(221, 213, "(\n                    address,\n                    address,\n                    uint8,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    address,\n                    bool,\n                    bytes32\n                )");
insert Expression(222, 221, "(\n                    address,\n                    address,\n                    uint8,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    address,\n                    bool,\n                    bytes32\n                )");
insert TupleExpression(223, 222, "(\n                    address,\n                    address,\n                    uint8,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    address,\n                    bool,\n                    bytes32\n                )");
insert Expression(224, 223, "address");
insert PrimitiveType(225, 224, "address");
insert Expression(226, 223, "address");
insert PrimitiveType(227, 226, "address");
insert Expression(228, 223, "uint8");
insert PrimitiveType(229, 228, "uint8");
insert Expression(230, 223, "address");
insert PrimitiveType(231, 230, "address");
insert Expression(232, 223, "uint256");
insert PrimitiveType(233, 232, "uint256");
insert Expression(234, 223, "bytes32");
insert PrimitiveType(235, 234, "bytes32");
insert Expression(236, 223, "address");
insert PrimitiveType(237, 236, "address");
insert Expression(238, 223, "address");
insert PrimitiveType(239, 238, "address");
insert Expression(240, 223, "bool");
insert PrimitiveType(241, 240, "bool");
insert Expression(242, 223, "bytes32");
insert PrimitiveType(243, 242, "bytes32");
insert Statement(244, 168, "return\n            EscrowData({\n                client: client,\n                resolver: resolver,\n                resolverType: resolverType,\n                token: token,\n                terminationTime: terminationTime,\n                details: details,\n                provider: provider,\n                providerReceiver: providerReceiver,\n                requireVerification: requireVerification,\n                escrowType: escrowType\n            });");
insert ReturnStatement(245, 244, "return\n            EscrowData({\n                client: client,\n                resolver: resolver,\n                resolverType: resolverType,\n                token: token,\n                terminationTime: terminationTime,\n                details: details,\n                provider: provider,\n                providerReceiver: providerReceiver,\n                requireVerification: requireVerification,\n                escrowType: escrowType\n            });");
insert Expression(246, 245, "EscrowData({\n                client: client,\n                resolver: resolver,\n                resolverType: resolverType,\n                token: token,\n                terminationTime: terminationTime,\n                details: details,\n                provider: provider,\n                providerReceiver: providerReceiver,\n                requireVerification: requireVerification,\n                escrowType: escrowType\n            })");
insert CallExpression(247, 246, "EscrowData({\n                client: client,\n                resolver: resolver,\n                resolverType: resolverType,\n                token: token,\n                terminationTime: terminationTime,\n                details: details,\n                provider: provider,\n                providerReceiver: providerReceiver,\n                requireVerification: requireVerification,\n                escrowType: escrowType\n            })");
insert Expression(248, 247, "EscrowData");
insert Identifier(249, 248, "EscrowData");
insert CallArgument(250, 247, "{\n                client: client,\n                resolver: resolver,\n                resolverType: resolverType,\n                token: token,\n                terminationTime: terminationTime,\n                details: details,\n                provider: provider,\n                providerReceiver: providerReceiver,\n                requireVerification: requireVerification,\n                escrowType: escrowType\n            }");
insert CallStructArgument(251, 250, "client: client");
insert Identifier(252, 251, "client");
insert Expression(253, 251, "client");
insert Identifier(254, 253, "client");
insert CallStructArgument(255, 250, "resolver: resolver");
insert Identifier(256, 255, "resolver");
insert Expression(257, 255, "resolver");
insert Identifier(258, 257, "resolver");
insert CallStructArgument(259, 250, "resolverType: resolverType");
insert Identifier(260, 259, "resolverType");
insert Expression(261, 259, "resolverType");
insert Identifier(262, 261, "resolverType");
insert CallStructArgument(263, 250, "token: token");
insert Identifier(264, 263, "token");
insert Expression(265, 263, "token");
insert Identifier(266, 265, "token");
insert CallStructArgument(267, 250, "terminationTime: terminationTime");
insert Identifier(268, 267, "terminationTime");
insert Expression(269, 267, "terminationTime");
insert Identifier(270, 269, "terminationTime");
insert CallStructArgument(271, 250, "details: details");
insert Identifier(272, 271, "details");
insert Expression(273, 271, "details");
insert Identifier(274, 273, "details");
insert CallStructArgument(275, 250, "provider: provider");
insert Identifier(276, 275, "provider");
insert Expression(277, 275, "provider");
insert Identifier(278, 277, "provider");
insert CallStructArgument(279, 250, "providerReceiver: providerReceiver");
insert Identifier(280, 279, "providerReceiver");
insert Expression(281, 279, "providerReceiver");
insert Identifier(282, 281, "providerReceiver");
insert CallStructArgument(283, 250, "requireVerification: requireVerification");
insert Identifier(284, 283, "requireVerification");
insert Expression(285, 283, "requireVerification");
insert Identifier(286, 285, "requireVerification");
insert CallStructArgument(287, 250, "escrowType: escrowType");
insert Identifier(288, 287, "escrowType");
insert Expression(289, 287, "escrowType");
insert Identifier(290, 289, "escrowType");
insert Comment(291, 24, "/// @notice Internal function to deploy a new escrow contract with provided details and milestone amounts");
insert Comment(292, 24, "/// @param _milestoneAmounts Array representing the milestone payment amounts");
insert Comment(293, 24, "/// @param _escrowData Encoded escrow data");
insert Comment(294, 24, "/// @param _fundAmount Total amount to be funded into the escrow");
insert Comment(295, 24, "/// @return escrow Address of the newly deployed escrow");
insert FunctionDefinition(296, 24, "function deployEscrow(\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _escrowData,\n        uint256 _fundAmount\n    ) public payable nonReentrant returns (address escrow) {\n        // Decode the provided escrow data\n        EscrowData memory escrowData = _decodeEscrowData(_escrowData);\n\n        // Prepare the details for the escrow creation\n        bytes memory escrowDetails = abi.encode(\n            escrowData.client,\n            escrowData.resolverType,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            escrowData.requireVerification,\n            address(escrowFactory),\n            escrowData.providerReceiver\n        );\n\n        // Deploy the new escrow contract using the factory\n        escrow = escrowFactory.create(\n            escrowData.provider,\n            _milestoneAmounts,\n            escrowDetails,\n            escrowData.escrowType\n        );\n\n        // Ensure escrow creation was successful\n        if (escrow == address(0)) revert EscrowNotCreated();\n\n        if (escrowData.token == address(wrappedNativeToken) && msg.value > 0) {\n            // Ensure the fund amount is valid\n            if (msg.value != _fundAmount) revert InvalidFundAmount();\n\n            // Transfer the native fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            wrappedNativeToken.deposit{value: _fundAmount}();\n\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransfer(escrow, _fundAmount);\n        } else {\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransferFrom(\n                msg.sender,\n                escrow,\n                _fundAmount\n            );\n        }\n\n        // Emit an event for the escrow creation\n        emit EscrowCreated(escrow, escrowData.token, _fundAmount);\n    }");
insert Identifier(297, 296, "deployEscrow");
insert Parameter(298, 296, "uint256[] memory _milestoneAmounts");
insert TypeName(299, 298, "uint256[]");
insert TypeName(300, 299, "uint256");
insert PrimitiveType(301, 300, "uint256");
insert Identifier(302, 298, "_milestoneAmounts");
insert Parameter(303, 296, "bytes calldata _escrowData");
insert TypeName(304, 303, "bytes");
insert PrimitiveType(305, 304, "bytes");
insert Identifier(306, 303, "_escrowData");
insert Parameter(307, 296, "uint256 _fundAmount");
insert TypeName(308, 307, "uint256");
insert PrimitiveType(309, 308, "uint256");
insert Identifier(310, 307, "_fundAmount");
insert Visibility(311, 296, "public");
insert StateMutability(312, 296, "payable");
insert ModifierInvocation(313, 296, "nonReentrant");
insert Identifier(314, 313, "nonReentrant");
insert ReturnTypeDefinition(315, 296, "returns (address escrow)");
insert Parameter(316, 315, "address escrow");
insert TypeName(317, 316, "address");
insert PrimitiveType(318, 317, "address");
insert Identifier(319, 316, "escrow");
insert FunctionBody(320, 296, "{\n        // Decode the provided escrow data\n        EscrowData memory escrowData = _decodeEscrowData(_escrowData);\n\n        // Prepare the details for the escrow creation\n        bytes memory escrowDetails = abi.encode(\n            escrowData.client,\n            escrowData.resolverType,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            escrowData.requireVerification,\n            address(escrowFactory),\n            escrowData.providerReceiver\n        );\n\n        // Deploy the new escrow contract using the factory\n        escrow = escrowFactory.create(\n            escrowData.provider,\n            _milestoneAmounts,\n            escrowDetails,\n            escrowData.escrowType\n        );\n\n        // Ensure escrow creation was successful\n        if (escrow == address(0)) revert EscrowNotCreated();\n\n        if (escrowData.token == address(wrappedNativeToken) && msg.value > 0) {\n            // Ensure the fund amount is valid\n            if (msg.value != _fundAmount) revert InvalidFundAmount();\n\n            // Transfer the native fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            wrappedNativeToken.deposit{value: _fundAmount}();\n\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransfer(escrow, _fundAmount);\n        } else {\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransferFrom(\n                msg.sender,\n                escrow,\n                _fundAmount\n            );\n        }\n\n        // Emit an event for the escrow creation\n        emit EscrowCreated(escrow, escrowData.token, _fundAmount);\n    }");
insert Comment(321, 320, "// Decode the provided escrow data");
insert Statement(322, 320, "EscrowData memory escrowData = _decodeEscrowData(_escrowData);");
insert VariableDeclarationStatement(323, 322, "EscrowData memory escrowData = _decodeEscrowData(_escrowData);");
insert VariableDeclaration(324, 323, "EscrowData memory escrowData");
insert TypeName(325, 324, "EscrowData");
insert UserDefinedType(326, 325, "EscrowData");
insert Identifier(327, 326, "EscrowData");
insert Identifier(328, 324, "escrowData");
insert Expression(329, 323, "_decodeEscrowData(_escrowData)");
insert CallExpression(330, 329, "_decodeEscrowData(_escrowData)");
insert Expression(331, 330, "_decodeEscrowData");
insert Identifier(332, 331, "_decodeEscrowData");
insert CallArgument(333, 330, "_escrowData");
insert Expression(334, 333, "_escrowData");
insert Identifier(335, 334, "_escrowData");
insert Comment(336, 320, "// Prepare the details for the escrow creation");
insert Statement(337, 320, "bytes memory escrowDetails = abi.encode(\n            escrowData.client,\n            escrowData.resolverType,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            escrowData.requireVerification,\n            address(escrowFactory),\n            escrowData.providerReceiver\n        );");
insert VariableDeclarationStatement(338, 337, "bytes memory escrowDetails = abi.encode(\n            escrowData.client,\n            escrowData.resolverType,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            escrowData.requireVerification,\n            address(escrowFactory),\n            escrowData.providerReceiver\n        );");
insert VariableDeclaration(339, 338, "bytes memory escrowDetails");
insert TypeName(340, 339, "bytes");
insert PrimitiveType(341, 340, "bytes");
insert Identifier(342, 339, "escrowDetails");
insert Expression(343, 338, "abi.encode(\n            escrowData.client,\n            escrowData.resolverType,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            escrowData.requireVerification,\n            address(escrowFactory),\n            escrowData.providerReceiver\n        )");
insert CallExpression(344, 343, "abi.encode(\n            escrowData.client,\n            escrowData.resolverType,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            escrowData.requireVerification,\n            address(escrowFactory),\n            escrowData.providerReceiver\n        )");
insert Expression(345, 344, "abi.encode");
insert MemberExpression(346, 345, "abi.encode");
insert Identifier(347, 346, "abi");
insert Identifier(348, 346, "encode");
insert CallArgument(349, 344, "escrowData.client");
insert Expression(350, 349, "escrowData.client");
insert MemberExpression(351, 350, "escrowData.client");
insert Identifier(352, 351, "escrowData");
insert Identifier(353, 351, "client");
insert CallArgument(354, 344, "escrowData.resolverType");
insert Expression(355, 354, "escrowData.resolverType");
insert MemberExpression(356, 355, "escrowData.resolverType");
insert Identifier(357, 356, "escrowData");
insert Identifier(358, 356, "resolverType");
insert CallArgument(359, 344, "escrowData.resolver");
insert Expression(360, 359, "escrowData.resolver");
insert MemberExpression(361, 360, "escrowData.resolver");
insert Identifier(362, 361, "escrowData");
insert Identifier(363, 361, "resolver");
insert CallArgument(364, 344, "escrowData.token");
insert Expression(365, 364, "escrowData.token");
insert MemberExpression(366, 365, "escrowData.token");
insert Identifier(367, 366, "escrowData");
insert Identifier(368, 366, "token");
insert CallArgument(369, 344, "escrowData.terminationTime");
insert Expression(370, 369, "escrowData.terminationTime");
insert MemberExpression(371, 370, "escrowData.terminationTime");
insert Identifier(372, 371, "escrowData");
insert Identifier(373, 371, "terminationTime");
insert CallArgument(374, 344, "escrowData.details");
insert Expression(375, 374, "escrowData.details");
insert MemberExpression(376, 375, "escrowData.details");
insert Identifier(377, 376, "escrowData");
insert Identifier(378, 376, "details");
insert CallArgument(379, 344, "wrappedNativeToken");
insert Expression(380, 379, "wrappedNativeToken");
insert Identifier(381, 380, "wrappedNativeToken");
insert CallArgument(382, 344, "escrowData.requireVerification");
insert Expression(383, 382, "escrowData.requireVerification");
insert MemberExpression(384, 383, "escrowData.requireVerification");
insert Identifier(385, 384, "escrowData");
insert Identifier(386, 384, "requireVerification");
insert CallArgument(387, 344, "address(escrowFactory)");
insert Expression(388, 387, "address(escrowFactory)");
insert TypeCastExpression(389, 388, "address(escrowFactory)");
insert PrimitiveType(390, 389, "address");
insert CallArgument(391, 389, "escrowFactory");
insert Expression(392, 391, "escrowFactory");
insert Identifier(393, 392, "escrowFactory");
insert CallArgument(394, 344, "escrowData.providerReceiver");
insert Expression(395, 394, "escrowData.providerReceiver");
insert MemberExpression(396, 395, "escrowData.providerReceiver");
insert Identifier(397, 396, "escrowData");
insert Identifier(398, 396, "providerReceiver");
insert Comment(399, 320, "// Deploy the new escrow contract using the factory");
insert Statement(400, 320, "escrow = escrowFactory.create(\n            escrowData.provider,\n            _milestoneAmounts,\n            escrowDetails,\n            escrowData.escrowType\n        );");
insert ExpressionStatement(401, 400, "escrow = escrowFactory.create(\n            escrowData.provider,\n            _milestoneAmounts,\n            escrowDetails,\n            escrowData.escrowType\n        );");
insert Expression(402, 401, "escrow = escrowFactory.create(\n            escrowData.provider,\n            _milestoneAmounts,\n            escrowDetails,\n            escrowData.escrowType\n        )");
insert AssignmentExpression(403, 402, "escrow = escrowFactory.create(\n            escrowData.provider,\n            _milestoneAmounts,\n            escrowDetails,\n            escrowData.escrowType\n        )");
insert Expression(404, 403, "escrow");
insert Identifier(405, 404, "escrow");
insert Expression(406, 403, "escrowFactory.create(\n            escrowData.provider,\n            _milestoneAmounts,\n            escrowDetails,\n            escrowData.escrowType\n        )");
insert CallExpression(407, 406, "escrowFactory.create(\n            escrowData.provider,\n            _milestoneAmounts,\n            escrowDetails,\n            escrowData.escrowType\n        )");
insert Expression(408, 407, "escrowFactory.create");
insert MemberExpression(409, 408, "escrowFactory.create");
insert Identifier(410, 409, "escrowFactory");
insert Identifier(411, 409, "create");
insert CallArgument(412, 407, "escrowData.provider");
insert Expression(413, 412, "escrowData.provider");
insert MemberExpression(414, 413, "escrowData.provider");
insert Identifier(415, 414, "escrowData");
insert Identifier(416, 414, "provider");
insert CallArgument(417, 407, "_milestoneAmounts");
insert Expression(418, 417, "_milestoneAmounts");
insert Identifier(419, 418, "_milestoneAmounts");
insert CallArgument(420, 407, "escrowDetails");
insert Expression(421, 420, "escrowDetails");
insert Identifier(422, 421, "escrowDetails");
insert CallArgument(423, 407, "escrowData.escrowType");
insert Expression(424, 423, "escrowData.escrowType");
insert MemberExpression(425, 424, "escrowData.escrowType");
insert Identifier(426, 425, "escrowData");
insert Identifier(427, 425, "escrowType");
insert Comment(428, 320, "// Ensure escrow creation was successful");
insert Statement(429, 320, "if (escrow == address(0)) revert EscrowNotCreated();");
insert IfStatement(430, 429, "if (escrow == address(0)) revert EscrowNotCreated();");
insert Expression(431, 430, "escrow == address(0)");
insert BinaryExpression(432, 431, "escrow == address(0)");
insert Expression(433, 432, "escrow");
insert Identifier(434, 433, "escrow");
insert Expression(435, 432, "address(0)");
insert TypeCastExpression(436, 435, "address(0)");
insert PrimitiveType(437, 436, "address");
insert CallArgument(438, 436, "0");
insert Expression(439, 438, "0");
insert NumberLiteral(440, 439, "0");
insert Statement(441, 430, "revert EscrowNotCreated();");
insert RevertStatement(442, 441, "revert EscrowNotCreated();");
insert Expression(443, 442, "EscrowNotCreated");
insert Identifier(444, 443, "EscrowNotCreated");
insert RevertArguments(445, 442, "()");
insert Statement(446, 320, "if (escrowData.token == address(wrappedNativeToken) && msg.value > 0) {\n            // Ensure the fund amount is valid\n            if (msg.value != _fundAmount) revert InvalidFundAmount();\n\n            // Transfer the native fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            wrappedNativeToken.deposit{value: _fundAmount}();\n\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransfer(escrow, _fundAmount);\n        } else {\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransferFrom(\n                msg.sender,\n                escrow,\n                _fundAmount\n            );\n        }");
insert IfStatement(447, 446, "if (escrowData.token == address(wrappedNativeToken) && msg.value > 0) {\n            // Ensure the fund amount is valid\n            if (msg.value != _fundAmount) revert InvalidFundAmount();\n\n            // Transfer the native fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            wrappedNativeToken.deposit{value: _fundAmount}();\n\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransfer(escrow, _fundAmount);\n        } else {\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransferFrom(\n                msg.sender,\n                escrow,\n                _fundAmount\n            );\n        }");
insert Expression(448, 447, "escrowData.token == address(wrappedNativeToken) && msg.value > 0");
insert BinaryExpression(449, 448, "escrowData.token == address(wrappedNativeToken) && msg.value > 0");
insert Expression(450, 449, "escrowData.token == address(wrappedNativeToken) && msg.value");
insert MemberExpression(451, 450, "escrowData.token == address(wrappedNativeToken) && msg.value");
insert Expression(452, 451, "escrowData.token == address(wrappedNativeToken) && msg");
insert BinaryExpression(453, 452, "escrowData.token == address(wrappedNativeToken) && msg");
insert Expression(454, 453, "escrowData.token == address(wrappedNativeToken)");
insert BinaryExpression(455, 454, "escrowData.token == address(wrappedNativeToken)");
insert Expression(456, 455, "escrowData.token");
insert MemberExpression(457, 456, "escrowData.token");
insert Identifier(458, 457, "escrowData");
insert Identifier(459, 457, "token");
insert Expression(460, 455, "address(wrappedNativeToken)");
insert TypeCastExpression(461, 460, "address(wrappedNativeToken)");
insert PrimitiveType(462, 461, "address");
insert CallArgument(463, 461, "wrappedNativeToken");
insert Expression(464, 463, "wrappedNativeToken");
insert Identifier(465, 464, "wrappedNativeToken");
insert Expression(466, 453, "msg");
insert Identifier(467, 466, "msg");
insert Identifier(468, 451, "value");
insert Expression(469, 449, "0");
insert NumberLiteral(470, 469, "0");
insert Statement(471, 447, "{\n            // Ensure the fund amount is valid\n            if (msg.value != _fundAmount) revert InvalidFundAmount();\n\n            // Transfer the native fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            wrappedNativeToken.deposit{value: _fundAmount}();\n\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransfer(escrow, _fundAmount);\n        }");
insert BlockStatement(472, 471, "{\n            // Ensure the fund amount is valid\n            if (msg.value != _fundAmount) revert InvalidFundAmount();\n\n            // Transfer the native fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            wrappedNativeToken.deposit{value: _fundAmount}();\n\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransfer(escrow, _fundAmount);\n        }");
insert Comment(473, 472, "// Ensure the fund amount is valid");
insert Statement(474, 472, "if (msg.value != _fundAmount) revert InvalidFundAmount();");
insert IfStatement(475, 474, "if (msg.value != _fundAmount) revert InvalidFundAmount();");
insert Expression(476, 475, "msg.value != _fundAmount");
insert BinaryExpression(477, 476, "msg.value != _fundAmount");
insert Expression(478, 477, "msg.value");
insert MemberExpression(479, 478, "msg.value");
insert Identifier(480, 479, "msg");
insert Identifier(481, 479, "value");
insert Expression(482, 477, "_fundAmount");
insert Identifier(483, 482, "_fundAmount");
insert Statement(484, 475, "revert InvalidFundAmount();");
insert RevertStatement(485, 484, "revert InvalidFundAmount();");
insert Expression(486, 485, "InvalidFundAmount");
insert Identifier(487, 486, "InvalidFundAmount");
insert RevertArguments(488, 485, "()");
insert Comment(489, 472, "// Transfer the native fund amount to the newly created escrow contract");
insert Comment(490, 472, "// Require the client to approve the fund transfer");
insert Statement(491, 472, "wrappedNativeToken.deposit{value: _fundAmount}();");
insert ExpressionStatement(492, 491, "wrappedNativeToken.deposit{value: _fundAmount}();");
insert Expression(493, 492, "wrappedNativeToken.deposit{value: _fundAmount}()");
insert CallExpression(494, 493, "wrappedNativeToken.deposit{value: _fundAmount}()");
insert Expression(495, 494, "wrappedNativeToken.deposit{value: _fundAmount}");
insert StructExpression(496, 495, "wrappedNativeToken.deposit{value: _fundAmount}");
insert Expression(497, 496, "wrappedNativeToken.deposit");
insert MemberExpression(498, 497, "wrappedNativeToken.deposit");
insert Identifier(499, 498, "wrappedNativeToken");
insert Identifier(500, 498, "deposit");
insert StructFieldAssignment(501, 496, "value: _fundAmount");
insert Identifier(502, 501, "value");
insert Expression(503, 501, "_fundAmount");
insert Identifier(504, 503, "_fundAmount");
insert Comment(505, 472, "// Transfer the fund amount to the newly created escrow contract");
insert Comment(506, 472, "// Require the client to approve the fund transfer");
insert Statement(507, 472, "IERC20(escrowData.token).safeTransfer(escrow, _fundAmount);");
insert ExpressionStatement(508, 507, "IERC20(escrowData.token).safeTransfer(escrow, _fundAmount);");
insert Expression(509, 508, "IERC20(escrowData.token).safeTransfer(escrow, _fundAmount)");
insert CallExpression(510, 509, "IERC20(escrowData.token).safeTransfer(escrow, _fundAmount)");
insert Expression(511, 510, "IERC20(escrowData.token).safeTransfer");
insert MemberExpression(512, 511, "IERC20(escrowData.token).safeTransfer");
insert Expression(513, 512, "IERC20(escrowData.token)");
insert CallExpression(514, 513, "IERC20(escrowData.token)");
insert Expression(515, 514, "IERC20");
insert Identifier(516, 515, "IERC20");
insert CallArgument(517, 514, "escrowData.token");
insert Expression(518, 517, "escrowData.token");
insert MemberExpression(519, 518, "escrowData.token");
insert Identifier(520, 519, "escrowData");
insert Identifier(521, 519, "token");
insert Identifier(522, 512, "safeTransfer");
insert CallArgument(523, 510, "escrow");
insert Expression(524, 523, "escrow");
insert Identifier(525, 524, "escrow");
insert CallArgument(526, 510, "_fundAmount");
insert Expression(527, 526, "_fundAmount");
insert Identifier(528, 527, "_fundAmount");
insert Statement(529, 447, "{\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransferFrom(\n                msg.sender,\n                escrow,\n                _fundAmount\n            );\n        }");
insert BlockStatement(530, 529, "{\n            // Transfer the fund amount to the newly created escrow contract\n            // Require the client to approve the fund transfer\n            IERC20(escrowData.token).safeTransferFrom(\n                msg.sender,\n                escrow,\n                _fundAmount\n            );\n        }");
insert Comment(531, 530, "// Transfer the fund amount to the newly created escrow contract");
insert Comment(532, 530, "// Require the client to approve the fund transfer");
insert Statement(533, 530, "IERC20(escrowData.token).safeTransferFrom(\n                msg.sender,\n                escrow,\n                _fundAmount\n            );");
insert ExpressionStatement(534, 533, "IERC20(escrowData.token).safeTransferFrom(\n                msg.sender,\n                escrow,\n                _fundAmount\n            );");
insert Expression(535, 534, "IERC20(escrowData.token).safeTransferFrom(\n                msg.sender,\n                escrow,\n                _fundAmount\n            )");
insert CallExpression(536, 535, "IERC20(escrowData.token).safeTransferFrom(\n                msg.sender,\n                escrow,\n                _fundAmount\n            )");
insert Expression(537, 536, "IERC20(escrowData.token).safeTransferFrom");
insert MemberExpression(538, 537, "IERC20(escrowData.token).safeTransferFrom");
insert Expression(539, 538, "IERC20(escrowData.token)");
insert CallExpression(540, 539, "IERC20(escrowData.token)");
insert Expression(541, 540, "IERC20");
insert Identifier(542, 541, "IERC20");
insert CallArgument(543, 540, "escrowData.token");
insert Expression(544, 543, "escrowData.token");
insert MemberExpression(545, 544, "escrowData.token");
insert Identifier(546, 545, "escrowData");
insert Identifier(547, 545, "token");
insert Identifier(548, 538, "safeTransferFrom");
insert CallArgument(549, 536, "msg.sender");
insert Expression(550, 549, "msg.sender");
insert MemberExpression(551, 550, "msg.sender");
insert Identifier(552, 551, "msg");
insert Identifier(553, 551, "sender");
insert CallArgument(554, 536, "escrow");
insert Expression(555, 554, "escrow");
insert Identifier(556, 555, "escrow");
insert CallArgument(557, 536, "_fundAmount");
insert Expression(558, 557, "_fundAmount");
insert Identifier(559, 558, "_fundAmount");
insert Comment(560, 320, "// Emit an event for the escrow creation");
insert Statement(561, 320, "emit EscrowCreated(escrow, escrowData.token, _fundAmount);");
insert EmitStatement(562, 561, "emit EscrowCreated(escrow, escrowData.token, _fundAmount);");
insert Expression(563, 562, "EscrowCreated");
insert Identifier(564, 563, "EscrowCreated");
insert CallArgument(565, 562, "escrow");
insert Expression(566, 565, "escrow");
insert Identifier(567, 566, "escrow");
insert CallArgument(568, 562, "escrowData.token");
insert Expression(569, 568, "escrowData.token");
insert MemberExpression(570, 569, "escrowData.token");
insert Identifier(571, 570, "escrowData");
insert Identifier(572, 570, "token");
insert CallArgument(573, 562, "_fundAmount");
insert Expression(574, 573, "_fundAmount");
insert Identifier(575, 574, "_fundAmount");
insert SourceFile(576, 0, "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/// @title Spoils Manager Contract\n/// @notice Manages the distribution of spoils, allowing an owner to set a receiver and adjust the spoils percentage distributed to that receiver.\ncontract SpoilsManager is OwnableUpgradeable {\n    /// @dev The scale used to calculate the spoils percentage\n    uint32 public SPLIT_PERCENTAGE_SCALE; // 100 * SPLIT_PERCENTAGE_SCALE = 100%\n\n    /// @notice The percentage of spoils to be sent to the owner's receiver\n    uint32 public spoils;\n\n    /// @notice The address of the owner's receiver\n    address public receiver;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initialize the SpoilsManager contract\n     * @param _spoils The percentage of spoils to be sent to the owner's receiver\n     * @param _percentageScale The scale used to calculate the spoils percentage\n     * @param _receiver The address of the owner's receiver\n     * @param _newOwner Address of the initial owner of the SpoilsManager contract\n     */\n    function init(\n        uint32 _spoils,\n        uint32 _percentageScale,\n        address _receiver,\n        address _newOwner\n    ) external virtual initializer {\n        spoils = _spoils;\n        receiver = _receiver;\n        __Ownable_init(_newOwner);\n        SPLIT_PERCENTAGE_SCALE = _percentageScale;\n    }\n\n    /**\n     * @dev Set the spoils amount to be sent to the owner's receiver\n     * @param _spoils The percentage of spoils to be sent to the owner's receiver\n     */\n    function setSpoils(uint32 _spoils) external onlyOwner {\n        spoils = _spoils;\n    }\n\n    /**\n     * @dev Set the owner's receiver address\n     * @param _receiver The address of the owner's receiver\n     */\n    function setReceiver(address _receiver) external onlyOwner {\n        receiver = _receiver;\n    }\n\n    /**\n     * @dev Get the spoils amount to be sent to the owner's receiver\n     * @return The percentage of spoils to be sent to the owner's receiver\n     */\n    function getSpoils() external view returns (uint32) {\n        return spoils * SPLIT_PERCENTAGE_SCALE;\n    }\n}\n");
insert Comment(577, 576, "// SPDX-License-Identifier: MIT");
insert PragmaDirective(578, 576, "pragma solidity ^0.8.20;");
insert SolidityPragmaToken(579, 578, "solidity ^0.8.20");
insert SolidityVersionComparisonOperator(580, 579, " ^");
insert SolidityVersion(581, 579, "0.8.20");
insert ImportDirective(582, 576, "import {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";");
insert Identifier(583, 582, "OwnableUpgradeable");
insert Comment(584, 576, "/// @title Spoils Manager Contract");
insert Comment(585, 576, "/// @notice Manages the distribution of spoils, allowing an owner to set a receiver and adjust the spoils percentage distributed to that receiver.");
insert ContractDeclaration(586, 576, "contract SpoilsManager is OwnableUpgradeable {\n    /// @dev The scale used to calculate the spoils percentage\n    uint32 public SPLIT_PERCENTAGE_SCALE; // 100 * SPLIT_PERCENTAGE_SCALE = 100%\n\n    /// @notice The percentage of spoils to be sent to the owner's receiver\n    uint32 public spoils;\n\n    /// @notice The address of the owner's receiver\n    address public receiver;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initialize the SpoilsManager contract\n     * @param _spoils The percentage of spoils to be sent to the owner's receiver\n     * @param _percentageScale The scale used to calculate the spoils percentage\n     * @param _receiver The address of the owner's receiver\n     * @param _newOwner Address of the initial owner of the SpoilsManager contract\n     */\n    function init(\n        uint32 _spoils,\n        uint32 _percentageScale,\n        address _receiver,\n        address _newOwner\n    ) external virtual initializer {\n        spoils = _spoils;\n        receiver = _receiver;\n        __Ownable_init(_newOwner);\n        SPLIT_PERCENTAGE_SCALE = _percentageScale;\n    }\n\n    /**\n     * @dev Set the spoils amount to be sent to the owner's receiver\n     * @param _spoils The percentage of spoils to be sent to the owner's receiver\n     */\n    function setSpoils(uint32 _spoils) external onlyOwner {\n        spoils = _spoils;\n    }\n\n    /**\n     * @dev Set the owner's receiver address\n     * @param _receiver The address of the owner's receiver\n     */\n    function setReceiver(address _receiver) external onlyOwner {\n        receiver = _receiver;\n    }\n\n    /**\n     * @dev Get the spoils amount to be sent to the owner's receiver\n     * @return The percentage of spoils to be sent to the owner's receiver\n     */\n    function getSpoils() external view returns (uint32) {\n        return spoils * SPLIT_PERCENTAGE_SCALE;\n    }\n}");
insert Identifier(587, 586, "SpoilsManager");
insert InheritanceSpecifier(588, 586, "OwnableUpgradeable");
insert UserDefinedType(589, 588, "OwnableUpgradeable");
insert Identifier(590, 589, "OwnableUpgradeable");
insert ContractBody(591, 586, "{\n    /// @dev The scale used to calculate the spoils percentage\n    uint32 public SPLIT_PERCENTAGE_SCALE; // 100 * SPLIT_PERCENTAGE_SCALE = 100%\n\n    /// @notice The percentage of spoils to be sent to the owner's receiver\n    uint32 public spoils;\n\n    /// @notice The address of the owner's receiver\n    address public receiver;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initialize the SpoilsManager contract\n     * @param _spoils The percentage of spoils to be sent to the owner's receiver\n     * @param _percentageScale The scale used to calculate the spoils percentage\n     * @param _receiver The address of the owner's receiver\n     * @param _newOwner Address of the initial owner of the SpoilsManager contract\n     */\n    function init(\n        uint32 _spoils,\n        uint32 _percentageScale,\n        address _receiver,\n        address _newOwner\n    ) external virtual initializer {\n        spoils = _spoils;\n        receiver = _receiver;\n        __Ownable_init(_newOwner);\n        SPLIT_PERCENTAGE_SCALE = _percentageScale;\n    }\n\n    /**\n     * @dev Set the spoils amount to be sent to the owner's receiver\n     * @param _spoils The percentage of spoils to be sent to the owner's receiver\n     */\n    function setSpoils(uint32 _spoils) external onlyOwner {\n        spoils = _spoils;\n    }\n\n    /**\n     * @dev Set the owner's receiver address\n     * @param _receiver The address of the owner's receiver\n     */\n    function setReceiver(address _receiver) external onlyOwner {\n        receiver = _receiver;\n    }\n\n    /**\n     * @dev Get the spoils amount to be sent to the owner's receiver\n     * @return The percentage of spoils to be sent to the owner's receiver\n     */\n    function getSpoils() external view returns (uint32) {\n        return spoils * SPLIT_PERCENTAGE_SCALE;\n    }\n}");
insert Comment(592, 591, "/// @dev The scale used to calculate the spoils percentage");
insert StateVariableDeclaration(593, 591, "uint32 public SPLIT_PERCENTAGE_SCALE;");
insert TypeName(594, 593, "uint32");
insert PrimitiveType(595, 594, "uint32");
insert Visibility(596, 593, "public");
insert Identifier(597, 593, "SPLIT_PERCENTAGE_SCALE");
insert Comment(598, 591, "// 100 * SPLIT_PERCENTAGE_SCALE = 100%");
insert Comment(599, 591, "/// @notice The percentage of spoils to be sent to the owner's receiver");
insert StateVariableDeclaration(600, 591, "uint32 public spoils;");
insert TypeName(601, 600, "uint32");
insert PrimitiveType(602, 601, "uint32");
insert Visibility(603, 600, "public");
insert Identifier(604, 600, "spoils");
insert Comment(605, 591, "/// @notice The address of the owner's receiver");
insert StateVariableDeclaration(606, 591, "address public receiver;");
insert TypeName(607, 606, "address");
insert PrimitiveType(608, 607, "address");
insert Visibility(609, 606, "public");
insert Identifier(610, 606, "receiver");
insert ConstructorDefinition(611, 591, "constructor() {\n        _disableInitializers();\n    }");
insert FunctionBody(612, 611, "{\n        _disableInitializers();\n    }");
insert Statement(613, 612, "_disableInitializers();");
insert ExpressionStatement(614, 613, "_disableInitializers();");
insert Expression(615, 614, "_disableInitializers()");
insert CallExpression(616, 615, "_disableInitializers()");
insert Expression(617, 616, "_disableInitializers");
insert Identifier(618, 617, "_disableInitializers");
insert Comment(619, 591, "/**\n     * @dev Initialize the SpoilsManager contract\n     * @param _spoils The percentage of spoils to be sent to the owner's receiver\n     * @param _percentageScale The scale used to calculate the spoils percentage\n     * @param _receiver The address of the owner's receiver\n     * @param _newOwner Address of the initial owner of the SpoilsManager contract\n     */");
insert FunctionDefinition(620, 591, "function init(\n        uint32 _spoils,\n        uint32 _percentageScale,\n        address _receiver,\n        address _newOwner\n    ) external virtual initializer {\n        spoils = _spoils;\n        receiver = _receiver;\n        __Ownable_init(_newOwner);\n        SPLIT_PERCENTAGE_SCALE = _percentageScale;\n    }");
insert Identifier(621, 620, "init");
insert Parameter(622, 620, "uint32 _spoils");
insert TypeName(623, 622, "uint32");
insert PrimitiveType(624, 623, "uint32");
insert Identifier(625, 622, "_spoils");
insert Parameter(626, 620, "uint32 _percentageScale");
insert TypeName(627, 626, "uint32");
insert PrimitiveType(628, 627, "uint32");
insert Identifier(629, 626, "_percentageScale");
insert Parameter(630, 620, "address _receiver");
insert TypeName(631, 630, "address");
insert PrimitiveType(632, 631, "address");
insert Identifier(633, 630, "_receiver");
insert Parameter(634, 620, "address _newOwner");
insert TypeName(635, 634, "address");
insert PrimitiveType(636, 635, "address");
insert Identifier(637, 634, "_newOwner");
insert Visibility(638, 620, "external");
insert Virtual(639, 620, "virtual");
insert ModifierInvocation(640, 620, "initializer");
insert Identifier(641, 640, "initializer");
insert FunctionBody(642, 620, "{\n        spoils = _spoils;\n        receiver = _receiver;\n        __Ownable_init(_newOwner);\n        SPLIT_PERCENTAGE_SCALE = _percentageScale;\n    }");
insert Statement(643, 642, "spoils = _spoils;");
insert ExpressionStatement(644, 643, "spoils = _spoils;");
insert Expression(645, 644, "spoils = _spoils");
insert AssignmentExpression(646, 645, "spoils = _spoils");
insert Expression(647, 646, "spoils");
insert Identifier(648, 647, "spoils");
insert Expression(649, 646, "_spoils");
insert Identifier(650, 649, "_spoils");
insert Statement(651, 642, "receiver = _receiver;");
insert ExpressionStatement(652, 651, "receiver = _receiver;");
insert Expression(653, 652, "receiver = _receiver");
insert AssignmentExpression(654, 653, "receiver = _receiver");
insert Expression(655, 654, "receiver");
insert Identifier(656, 655, "receiver");
insert Expression(657, 654, "_receiver");
insert Identifier(658, 657, "_receiver");
insert Statement(659, 642, "__Ownable_init(_newOwner);");
insert ExpressionStatement(660, 659, "__Ownable_init(_newOwner);");
insert Expression(661, 660, "__Ownable_init(_newOwner)");
insert CallExpression(662, 661, "__Ownable_init(_newOwner)");
insert Expression(663, 662, "__Ownable_init");
insert Identifier(664, 663, "__Ownable_init");
insert CallArgument(665, 662, "_newOwner");
insert Expression(666, 665, "_newOwner");
insert Identifier(667, 666, "_newOwner");
insert Statement(668, 642, "SPLIT_PERCENTAGE_SCALE = _percentageScale;");
insert ExpressionStatement(669, 668, "SPLIT_PERCENTAGE_SCALE = _percentageScale;");
insert Expression(670, 669, "SPLIT_PERCENTAGE_SCALE = _percentageScale");
insert AssignmentExpression(671, 670, "SPLIT_PERCENTAGE_SCALE = _percentageScale");
insert Expression(672, 671, "SPLIT_PERCENTAGE_SCALE");
insert Identifier(673, 672, "SPLIT_PERCENTAGE_SCALE");
insert Expression(674, 671, "_percentageScale");
insert Identifier(675, 674, "_percentageScale");
insert Comment(676, 591, "/**\n     * @dev Set the spoils amount to be sent to the owner's receiver\n     * @param _spoils The percentage of spoils to be sent to the owner's receiver\n     */");
insert FunctionDefinition(677, 591, "function setSpoils(uint32 _spoils) external onlyOwner {\n        spoils = _spoils;\n    }");
insert Identifier(678, 677, "setSpoils");
insert Parameter(679, 677, "uint32 _spoils");
insert TypeName(680, 679, "uint32");
insert PrimitiveType(681, 680, "uint32");
insert Identifier(682, 679, "_spoils");
insert Visibility(683, 677, "external");
insert ModifierInvocation(684, 677, "onlyOwner");
insert Identifier(685, 684, "onlyOwner");
insert FunctionBody(686, 677, "{\n        spoils = _spoils;\n    }");
insert Statement(687, 686, "spoils = _spoils;");
insert ExpressionStatement(688, 687, "spoils = _spoils;");
insert Expression(689, 688, "spoils = _spoils");
insert AssignmentExpression(690, 689, "spoils = _spoils");
insert Expression(691, 690, "spoils");
insert Identifier(692, 691, "spoils");
insert Expression(693, 690, "_spoils");
insert Identifier(694, 693, "_spoils");
insert Comment(695, 591, "/**\n     * @dev Set the owner's receiver address\n     * @param _receiver The address of the owner's receiver\n     */");
insert FunctionDefinition(696, 591, "function setReceiver(address _receiver) external onlyOwner {\n        receiver = _receiver;\n    }");
insert Identifier(697, 696, "setReceiver");
insert Parameter(698, 696, "address _receiver");
insert TypeName(699, 698, "address");
insert PrimitiveType(700, 699, "address");
insert Identifier(701, 698, "_receiver");
insert Visibility(702, 696, "external");
insert ModifierInvocation(703, 696, "onlyOwner");
insert Identifier(704, 703, "onlyOwner");
insert FunctionBody(705, 696, "{\n        receiver = _receiver;\n    }");
insert Statement(706, 705, "receiver = _receiver;");
insert ExpressionStatement(707, 706, "receiver = _receiver;");
insert Expression(708, 707, "receiver = _receiver");
insert AssignmentExpression(709, 708, "receiver = _receiver");
insert Expression(710, 709, "receiver");
insert Identifier(711, 710, "receiver");
insert Expression(712, 709, "_receiver");
insert Identifier(713, 712, "_receiver");
insert Comment(714, 591, "/**\n     * @dev Get the spoils amount to be sent to the owner's receiver\n     * @return The percentage of spoils to be sent to the owner's receiver\n     */");
insert FunctionDefinition(715, 591, "function getSpoils() external view returns (uint32) {\n        return spoils * SPLIT_PERCENTAGE_SCALE;\n    }");
insert Identifier(716, 715, "getSpoils");
insert Visibility(717, 715, "external");
insert StateMutability(718, 715, "view");
insert ReturnTypeDefinition(719, 715, "returns (uint32)");
insert Parameter(720, 719, "uint32");
insert TypeName(721, 720, "uint32");
insert PrimitiveType(722, 721, "uint32");
insert FunctionBody(723, 715, "{\n        return spoils * SPLIT_PERCENTAGE_SCALE;\n    }");
insert Statement(724, 723, "return spoils * SPLIT_PERCENTAGE_SCALE;");
insert ReturnStatement(725, 724, "return spoils * SPLIT_PERCENTAGE_SCALE;");
insert Expression(726, 725, "spoils * SPLIT_PERCENTAGE_SCALE");
insert BinaryExpression(727, 726, "spoils * SPLIT_PERCENTAGE_SCALE");
insert Expression(728, 727, "spoils");
insert Identifier(729, 728, "spoils");
insert Expression(730, 727, "SPLIT_PERCENTAGE_SCALE");
insert Identifier(731, 730, "SPLIT_PERCENTAGE_SCALE");
insert SourceFile(732, 0, "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";\nimport {ISmartInvoice} from \"./interfaces/ISmartInvoice.sol\";\n\n/// @title SmartInvoiceFactory\n/// @notice Factory contract for creating and managing smart invoice instances.\ncontract SmartInvoiceFactory is ISmartInvoiceFactory, AccessControl {\n    uint256 public invoiceCount = 0;\n\n    mapping(uint256 => address) internal _invoices;\n    mapping(address => uint256) public resolutionRates;\n\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    // Implementation Storage\n    mapping(bytes32 => mapping(uint256 => address)) public implementations;\n    mapping(bytes32 => uint256) public currentVersions;\n\n    address public immutable wrappedNativeToken;\n\n    /// @notice Constructor to initialize the factory with a wrapped native token.\n    /// @param _wrappedNativeToken The address of the wrapped native token.\n    constructor(address _wrappedNativeToken) {\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n        wrappedNativeToken = _wrappedNativeToken;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN, msg.sender);\n    }\n\n    /**\n     * @dev Internal function to initialize a new invoice.\n     * @param _invoiceAddress The address of the invoice contract.\n     * @param _recipient The address of the recipient.\n     * @param _amounts The array of amounts associated with the recipient.\n     * @param _data Additional data needed for initialization.\n     * @param _type The type of the invoice.\n     * @param _version The version of the invoice implementation.\n     */\n    function _init(\n        address _invoiceAddress,\n        address _recipient,\n        uint256[] calldata _amounts,\n        bytes calldata _data,\n        bytes32 _type,\n        uint256 _version\n    ) internal {\n        ISmartInvoice(_invoiceAddress).init(_recipient, _amounts, _data);\n\n        uint256 invoiceId = invoiceCount;\n        _invoices[invoiceId] = _invoiceAddress;\n        invoiceCount++;\n\n        emit LogNewInvoice(\n            invoiceId,\n            _invoiceAddress,\n            _amounts,\n            _type,\n            _version\n        );\n    }\n\n    /**\n     * @notice Creates a new smart invoice instance.\n     * @param _recipient The address of the recipient.\n     * @param _amounts The array of amounts associated with the recipient.\n     * @param _data Additional data needed for initialization.\n     * @param _type The type of the invoice.\n     * @return The address of the created invoice.\n     */\n    function create(\n        address _recipient,\n        uint256[] calldata _amounts,\n        bytes calldata _data,\n        bytes32 _type\n    ) external override returns (address) {\n        uint256 _version = currentVersions[_type];\n        address _implementation = implementations[_type][_version];\n        if (_implementation == address(0)) revert ImplementationDoesNotExist();\n\n        address invoiceAddress = Clones.clone(_implementation);\n        _init(invoiceAddress, _recipient, _amounts, _data, _type, _version);\n\n        return invoiceAddress;\n    }\n\n    /**\n     * @notice Predicts the deterministic address of a clone.\n     * @param _type The type of the invoice.\n     * @param _salt The salt used to determine the address.\n     * @return The predicted address of the deterministic clone.\n     */\n    function predictDeterministicAddress(\n        bytes32 _type,\n        bytes32 _salt\n    ) external view override returns (address) {\n        uint256 _version = currentVersions[_type];\n        address _implementation = implementations[_type][_version];\n        return Clones.predictDeterministicAddress(_implementation, _salt);\n    }\n\n    /**\n     * @notice Creates a new smart invoice instance deterministically.\n     * @param _recipient The address of the recipient.\n     * @param _amounts The array of amounts associated with the recipient.\n     * @param _data Additional data needed for initialization.\n     * @param _type The type of the invoice.\n     * @param _salt The salt used to determine the address.\n     * @return The address of the created invoice.\n     */\n    function createDeterministic(\n        address _recipient,\n        uint256[] calldata _amounts,\n        bytes calldata _data,\n        bytes32 _type,\n        bytes32 _salt\n    ) external override returns (address) {\n        uint256 _version = currentVersions[_type];\n        address _implementation = implementations[_type][_version];\n        if (_implementation == address(0)) revert ImplementationDoesNotExist();\n\n        address invoiceAddress = Clones.cloneDeterministic(\n            _implementation,\n            _salt\n        );\n        _init(invoiceAddress, _recipient, _amounts, _data, _type, _version);\n\n        return invoiceAddress;\n    }\n\n    /**\n     * @notice Gets the implementation address for a given type and version.\n     * @param _implementationType The type of the implementation.\n     * @param _implementationVersion The version of the implementation.\n     * @return The address of the implementation.\n     */\n    function getImplementation(\n        bytes32 _implementationType,\n        uint256 _implementationVersion\n    ) external view returns (address) {\n        return implementations[_implementationType][_implementationVersion];\n    }\n\n    /**\n     * @notice Gets the address of an invoice by its index.\n     * @param index The index of the invoice.\n     * @return The address of the invoice.\n     */\n    function getInvoiceAddress(uint256 index) external view returns (address) {\n        return _invoices[index];\n    }\n\n    /**\n     * @notice Updates the resolution rate for a resolver.\n     * @param _resolutionRate The new resolution rate.\n     * @param _details Additional details about the update.\n     */\n    function updateResolutionRate(\n        uint256 _resolutionRate,\n        bytes32 _details\n    ) external {\n        resolutionRates[msg.sender] = _resolutionRate;\n        emit UpdateResolutionRate(msg.sender, _resolutionRate, _details);\n    }\n\n    /**\n     * @notice Gets the resolution rate of a resolver.\n     * @param _resolver The address of the resolver.\n     * @return The resolution rate of the resolver.\n     */\n    function resolutionRateOf(\n        address _resolver\n    ) external view override returns (uint256) {\n        return resolutionRates[_resolver];\n    }\n\n    /**\n     * @notice Adds a new implementation for a given type.\n     * @param _type The type of the invoice.\n     * @param _implementation The address of the new implementation.\n     */\n    function addImplementation(\n        bytes32 _type,\n        address _implementation\n    ) external onlyRole(ADMIN) {\n        if (_implementation == address(0)) revert ZeroAddressImplementation();\n\n        uint256 _version = currentVersions[_type];\n        address currentImplementation = implementations[_type][_version];\n\n        if (currentImplementation == address(0)) {\n            implementations[_type][_version] = _implementation;\n        } else {\n            _version++;\n            implementations[_type][_version] = _implementation;\n            currentVersions[_type] = _version;\n        }\n\n        emit AddImplementation(_type, _version, _implementation);\n    }\n}\n");
insert Comment(733, 732, "// SPDX-License-Identifier: MIT");
insert PragmaDirective(734, 732, "pragma solidity ^0.8.20;");
insert SolidityPragmaToken(735, 734, "solidity ^0.8.20");
insert SolidityVersionComparisonOperator(736, 735, " ^");
insert SolidityVersion(737, 735, "0.8.20");
insert ImportDirective(738, 732, "import {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";");
insert Identifier(739, 738, "Clones");
insert ImportDirective(740, 732, "import {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";");
insert Identifier(741, 740, "AccessControl");
insert ImportDirective(742, 732, "import {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";");
insert Identifier(743, 742, "ISmartInvoiceFactory");
insert ImportDirective(744, 732, "import {ISmartInvoice} from \"./interfaces/ISmartInvoice.sol\";");
insert Identifier(745, 744, "ISmartInvoice");
insert Comment(746, 732, "/// @title SmartInvoiceFactory");
insert Comment(747, 732, "/// @notice Factory contract for creating and managing smart invoice instances.");
insert ContractDeclaration(748, 732, "contract SmartInvoiceFactory is ISmartInvoiceFactory, AccessControl {\n    uint256 public invoiceCount = 0;\n\n    mapping(uint256 => address) internal _invoices;\n    mapping(address => uint256) public resolutionRates;\n\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    // Implementation Storage\n    mapping(bytes32 => mapping(uint256 => address)) public implementations;\n    mapping(bytes32 => uint256) public currentVersions;\n\n    address public immutable wrappedNativeToken;\n\n    /// @notice Constructor to initialize the factory with a wrapped native token.\n    /// @param _wrappedNativeToken The address of the wrapped native token.\n    constructor(address _wrappedNativeToken) {\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n        wrappedNativeToken = _wrappedNativeToken;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN, msg.sender);\n    }\n\n    /**\n     * @dev Internal function to initialize a new invoice.\n     * @param _invoiceAddress The address of the invoice contract.\n     * @param _recipient The address of the recipient.\n     * @param _amounts The array of amounts associated with the recipient.\n     * @param _data Additional data needed for initialization.\n     * @param _type The type of the invoice.\n     * @param _version The version of the invoice implementation.\n     */\n    function _init(\n        address _invoiceAddress,\n        address _recipient,\n        uint256[] calldata _amounts,\n        bytes calldata _data,\n        bytes32 _type,\n        uint256 _version\n    ) internal {\n        ISmartInvoice(_invoiceAddress).init(_recipient, _amounts, _data);\n\n        uint256 invoiceId = invoiceCount;\n        _invoices[invoiceId] = _invoiceAddress;\n        invoiceCount++;\n\n        emit LogNewInvoice(\n            invoiceId,\n            _invoiceAddress,\n            _amounts,\n            _type,\n            _version\n        );\n    }\n\n    /**\n     * @notice Creates a new smart invoice instance.\n     * @param _recipient The address of the recipient.\n     * @param _amounts The array of amounts associated with the recipient.\n     * @param _data Additional data needed for initialization.\n     * @param _type The type of the invoice.\n     * @return The address of the created invoice.\n     */\n    function create(\n        address _recipient,\n        uint256[] calldata _amounts,\n        bytes calldata _data,\n        bytes32 _type\n    ) external override returns (address) {\n        uint256 _version = currentVersions[_type];\n        address _implementation = implementations[_type][_version];\n        if (_implementation == address(0)) revert ImplementationDoesNotExist();\n\n        address invoiceAddress = Clones.clone(_implementation);\n        _init(invoiceAddress, _recipient, _amounts, _data, _type, _version);\n\n        return invoiceAddress;\n    }\n\n    /**\n     * @notice Predicts the deterministic address of a clone.\n     * @param _type The type of the invoice.\n     * @param _salt The salt used to determine the address.\n     * @return The predicted address of the deterministic clone.\n     */\n    function predictDeterministicAddress(\n        bytes32 _type,\n        bytes32 _salt\n    ) external view override returns (address) {\n        uint256 _version = currentVersions[_type];\n        address _implementation = implementations[_type][_version];\n        return Clones.predictDeterministicAddress(_implementation, _salt);\n    }\n\n    /**\n     * @notice Creates a new smart invoice instance deterministically.\n     * @param _recipient The address of the recipient.\n     * @param _amounts The array of amounts associated with the recipient.\n     * @param _data Additional data needed for initialization.\n     * @param _type The type of the invoice.\n     * @param _salt The salt used to determine the address.\n     * @return The address of the created invoice.\n     */\n    function createDeterministic(\n        address _recipient,\n        uint256[] calldata _amounts,\n        bytes calldata _data,\n        bytes32 _type,\n        bytes32 _salt\n    ) external override returns (address) {\n        uint256 _version = currentVersions[_type];\n        address _implementation = implementations[_type][_version];\n        if (_implementation == address(0)) revert ImplementationDoesNotExist();\n\n        address invoiceAddress = Clones.cloneDeterministic(\n            _implementation,\n            _salt\n        );\n        _init(invoiceAddress, _recipient, _amounts, _data, _type, _version);\n\n        return invoiceAddress;\n    }\n\n    /**\n     * @notice Gets the implementation address for a given type and version.\n     * @param _implementationType The type of the implementation.\n     * @param _implementationVersion The version of the implementation.\n     * @return The address of the implementation.\n     */\n    function getImplementation(\n        bytes32 _implementationType,\n        uint256 _implementationVersion\n    ) external view returns (address) {\n        return implementations[_implementationType][_implementationVersion];\n    }\n\n    /**\n     * @notice Gets the address of an invoice by its index.\n     * @param index The index of the invoice.\n     * @return The address of the invoice.\n     */\n    function getInvoiceAddress(uint256 index) external view returns (address) {\n        return _invoices[index];\n    }\n\n    /**\n     * @notice Updates the resolution rate for a resolver.\n     * @param _resolutionRate The new resolution rate.\n     * @param _details Additional details about the update.\n     */\n    function updateResolutionRate(\n        uint256 _resolutionRate,\n        bytes32 _details\n    ) external {\n        resolutionRates[msg.sender] = _resolutionRate;\n        emit UpdateResolutionRate(msg.sender, _resolutionRate, _details);\n    }\n\n    /**\n     * @notice Gets the resolution rate of a resolver.\n     * @param _resolver The address of the resolver.\n     * @return The resolution rate of the resolver.\n     */\n    function resolutionRateOf(\n        address _resolver\n    ) external view override returns (uint256) {\n        return resolutionRates[_resolver];\n    }\n\n    /**\n     * @notice Adds a new implementation for a given type.\n     * @param _type The type of the invoice.\n     * @param _implementation The address of the new implementation.\n     */\n    function addImplementation(\n        bytes32 _type,\n        address _implementation\n    ) external onlyRole(ADMIN) {\n        if (_implementation == address(0)) revert ZeroAddressImplementation();\n\n        uint256 _version = currentVersions[_type];\n        address currentImplementation = implementations[_type][_version];\n\n        if (currentImplementation == address(0)) {\n            implementations[_type][_version] = _implementation;\n        } else {\n            _version++;\n            implementations[_type][_version] = _implementation;\n            currentVersions[_type] = _version;\n        }\n\n        emit AddImplementation(_type, _version, _implementation);\n    }\n}");
insert Identifier(749, 748, "SmartInvoiceFactory");
insert InheritanceSpecifier(750, 748, "ISmartInvoiceFactory");
insert UserDefinedType(751, 750, "ISmartInvoiceFactory");
insert Identifier(752, 751, "ISmartInvoiceFactory");
insert InheritanceSpecifier(753, 748, "AccessControl");
insert UserDefinedType(754, 753, "AccessControl");
insert Identifier(755, 754, "AccessControl");
insert ContractBody(756, 748, "{\n    uint256 public invoiceCount = 0;\n\n    mapping(uint256 => address) internal _invoices;\n    mapping(address => uint256) public resolutionRates;\n\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    // Implementation Storage\n    mapping(bytes32 => mapping(uint256 => address)) public implementations;\n    mapping(bytes32 => uint256) public currentVersions;\n\n    address public immutable wrappedNativeToken;\n\n    /// @notice Constructor to initialize the factory with a wrapped native token.\n    /// @param _wrappedNativeToken The address of the wrapped native token.\n    constructor(address _wrappedNativeToken) {\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n        wrappedNativeToken = _wrappedNativeToken;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN, msg.sender);\n    }\n\n    /**\n     * @dev Internal function to initialize a new invoice.\n     * @param _invoiceAddress The address of the invoice contract.\n     * @param _recipient The address of the recipient.\n     * @param _amounts The array of amounts associated with the recipient.\n     * @param _data Additional data needed for initialization.\n     * @param _type The type of the invoice.\n     * @param _version The version of the invoice implementation.\n     */\n    function _init(\n        address _invoiceAddress,\n        address _recipient,\n        uint256[] calldata _amounts,\n        bytes calldata _data,\n        bytes32 _type,\n        uint256 _version\n    ) internal {\n        ISmartInvoice(_invoiceAddress).init(_recipient, _amounts, _data);\n\n        uint256 invoiceId = invoiceCount;\n        _invoices[invoiceId] = _invoiceAddress;\n        invoiceCount++;\n\n        emit LogNewInvoice(\n            invoiceId,\n            _invoiceAddress,\n            _amounts,\n            _type,\n            _version\n        );\n    }\n\n    /**\n     * @notice Creates a new smart invoice instance.\n     * @param _recipient The address of the recipient.\n     * @param _amounts The array of amounts associated with the recipient.\n     * @param _data Additional data needed for initialization.\n     * @param _type The type of the invoice.\n     * @return The address of the created invoice.\n     */\n    function create(\n        address _recipient,\n        uint256[] calldata _amounts,\n        bytes calldata _data,\n        bytes32 _type\n    ) external override returns (address) {\n        uint256 _version = currentVersions[_type];\n        address _implementation = implementations[_type][_version];\n        if (_implementation == address(0)) revert ImplementationDoesNotExist();\n\n        address invoiceAddress = Clones.clone(_implementation);\n        _init(invoiceAddress, _recipient, _amounts, _data, _type, _version);\n\n        return invoiceAddress;\n    }\n\n    /**\n     * @notice Predicts the deterministic address of a clone.\n     * @param _type The type of the invoice.\n     * @param _salt The salt used to determine the address.\n     * @return The predicted address of the deterministic clone.\n     */\n    function predictDeterministicAddress(\n        bytes32 _type,\n        bytes32 _salt\n    ) external view override returns (address) {\n        uint256 _version = currentVersions[_type];\n        address _implementation = implementations[_type][_version];\n        return Clones.predictDeterministicAddress(_implementation, _salt);\n    }\n\n    /**\n     * @notice Creates a new smart invoice instance deterministically.\n     * @param _recipient The address of the recipient.\n     * @param _amounts The array of amounts associated with the recipient.\n     * @param _data Additional data needed for initialization.\n     * @param _type The type of the invoice.\n     * @param _salt The salt used to determine the address.\n     * @return The address of the created invoice.\n     */\n    function createDeterministic(\n        address _recipient,\n        uint256[] calldata _amounts,\n        bytes calldata _data,\n        bytes32 _type,\n        bytes32 _salt\n    ) external override returns (address) {\n        uint256 _version = currentVersions[_type];\n        address _implementation = implementations[_type][_version];\n        if (_implementation == address(0)) revert ImplementationDoesNotExist();\n\n        address invoiceAddress = Clones.cloneDeterministic(\n            _implementation,\n            _salt\n        );\n        _init(invoiceAddress, _recipient, _amounts, _data, _type, _version);\n\n        return invoiceAddress;\n    }\n\n    /**\n     * @notice Gets the implementation address for a given type and version.\n     * @param _implementationType The type of the implementation.\n     * @param _implementationVersion The version of the implementation.\n     * @return The address of the implementation.\n     */\n    function getImplementation(\n        bytes32 _implementationType,\n        uint256 _implementationVersion\n    ) external view returns (address) {\n        return implementations[_implementationType][_implementationVersion];\n    }\n\n    /**\n     * @notice Gets the address of an invoice by its index.\n     * @param index The index of the invoice.\n     * @return The address of the invoice.\n     */\n    function getInvoiceAddress(uint256 index) external view returns (address) {\n        return _invoices[index];\n    }\n\n    /**\n     * @notice Updates the resolution rate for a resolver.\n     * @param _resolutionRate The new resolution rate.\n     * @param _details Additional details about the update.\n     */\n    function updateResolutionRate(\n        uint256 _resolutionRate,\n        bytes32 _details\n    ) external {\n        resolutionRates[msg.sender] = _resolutionRate;\n        emit UpdateResolutionRate(msg.sender, _resolutionRate, _details);\n    }\n\n    /**\n     * @notice Gets the resolution rate of a resolver.\n     * @param _resolver The address of the resolver.\n     * @return The resolution rate of the resolver.\n     */\n    function resolutionRateOf(\n        address _resolver\n    ) external view override returns (uint256) {\n        return resolutionRates[_resolver];\n    }\n\n    /**\n     * @notice Adds a new implementation for a given type.\n     * @param _type The type of the invoice.\n     * @param _implementation The address of the new implementation.\n     */\n    function addImplementation(\n        bytes32 _type,\n        address _implementation\n    ) external onlyRole(ADMIN) {\n        if (_implementation == address(0)) revert ZeroAddressImplementation();\n\n        uint256 _version = currentVersions[_type];\n        address currentImplementation = implementations[_type][_version];\n\n        if (currentImplementation == address(0)) {\n            implementations[_type][_version] = _implementation;\n        } else {\n            _version++;\n            implementations[_type][_version] = _implementation;\n            currentVersions[_type] = _version;\n        }\n\n        emit AddImplementation(_type, _version, _implementation);\n    }\n}");
insert StateVariableDeclaration(757, 756, "uint256 public invoiceCount = 0;");
insert TypeName(758, 757, "uint256");
insert PrimitiveType(759, 758, "uint256");
insert Visibility(760, 757, "public");
insert Identifier(761, 757, "invoiceCount");
insert Expression(762, 757, "0");
insert NumberLiteral(763, 762, "0");
insert StateVariableDeclaration(764, 756, "mapping(uint256 => address) internal _invoices;");
insert TypeName(765, 764, "mapping(uint256 => address)");
insert PrimitiveType(766, 765, "uint256");
insert TypeName(767, 765, "address");
insert PrimitiveType(768, 767, "address");
insert Visibility(769, 764, "internal");
insert Identifier(770, 764, "_invoices");
insert StateVariableDeclaration(771, 756, "mapping(address => uint256) public resolutionRates;");
insert TypeName(772, 771, "mapping(address => uint256)");
insert PrimitiveType(773, 772, "address");
insert TypeName(774, 772, "uint256");
insert PrimitiveType(775, 774, "uint256");
insert Visibility(776, 771, "public");
insert Identifier(777, 771, "resolutionRates");
insert StateVariableDeclaration(778, 756, "bytes32 public constant ADMIN = keccak256(\"ADMIN\");");
insert TypeName(779, 778, "bytes32");
insert PrimitiveType(780, 779, "bytes32");
insert Visibility(781, 778, "public");
insert Identifier(782, 778, "ADMIN");
insert Expression(783, 778, "keccak256(\"ADMIN\")");
insert CallExpression(784, 783, "keccak256(\"ADMIN\")");
insert Expression(785, 784, "keccak256");
insert Identifier(786, 785, "keccak256");
insert CallArgument(787, 784, "\"ADMIN\"");
insert Expression(788, 787, "\"ADMIN\"");
insert StringLiteral(789, 788, "\"ADMIN\"");
insert Comment(790, 756, "// Implementation Storage");
insert StateVariableDeclaration(791, 756, "mapping(bytes32 => mapping(uint256 => address)) public implementations;");
insert TypeName(792, 791, "mapping(bytes32 => mapping(uint256 => address))");
insert PrimitiveType(793, 792, "bytes32");
insert TypeName(794, 792, "mapping(uint256 => address)");
insert PrimitiveType(795, 794, "uint256");
insert TypeName(796, 794, "address");
insert PrimitiveType(797, 796, "address");
insert Visibility(798, 791, "public");
insert Identifier(799, 791, "implementations");
insert StateVariableDeclaration(800, 756, "mapping(bytes32 => uint256) public currentVersions;");
insert TypeName(801, 800, "mapping(bytes32 => uint256)");
insert PrimitiveType(802, 801, "bytes32");
insert TypeName(803, 801, "uint256");
insert PrimitiveType(804, 803, "uint256");
insert Visibility(805, 800, "public");
insert Identifier(806, 800, "currentVersions");
insert StateVariableDeclaration(807, 756, "address public immutable wrappedNativeToken;");
insert TypeName(808, 807, "address");
insert PrimitiveType(809, 808, "address");
insert Visibility(810, 807, "public");
insert Immutable(811, 807, "immutable");
insert Identifier(812, 807, "wrappedNativeToken");
insert Comment(813, 756, "/// @notice Constructor to initialize the factory with a wrapped native token.");
insert Comment(814, 756, "/// @param _wrappedNativeToken The address of the wrapped native token.");
insert ConstructorDefinition(815, 756, "constructor(address _wrappedNativeToken) {\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n        wrappedNativeToken = _wrappedNativeToken;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN, msg.sender);\n    }");
insert Parameter(816, 815, "address _wrappedNativeToken");
insert TypeName(817, 816, "address");
insert PrimitiveType(818, 817, "address");
insert Identifier(819, 816, "_wrappedNativeToken");
insert FunctionBody(820, 815, "{\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n        wrappedNativeToken = _wrappedNativeToken;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN, msg.sender);\n    }");
insert Statement(821, 820, "if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();");
insert IfStatement(822, 821, "if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();");
insert Expression(823, 822, "_wrappedNativeToken == address(0)");
insert BinaryExpression(824, 823, "_wrappedNativeToken == address(0)");
insert Expression(825, 824, "_wrappedNativeToken");
insert Identifier(826, 825, "_wrappedNativeToken");
insert Expression(827, 824, "address(0)");
insert TypeCastExpression(828, 827, "address(0)");
insert PrimitiveType(829, 828, "address");
insert CallArgument(830, 828, "0");
insert Expression(831, 830, "0");
insert NumberLiteral(832, 831, "0");
insert Statement(833, 822, "revert InvalidWrappedNativeToken();");
insert RevertStatement(834, 833, "revert InvalidWrappedNativeToken();");
insert Expression(835, 834, "InvalidWrappedNativeToken");
insert Identifier(836, 835, "InvalidWrappedNativeToken");
insert RevertArguments(837, 834, "()");
insert Statement(838, 820, "wrappedNativeToken = _wrappedNativeToken;");
insert ExpressionStatement(839, 838, "wrappedNativeToken = _wrappedNativeToken;");
insert Expression(840, 839, "wrappedNativeToken = _wrappedNativeToken");
insert AssignmentExpression(841, 840, "wrappedNativeToken = _wrappedNativeToken");
insert Expression(842, 841, "wrappedNativeToken");
insert Identifier(843, 842, "wrappedNativeToken");
insert Expression(844, 841, "_wrappedNativeToken");
insert Identifier(845, 844, "_wrappedNativeToken");
insert Statement(846, 820, "_grantRole(DEFAULT_ADMIN_ROLE, msg.sender);");
insert ExpressionStatement(847, 846, "_grantRole(DEFAULT_ADMIN_ROLE, msg.sender);");
insert Expression(848, 847, "_grantRole(DEFAULT_ADMIN_ROLE, msg.sender)");
insert CallExpression(849, 848, "_grantRole(DEFAULT_ADMIN_ROLE, msg.sender)");
insert Expression(850, 849, "_grantRole");
insert Identifier(851, 850, "_grantRole");
insert CallArgument(852, 849, "DEFAULT_ADMIN_ROLE");
insert Expression(853, 852, "DEFAULT_ADMIN_ROLE");
insert Identifier(854, 853, "DEFAULT_ADMIN_ROLE");
insert CallArgument(855, 849, "msg.sender");
insert Expression(856, 855, "msg.sender");
insert MemberExpression(857, 856, "msg.sender");
insert Identifier(858, 857, "msg");
insert Identifier(859, 857, "sender");
insert Statement(860, 820, "_grantRole(ADMIN, msg.sender);");
insert ExpressionStatement(861, 860, "_grantRole(ADMIN, msg.sender);");
insert Expression(862, 861, "_grantRole(ADMIN, msg.sender)");
insert CallExpression(863, 862, "_grantRole(ADMIN, msg.sender)");
insert Expression(864, 863, "_grantRole");
insert Identifier(865, 864, "_grantRole");
insert CallArgument(866, 863, "ADMIN");
insert Expression(867, 866, "ADMIN");
insert Identifier(868, 867, "ADMIN");
insert CallArgument(869, 863, "msg.sender");
insert Expression(870, 869, "msg.sender");
insert MemberExpression(871, 870, "msg.sender");
insert Identifier(872, 871, "msg");
insert Identifier(873, 871, "sender");
insert Comment(874, 756, "/**\n     * @dev Internal function to initialize a new invoice.\n     * @param _invoiceAddress The address of the invoice contract.\n     * @param _recipient The address of the recipient.\n     * @param _amounts The array of amounts associated with the recipient.\n     * @param _data Additional data needed for initialization.\n     * @param _type The type of the invoice.\n     * @param _version The version of the invoice implementation.\n     */");
insert FunctionDefinition(875, 756, "function _init(\n        address _invoiceAddress,\n        address _recipient,\n        uint256[] calldata _amounts,\n        bytes calldata _data,\n        bytes32 _type,\n        uint256 _version\n    ) internal {\n        ISmartInvoice(_invoiceAddress).init(_recipient, _amounts, _data);\n\n        uint256 invoiceId = invoiceCount;\n        _invoices[invoiceId] = _invoiceAddress;\n        invoiceCount++;\n\n        emit LogNewInvoice(\n            invoiceId,\n            _invoiceAddress,\n            _amounts,\n            _type,\n            _version\n        );\n    }");
insert Identifier(876, 875, "_init");
insert Parameter(877, 875, "address _invoiceAddress");
insert TypeName(878, 877, "address");
insert PrimitiveType(879, 878, "address");
insert Identifier(880, 877, "_invoiceAddress");
insert Parameter(881, 875, "address _recipient");
insert TypeName(882, 881, "address");
insert PrimitiveType(883, 882, "address");
insert Identifier(884, 881, "_recipient");
insert Parameter(885, 875, "uint256[] calldata _amounts");
insert TypeName(886, 885, "uint256[]");
insert TypeName(887, 886, "uint256");
insert PrimitiveType(888, 887, "uint256");
insert Identifier(889, 885, "_amounts");
insert Parameter(890, 875, "bytes calldata _data");
insert TypeName(891, 890, "bytes");
insert PrimitiveType(892, 891, "bytes");
insert Identifier(893, 890, "_data");
insert Parameter(894, 875, "bytes32 _type");
insert TypeName(895, 894, "bytes32");
insert PrimitiveType(896, 895, "bytes32");
insert Identifier(897, 894, "_type");
insert Parameter(898, 875, "uint256 _version");
insert TypeName(899, 898, "uint256");
insert PrimitiveType(900, 899, "uint256");
insert Identifier(901, 898, "_version");
insert Visibility(902, 875, "internal");
insert FunctionBody(903, 875, "{\n        ISmartInvoice(_invoiceAddress).init(_recipient, _amounts, _data);\n\n        uint256 invoiceId = invoiceCount;\n        _invoices[invoiceId] = _invoiceAddress;\n        invoiceCount++;\n\n        emit LogNewInvoice(\n            invoiceId,\n            _invoiceAddress,\n            _amounts,\n            _type,\n            _version\n        );\n    }");
insert Statement(904, 903, "ISmartInvoice(_invoiceAddress).init(_recipient, _amounts, _data);");
insert ExpressionStatement(905, 904, "ISmartInvoice(_invoiceAddress).init(_recipient, _amounts, _data);");
insert Expression(906, 905, "ISmartInvoice(_invoiceAddress).init(_recipient, _amounts, _data)");
insert CallExpression(907, 906, "ISmartInvoice(_invoiceAddress).init(_recipient, _amounts, _data)");
insert Expression(908, 907, "ISmartInvoice(_invoiceAddress).init");
insert MemberExpression(909, 908, "ISmartInvoice(_invoiceAddress).init");
insert Expression(910, 909, "ISmartInvoice(_invoiceAddress)");
insert CallExpression(911, 910, "ISmartInvoice(_invoiceAddress)");
insert Expression(912, 911, "ISmartInvoice");
insert Identifier(913, 912, "ISmartInvoice");
insert CallArgument(914, 911, "_invoiceAddress");
insert Expression(915, 914, "_invoiceAddress");
insert Identifier(916, 915, "_invoiceAddress");
insert Identifier(917, 909, "init");
insert CallArgument(918, 907, "_recipient");
insert Expression(919, 918, "_recipient");
insert Identifier(920, 919, "_recipient");
insert CallArgument(921, 907, "_amounts");
insert Expression(922, 921, "_amounts");
insert Identifier(923, 922, "_amounts");
insert CallArgument(924, 907, "_data");
insert Expression(925, 924, "_data");
insert Identifier(926, 925, "_data");
insert Statement(927, 903, "uint256 invoiceId = invoiceCount;");
insert VariableDeclarationStatement(928, 927, "uint256 invoiceId = invoiceCount;");
insert VariableDeclaration(929, 928, "uint256 invoiceId");
insert TypeName(930, 929, "uint256");
insert PrimitiveType(931, 930, "uint256");
insert Identifier(932, 929, "invoiceId");
insert Expression(933, 928, "invoiceCount");
insert Identifier(934, 933, "invoiceCount");
insert Statement(935, 903, "_invoices[invoiceId] = _invoiceAddress;");
insert ExpressionStatement(936, 935, "_invoices[invoiceId] = _invoiceAddress;");
insert Expression(937, 936, "_invoices[invoiceId] = _invoiceAddress");
insert AssignmentExpression(938, 937, "_invoices[invoiceId] = _invoiceAddress");
insert Expression(939, 938, "_invoices[invoiceId]");
insert ArrayAccess(940, 939, "_invoices[invoiceId]");
insert Expression(941, 940, "_invoices");
insert Identifier(942, 941, "_invoices");
insert Expression(943, 940, "invoiceId");
insert Identifier(944, 943, "invoiceId");
insert Expression(945, 938, "_invoiceAddress");
insert Identifier(946, 945, "_invoiceAddress");
insert Statement(947, 903, "invoiceCount++;");
insert ExpressionStatement(948, 947, "invoiceCount++;");
insert Expression(949, 948, "invoiceCount++");
insert UpdateExpression(950, 949, "invoiceCount++");
insert Expression(951, 950, "invoiceCount");
insert Identifier(952, 951, "invoiceCount");
insert Statement(953, 903, "emit LogNewInvoice(\n            invoiceId,\n            _invoiceAddress,\n            _amounts,\n            _type,\n            _version\n        );");
insert EmitStatement(954, 953, "emit LogNewInvoice(\n            invoiceId,\n            _invoiceAddress,\n            _amounts,\n            _type,\n            _version\n        );");
insert Expression(955, 954, "LogNewInvoice");
insert Identifier(956, 955, "LogNewInvoice");
insert CallArgument(957, 954, "invoiceId");
insert Expression(958, 957, "invoiceId");
insert Identifier(959, 958, "invoiceId");
insert CallArgument(960, 954, "_invoiceAddress");
insert Expression(961, 960, "_invoiceAddress");
insert Identifier(962, 961, "_invoiceAddress");
insert CallArgument(963, 954, "_amounts");
insert Expression(964, 963, "_amounts");
insert Identifier(965, 964, "_amounts");
insert CallArgument(966, 954, "_type");
insert Expression(967, 966, "_type");
insert Identifier(968, 967, "_type");
insert CallArgument(969, 954, "_version");
insert Expression(970, 969, "_version");
insert Identifier(971, 970, "_version");
insert Comment(972, 756, "/**\n     * @notice Creates a new smart invoice instance.\n     * @param _recipient The address of the recipient.\n     * @param _amounts The array of amounts associated with the recipient.\n     * @param _data Additional data needed for initialization.\n     * @param _type The type of the invoice.\n     * @return The address of the created invoice.\n     */");
insert FunctionDefinition(973, 756, "function create(\n        address _recipient,\n        uint256[] calldata _amounts,\n        bytes calldata _data,\n        bytes32 _type\n    ) external override returns (address) {\n        uint256 _version = currentVersions[_type];\n        address _implementation = implementations[_type][_version];\n        if (_implementation == address(0)) revert ImplementationDoesNotExist();\n\n        address invoiceAddress = Clones.clone(_implementation);\n        _init(invoiceAddress, _recipient, _amounts, _data, _type, _version);\n\n        return invoiceAddress;\n    }");
insert Identifier(974, 973, "create");
insert Parameter(975, 973, "address _recipient");
insert TypeName(976, 975, "address");
insert PrimitiveType(977, 976, "address");
insert Identifier(978, 975, "_recipient");
insert Parameter(979, 973, "uint256[] calldata _amounts");
insert TypeName(980, 979, "uint256[]");
insert TypeName(981, 980, "uint256");
insert PrimitiveType(982, 981, "uint256");
insert Identifier(983, 979, "_amounts");
insert Parameter(984, 973, "bytes calldata _data");
insert TypeName(985, 984, "bytes");
insert PrimitiveType(986, 985, "bytes");
insert Identifier(987, 984, "_data");
insert Parameter(988, 973, "bytes32 _type");
insert TypeName(989, 988, "bytes32");
insert PrimitiveType(990, 989, "bytes32");
insert Identifier(991, 988, "_type");
insert Visibility(992, 973, "external");
insert OverrideSpecifier(993, 973, "override");
insert ReturnTypeDefinition(994, 973, "returns (address)");
insert Parameter(995, 994, "address");
insert TypeName(996, 995, "address");
insert PrimitiveType(997, 996, "address");
insert FunctionBody(998, 973, "{\n        uint256 _version = currentVersions[_type];\n        address _implementation = implementations[_type][_version];\n        if (_implementation == address(0)) revert ImplementationDoesNotExist();\n\n        address invoiceAddress = Clones.clone(_implementation);\n        _init(invoiceAddress, _recipient, _amounts, _data, _type, _version);\n\n        return invoiceAddress;\n    }");
insert Statement(999, 998, "uint256 _version = currentVersions[_type];");
insert VariableDeclarationStatement(1000, 999, "uint256 _version = currentVersions[_type];");
insert VariableDeclaration(1001, 1000, "uint256 _version");
insert TypeName(1002, 1001, "uint256");
insert PrimitiveType(1003, 1002, "uint256");
insert Identifier(1004, 1001, "_version");
insert Expression(1005, 1000, "currentVersions[_type]");
insert ArrayAccess(1006, 1005, "currentVersions[_type]");
insert Expression(1007, 1006, "currentVersions");
insert Identifier(1008, 1007, "currentVersions");
insert Expression(1009, 1006, "_type");
insert Identifier(1010, 1009, "_type");
insert Statement(1011, 998, "address _implementation = implementations[_type][_version];");
insert VariableDeclarationStatement(1012, 1011, "address _implementation = implementations[_type][_version];");
insert VariableDeclaration(1013, 1012, "address _implementation");
insert TypeName(1014, 1013, "address");
insert PrimitiveType(1015, 1014, "address");
insert Identifier(1016, 1013, "_implementation");
insert Expression(1017, 1012, "implementations[_type][_version]");
insert ArrayAccess(1018, 1017, "implementations[_type][_version]");
insert Expression(1019, 1018, "implementations[_type]");
insert ArrayAccess(1020, 1019, "implementations[_type]");
insert Expression(1021, 1020, "implementations");
insert Identifier(1022, 1021, "implementations");
insert Expression(1023, 1020, "_type");
insert Identifier(1024, 1023, "_type");
insert Expression(1025, 1018, "_version");
insert Identifier(1026, 1025, "_version");
insert Statement(1027, 998, "if (_implementation == address(0)) revert ImplementationDoesNotExist();");
insert IfStatement(1028, 1027, "if (_implementation == address(0)) revert ImplementationDoesNotExist();");
insert Expression(1029, 1028, "_implementation == address(0)");
insert BinaryExpression(1030, 1029, "_implementation == address(0)");
insert Expression(1031, 1030, "_implementation");
insert Identifier(1032, 1031, "_implementation");
insert Expression(1033, 1030, "address(0)");
insert TypeCastExpression(1034, 1033, "address(0)");
insert PrimitiveType(1035, 1034, "address");
insert CallArgument(1036, 1034, "0");
insert Expression(1037, 1036, "0");
insert NumberLiteral(1038, 1037, "0");
insert Statement(1039, 1028, "revert ImplementationDoesNotExist();");
insert RevertStatement(1040, 1039, "revert ImplementationDoesNotExist();");
insert Expression(1041, 1040, "ImplementationDoesNotExist");
insert Identifier(1042, 1041, "ImplementationDoesNotExist");
insert RevertArguments(1043, 1040, "()");
insert Statement(1044, 998, "address invoiceAddress = Clones.clone(_implementation);");
insert VariableDeclarationStatement(1045, 1044, "address invoiceAddress = Clones.clone(_implementation);");
insert VariableDeclaration(1046, 1045, "address invoiceAddress");
insert TypeName(1047, 1046, "address");
insert PrimitiveType(1048, 1047, "address");
insert Identifier(1049, 1046, "invoiceAddress");
insert Expression(1050, 1045, "Clones.clone(_implementation)");
insert CallExpression(1051, 1050, "Clones.clone(_implementation)");
insert Expression(1052, 1051, "Clones.clone");
insert MemberExpression(1053, 1052, "Clones.clone");
insert Identifier(1054, 1053, "Clones");
insert Identifier(1055, 1053, "clone");
insert CallArgument(1056, 1051, "_implementation");
insert Expression(1057, 1056, "_implementation");
insert Identifier(1058, 1057, "_implementation");
insert Statement(1059, 998, "_init(invoiceAddress, _recipient, _amounts, _data, _type, _version);");
insert ExpressionStatement(1060, 1059, "_init(invoiceAddress, _recipient, _amounts, _data, _type, _version);");
insert Expression(1061, 1060, "_init(invoiceAddress, _recipient, _amounts, _data, _type, _version)");
insert CallExpression(1062, 1061, "_init(invoiceAddress, _recipient, _amounts, _data, _type, _version)");
insert Expression(1063, 1062, "_init");
insert Identifier(1064, 1063, "_init");
insert CallArgument(1065, 1062, "invoiceAddress");
insert Expression(1066, 1065, "invoiceAddress");
insert Identifier(1067, 1066, "invoiceAddress");
insert CallArgument(1068, 1062, "_recipient");
insert Expression(1069, 1068, "_recipient");
insert Identifier(1070, 1069, "_recipient");
insert CallArgument(1071, 1062, "_amounts");
insert Expression(1072, 1071, "_amounts");
insert Identifier(1073, 1072, "_amounts");
insert CallArgument(1074, 1062, "_data");
insert Expression(1075, 1074, "_data");
insert Identifier(1076, 1075, "_data");
insert CallArgument(1077, 1062, "_type");
insert Expression(1078, 1077, "_type");
insert Identifier(1079, 1078, "_type");
insert CallArgument(1080, 1062, "_version");
insert Expression(1081, 1080, "_version");
insert Identifier(1082, 1081, "_version");
insert Statement(1083, 998, "return invoiceAddress;");
insert ReturnStatement(1084, 1083, "return invoiceAddress;");
insert Expression(1085, 1084, "invoiceAddress");
insert Identifier(1086, 1085, "invoiceAddress");
insert Comment(1087, 756, "/**\n     * @notice Predicts the deterministic address of a clone.\n     * @param _type The type of the invoice.\n     * @param _salt The salt used to determine the address.\n     * @return The predicted address of the deterministic clone.\n     */");
insert FunctionDefinition(1088, 756, "function predictDeterministicAddress(\n        bytes32 _type,\n        bytes32 _salt\n    ) external view override returns (address) {\n        uint256 _version = currentVersions[_type];\n        address _implementation = implementations[_type][_version];\n        return Clones.predictDeterministicAddress(_implementation, _salt);\n    }");
insert Identifier(1089, 1088, "predictDeterministicAddress");
insert Parameter(1090, 1088, "bytes32 _type");
insert TypeName(1091, 1090, "bytes32");
insert PrimitiveType(1092, 1091, "bytes32");
insert Identifier(1093, 1090, "_type");
insert Parameter(1094, 1088, "bytes32 _salt");
insert TypeName(1095, 1094, "bytes32");
insert PrimitiveType(1096, 1095, "bytes32");
insert Identifier(1097, 1094, "_salt");
insert Visibility(1098, 1088, "external");
insert StateMutability(1099, 1088, "view");
insert OverrideSpecifier(1100, 1088, "override");
insert ReturnTypeDefinition(1101, 1088, "returns (address)");
insert Parameter(1102, 1101, "address");
insert TypeName(1103, 1102, "address");
insert PrimitiveType(1104, 1103, "address");
insert FunctionBody(1105, 1088, "{\n        uint256 _version = currentVersions[_type];\n        address _implementation = implementations[_type][_version];\n        return Clones.predictDeterministicAddress(_implementation, _salt);\n    }");
insert Statement(1106, 1105, "uint256 _version = currentVersions[_type];");
insert VariableDeclarationStatement(1107, 1106, "uint256 _version = currentVersions[_type];");
insert VariableDeclaration(1108, 1107, "uint256 _version");
insert TypeName(1109, 1108, "uint256");
insert PrimitiveType(1110, 1109, "uint256");
insert Identifier(1111, 1108, "_version");
insert Expression(1112, 1107, "currentVersions[_type]");
insert ArrayAccess(1113, 1112, "currentVersions[_type]");
insert Expression(1114, 1113, "currentVersions");
insert Identifier(1115, 1114, "currentVersions");
insert Expression(1116, 1113, "_type");
insert Identifier(1117, 1116, "_type");
insert Statement(1118, 1105, "address _implementation = implementations[_type][_version];");
insert VariableDeclarationStatement(1119, 1118, "address _implementation = implementations[_type][_version];");
insert VariableDeclaration(1120, 1119, "address _implementation");
insert TypeName(1121, 1120, "address");
insert PrimitiveType(1122, 1121, "address");
insert Identifier(1123, 1120, "_implementation");
insert Expression(1124, 1119, "implementations[_type][_version]");
insert ArrayAccess(1125, 1124, "implementations[_type][_version]");
insert Expression(1126, 1125, "implementations[_type]");
insert ArrayAccess(1127, 1126, "implementations[_type]");
insert Expression(1128, 1127, "implementations");
insert Identifier(1129, 1128, "implementations");
insert Expression(1130, 1127, "_type");
insert Identifier(1131, 1130, "_type");
insert Expression(1132, 1125, "_version");
insert Identifier(1133, 1132, "_version");
insert Statement(1134, 1105, "return Clones.predictDeterministicAddress(_implementation, _salt);");
insert ReturnStatement(1135, 1134, "return Clones.predictDeterministicAddress(_implementation, _salt);");
insert Expression(1136, 1135, "Clones.predictDeterministicAddress(_implementation, _salt)");
insert CallExpression(1137, 1136, "Clones.predictDeterministicAddress(_implementation, _salt)");
insert Expression(1138, 1137, "Clones.predictDeterministicAddress");
insert MemberExpression(1139, 1138, "Clones.predictDeterministicAddress");
insert Identifier(1140, 1139, "Clones");
insert Identifier(1141, 1139, "predictDeterministicAddress");
insert CallArgument(1142, 1137, "_implementation");
insert Expression(1143, 1142, "_implementation");
insert Identifier(1144, 1143, "_implementation");
insert CallArgument(1145, 1137, "_salt");
insert Expression(1146, 1145, "_salt");
insert Identifier(1147, 1146, "_salt");
insert Comment(1148, 756, "/**\n     * @notice Creates a new smart invoice instance deterministically.\n     * @param _recipient The address of the recipient.\n     * @param _amounts The array of amounts associated with the recipient.\n     * @param _data Additional data needed for initialization.\n     * @param _type The type of the invoice.\n     * @param _salt The salt used to determine the address.\n     * @return The address of the created invoice.\n     */");
insert FunctionDefinition(1149, 756, "function createDeterministic(\n        address _recipient,\n        uint256[] calldata _amounts,\n        bytes calldata _data,\n        bytes32 _type,\n        bytes32 _salt\n    ) external override returns (address) {\n        uint256 _version = currentVersions[_type];\n        address _implementation = implementations[_type][_version];\n        if (_implementation == address(0)) revert ImplementationDoesNotExist();\n\n        address invoiceAddress = Clones.cloneDeterministic(\n            _implementation,\n            _salt\n        );\n        _init(invoiceAddress, _recipient, _amounts, _data, _type, _version);\n\n        return invoiceAddress;\n    }");
insert Identifier(1150, 1149, "createDeterministic");
insert Parameter(1151, 1149, "address _recipient");
insert TypeName(1152, 1151, "address");
insert PrimitiveType(1153, 1152, "address");
insert Identifier(1154, 1151, "_recipient");
insert Parameter(1155, 1149, "uint256[] calldata _amounts");
insert TypeName(1156, 1155, "uint256[]");
insert TypeName(1157, 1156, "uint256");
insert PrimitiveType(1158, 1157, "uint256");
insert Identifier(1159, 1155, "_amounts");
insert Parameter(1160, 1149, "bytes calldata _data");
insert TypeName(1161, 1160, "bytes");
insert PrimitiveType(1162, 1161, "bytes");
insert Identifier(1163, 1160, "_data");
insert Parameter(1164, 1149, "bytes32 _type");
insert TypeName(1165, 1164, "bytes32");
insert PrimitiveType(1166, 1165, "bytes32");
insert Identifier(1167, 1164, "_type");
insert Parameter(1168, 1149, "bytes32 _salt");
insert TypeName(1169, 1168, "bytes32");
insert PrimitiveType(1170, 1169, "bytes32");
insert Identifier(1171, 1168, "_salt");
insert Visibility(1172, 1149, "external");
insert OverrideSpecifier(1173, 1149, "override");
insert ReturnTypeDefinition(1174, 1149, "returns (address)");
insert Parameter(1175, 1174, "address");
insert TypeName(1176, 1175, "address");
insert PrimitiveType(1177, 1176, "address");
insert FunctionBody(1178, 1149, "{\n        uint256 _version = currentVersions[_type];\n        address _implementation = implementations[_type][_version];\n        if (_implementation == address(0)) revert ImplementationDoesNotExist();\n\n        address invoiceAddress = Clones.cloneDeterministic(\n            _implementation,\n            _salt\n        );\n        _init(invoiceAddress, _recipient, _amounts, _data, _type, _version);\n\n        return invoiceAddress;\n    }");
insert Statement(1179, 1178, "uint256 _version = currentVersions[_type];");
insert VariableDeclarationStatement(1180, 1179, "uint256 _version = currentVersions[_type];");
insert VariableDeclaration(1181, 1180, "uint256 _version");
insert TypeName(1182, 1181, "uint256");
insert PrimitiveType(1183, 1182, "uint256");
insert Identifier(1184, 1181, "_version");
insert Expression(1185, 1180, "currentVersions[_type]");
insert ArrayAccess(1186, 1185, "currentVersions[_type]");
insert Expression(1187, 1186, "currentVersions");
insert Identifier(1188, 1187, "currentVersions");
insert Expression(1189, 1186, "_type");
insert Identifier(1190, 1189, "_type");
insert Statement(1191, 1178, "address _implementation = implementations[_type][_version];");
insert VariableDeclarationStatement(1192, 1191, "address _implementation = implementations[_type][_version];");
insert VariableDeclaration(1193, 1192, "address _implementation");
insert TypeName(1194, 1193, "address");
insert PrimitiveType(1195, 1194, "address");
insert Identifier(1196, 1193, "_implementation");
insert Expression(1197, 1192, "implementations[_type][_version]");
insert ArrayAccess(1198, 1197, "implementations[_type][_version]");
insert Expression(1199, 1198, "implementations[_type]");
insert ArrayAccess(1200, 1199, "implementations[_type]");
insert Expression(1201, 1200, "implementations");
insert Identifier(1202, 1201, "implementations");
insert Expression(1203, 1200, "_type");
insert Identifier(1204, 1203, "_type");
insert Expression(1205, 1198, "_version");
insert Identifier(1206, 1205, "_version");
insert Statement(1207, 1178, "if (_implementation == address(0)) revert ImplementationDoesNotExist();");
insert IfStatement(1208, 1207, "if (_implementation == address(0)) revert ImplementationDoesNotExist();");
insert Expression(1209, 1208, "_implementation == address(0)");
insert BinaryExpression(1210, 1209, "_implementation == address(0)");
insert Expression(1211, 1210, "_implementation");
insert Identifier(1212, 1211, "_implementation");
insert Expression(1213, 1210, "address(0)");
insert TypeCastExpression(1214, 1213, "address(0)");
insert PrimitiveType(1215, 1214, "address");
insert CallArgument(1216, 1214, "0");
insert Expression(1217, 1216, "0");
insert NumberLiteral(1218, 1217, "0");
insert Statement(1219, 1208, "revert ImplementationDoesNotExist();");
insert RevertStatement(1220, 1219, "revert ImplementationDoesNotExist();");
insert Expression(1221, 1220, "ImplementationDoesNotExist");
insert Identifier(1222, 1221, "ImplementationDoesNotExist");
insert RevertArguments(1223, 1220, "()");
insert Statement(1224, 1178, "address invoiceAddress = Clones.cloneDeterministic(\n            _implementation,\n            _salt\n        );");
insert VariableDeclarationStatement(1225, 1224, "address invoiceAddress = Clones.cloneDeterministic(\n            _implementation,\n            _salt\n        );");
insert VariableDeclaration(1226, 1225, "address invoiceAddress");
insert TypeName(1227, 1226, "address");
insert PrimitiveType(1228, 1227, "address");
insert Identifier(1229, 1226, "invoiceAddress");
insert Expression(1230, 1225, "Clones.cloneDeterministic(\n            _implementation,\n            _salt\n        )");
insert CallExpression(1231, 1230, "Clones.cloneDeterministic(\n            _implementation,\n            _salt\n        )");
insert Expression(1232, 1231, "Clones.cloneDeterministic");
insert MemberExpression(1233, 1232, "Clones.cloneDeterministic");
insert Identifier(1234, 1233, "Clones");
insert Identifier(1235, 1233, "cloneDeterministic");
insert CallArgument(1236, 1231, "_implementation");
insert Expression(1237, 1236, "_implementation");
insert Identifier(1238, 1237, "_implementation");
insert CallArgument(1239, 1231, "_salt");
insert Expression(1240, 1239, "_salt");
insert Identifier(1241, 1240, "_salt");
insert Statement(1242, 1178, "_init(invoiceAddress, _recipient, _amounts, _data, _type, _version);");
insert ExpressionStatement(1243, 1242, "_init(invoiceAddress, _recipient, _amounts, _data, _type, _version);");
insert Expression(1244, 1243, "_init(invoiceAddress, _recipient, _amounts, _data, _type, _version)");
insert CallExpression(1245, 1244, "_init(invoiceAddress, _recipient, _amounts, _data, _type, _version)");
insert Expression(1246, 1245, "_init");
insert Identifier(1247, 1246, "_init");
insert CallArgument(1248, 1245, "invoiceAddress");
insert Expression(1249, 1248, "invoiceAddress");
insert Identifier(1250, 1249, "invoiceAddress");
insert CallArgument(1251, 1245, "_recipient");
insert Expression(1252, 1251, "_recipient");
insert Identifier(1253, 1252, "_recipient");
insert CallArgument(1254, 1245, "_amounts");
insert Expression(1255, 1254, "_amounts");
insert Identifier(1256, 1255, "_amounts");
insert CallArgument(1257, 1245, "_data");
insert Expression(1258, 1257, "_data");
insert Identifier(1259, 1258, "_data");
insert CallArgument(1260, 1245, "_type");
insert Expression(1261, 1260, "_type");
insert Identifier(1262, 1261, "_type");
insert CallArgument(1263, 1245, "_version");
insert Expression(1264, 1263, "_version");
insert Identifier(1265, 1264, "_version");
insert Statement(1266, 1178, "return invoiceAddress;");
insert ReturnStatement(1267, 1266, "return invoiceAddress;");
insert Expression(1268, 1267, "invoiceAddress");
insert Identifier(1269, 1268, "invoiceAddress");
insert Comment(1270, 756, "/**\n     * @notice Gets the implementation address for a given type and version.\n     * @param _implementationType The type of the implementation.\n     * @param _implementationVersion The version of the implementation.\n     * @return The address of the implementation.\n     */");
insert FunctionDefinition(1271, 756, "function getImplementation(\n        bytes32 _implementationType,\n        uint256 _implementationVersion\n    ) external view returns (address) {\n        return implementations[_implementationType][_implementationVersion];\n    }");
insert Identifier(1272, 1271, "getImplementation");
insert Parameter(1273, 1271, "bytes32 _implementationType");
insert TypeName(1274, 1273, "bytes32");
insert PrimitiveType(1275, 1274, "bytes32");
insert Identifier(1276, 1273, "_implementationType");
insert Parameter(1277, 1271, "uint256 _implementationVersion");
insert TypeName(1278, 1277, "uint256");
insert PrimitiveType(1279, 1278, "uint256");
insert Identifier(1280, 1277, "_implementationVersion");
insert Visibility(1281, 1271, "external");
insert StateMutability(1282, 1271, "view");
insert ReturnTypeDefinition(1283, 1271, "returns (address)");
insert Parameter(1284, 1283, "address");
insert TypeName(1285, 1284, "address");
insert PrimitiveType(1286, 1285, "address");
insert FunctionBody(1287, 1271, "{\n        return implementations[_implementationType][_implementationVersion];\n    }");
insert Statement(1288, 1287, "return implementations[_implementationType][_implementationVersion];");
insert ReturnStatement(1289, 1288, "return implementations[_implementationType][_implementationVersion];");
insert Expression(1290, 1289, "implementations[_implementationType][_implementationVersion]");
insert ArrayAccess(1291, 1290, "implementations[_implementationType][_implementationVersion]");
insert Expression(1292, 1291, "implementations[_implementationType]");
insert ArrayAccess(1293, 1292, "implementations[_implementationType]");
insert Expression(1294, 1293, "implementations");
insert Identifier(1295, 1294, "implementations");
insert Expression(1296, 1293, "_implementationType");
insert Identifier(1297, 1296, "_implementationType");
insert Expression(1298, 1291, "_implementationVersion");
insert Identifier(1299, 1298, "_implementationVersion");
insert Comment(1300, 756, "/**\n     * @notice Gets the address of an invoice by its index.\n     * @param index The index of the invoice.\n     * @return The address of the invoice.\n     */");
insert FunctionDefinition(1301, 756, "function getInvoiceAddress(uint256 index) external view returns (address) {\n        return _invoices[index];\n    }");
insert Identifier(1302, 1301, "getInvoiceAddress");
insert Parameter(1303, 1301, "uint256 index");
insert TypeName(1304, 1303, "uint256");
insert PrimitiveType(1305, 1304, "uint256");
insert Identifier(1306, 1303, "index");
insert Visibility(1307, 1301, "external");
insert StateMutability(1308, 1301, "view");
insert ReturnTypeDefinition(1309, 1301, "returns (address)");
insert Parameter(1310, 1309, "address");
insert TypeName(1311, 1310, "address");
insert PrimitiveType(1312, 1311, "address");
insert FunctionBody(1313, 1301, "{\n        return _invoices[index];\n    }");
insert Statement(1314, 1313, "return _invoices[index];");
insert ReturnStatement(1315, 1314, "return _invoices[index];");
insert Expression(1316, 1315, "_invoices[index]");
insert ArrayAccess(1317, 1316, "_invoices[index]");
insert Expression(1318, 1317, "_invoices");
insert Identifier(1319, 1318, "_invoices");
insert Expression(1320, 1317, "index");
insert Identifier(1321, 1320, "index");
insert Comment(1322, 756, "/**\n     * @notice Updates the resolution rate for a resolver.\n     * @param _resolutionRate The new resolution rate.\n     * @param _details Additional details about the update.\n     */");
insert FunctionDefinition(1323, 756, "function updateResolutionRate(\n        uint256 _resolutionRate,\n        bytes32 _details\n    ) external {\n        resolutionRates[msg.sender] = _resolutionRate;\n        emit UpdateResolutionRate(msg.sender, _resolutionRate, _details);\n    }");
insert Identifier(1324, 1323, "updateResolutionRate");
insert Parameter(1325, 1323, "uint256 _resolutionRate");
insert TypeName(1326, 1325, "uint256");
insert PrimitiveType(1327, 1326, "uint256");
insert Identifier(1328, 1325, "_resolutionRate");
insert Parameter(1329, 1323, "bytes32 _details");
insert TypeName(1330, 1329, "bytes32");
insert PrimitiveType(1331, 1330, "bytes32");
insert Identifier(1332, 1329, "_details");
insert Visibility(1333, 1323, "external");
insert FunctionBody(1334, 1323, "{\n        resolutionRates[msg.sender] = _resolutionRate;\n        emit UpdateResolutionRate(msg.sender, _resolutionRate, _details);\n    }");
insert Statement(1335, 1334, "resolutionRates[msg.sender] = _resolutionRate;");
insert ExpressionStatement(1336, 1335, "resolutionRates[msg.sender] = _resolutionRate;");
insert Expression(1337, 1336, "resolutionRates[msg.sender] = _resolutionRate");
insert AssignmentExpression(1338, 1337, "resolutionRates[msg.sender] = _resolutionRate");
insert Expression(1339, 1338, "resolutionRates[msg.sender]");
insert ArrayAccess(1340, 1339, "resolutionRates[msg.sender]");
insert Expression(1341, 1340, "resolutionRates");
insert Identifier(1342, 1341, "resolutionRates");
insert Expression(1343, 1340, "msg.sender");
insert MemberExpression(1344, 1343, "msg.sender");
insert Identifier(1345, 1344, "msg");
insert Identifier(1346, 1344, "sender");
insert Expression(1347, 1338, "_resolutionRate");
insert Identifier(1348, 1347, "_resolutionRate");
insert Statement(1349, 1334, "emit UpdateResolutionRate(msg.sender, _resolutionRate, _details);");
insert EmitStatement(1350, 1349, "emit UpdateResolutionRate(msg.sender, _resolutionRate, _details);");
insert Expression(1351, 1350, "UpdateResolutionRate");
insert Identifier(1352, 1351, "UpdateResolutionRate");
insert CallArgument(1353, 1350, "msg.sender");
insert Expression(1354, 1353, "msg.sender");
insert MemberExpression(1355, 1354, "msg.sender");
insert Identifier(1356, 1355, "msg");
insert Identifier(1357, 1355, "sender");
insert CallArgument(1358, 1350, "_resolutionRate");
insert Expression(1359, 1358, "_resolutionRate");
insert Identifier(1360, 1359, "_resolutionRate");
insert CallArgument(1361, 1350, "_details");
insert Expression(1362, 1361, "_details");
insert Identifier(1363, 1362, "_details");
insert Comment(1364, 756, "/**\n     * @notice Gets the resolution rate of a resolver.\n     * @param _resolver The address of the resolver.\n     * @return The resolution rate of the resolver.\n     */");
insert FunctionDefinition(1365, 756, "function resolutionRateOf(\n        address _resolver\n    ) external view override returns (uint256) {\n        return resolutionRates[_resolver];\n    }");
insert Identifier(1366, 1365, "resolutionRateOf");
insert Parameter(1367, 1365, "address _resolver");
insert TypeName(1368, 1367, "address");
insert PrimitiveType(1369, 1368, "address");
insert Identifier(1370, 1367, "_resolver");
insert Visibility(1371, 1365, "external");
insert StateMutability(1372, 1365, "view");
insert OverrideSpecifier(1373, 1365, "override");
insert ReturnTypeDefinition(1374, 1365, "returns (uint256)");
insert Parameter(1375, 1374, "uint256");
insert TypeName(1376, 1375, "uint256");
insert PrimitiveType(1377, 1376, "uint256");
insert FunctionBody(1378, 1365, "{\n        return resolutionRates[_resolver];\n    }");
insert Statement(1379, 1378, "return resolutionRates[_resolver];");
insert ReturnStatement(1380, 1379, "return resolutionRates[_resolver];");
insert Expression(1381, 1380, "resolutionRates[_resolver]");
insert ArrayAccess(1382, 1381, "resolutionRates[_resolver]");
insert Expression(1383, 1382, "resolutionRates");
insert Identifier(1384, 1383, "resolutionRates");
insert Expression(1385, 1382, "_resolver");
insert Identifier(1386, 1385, "_resolver");
insert Comment(1387, 756, "/**\n     * @notice Adds a new implementation for a given type.\n     * @param _type The type of the invoice.\n     * @param _implementation The address of the new implementation.\n     */");
insert FunctionDefinition(1388, 756, "function addImplementation(\n        bytes32 _type,\n        address _implementation\n    ) external onlyRole(ADMIN) {\n        if (_implementation == address(0)) revert ZeroAddressImplementation();\n\n        uint256 _version = currentVersions[_type];\n        address currentImplementation = implementations[_type][_version];\n\n        if (currentImplementation == address(0)) {\n            implementations[_type][_version] = _implementation;\n        } else {\n            _version++;\n            implementations[_type][_version] = _implementation;\n            currentVersions[_type] = _version;\n        }\n\n        emit AddImplementation(_type, _version, _implementation);\n    }");
insert Identifier(1389, 1388, "addImplementation");
insert Parameter(1390, 1388, "bytes32 _type");
insert TypeName(1391, 1390, "bytes32");
insert PrimitiveType(1392, 1391, "bytes32");
insert Identifier(1393, 1390, "_type");
insert Parameter(1394, 1388, "address _implementation");
insert TypeName(1395, 1394, "address");
insert PrimitiveType(1396, 1395, "address");
insert Identifier(1397, 1394, "_implementation");
insert Visibility(1398, 1388, "external");
insert ModifierInvocation(1399, 1388, "onlyRole(ADMIN)");
insert Identifier(1400, 1399, "onlyRole");
insert CallArgument(1401, 1399, "ADMIN");
insert Expression(1402, 1401, "ADMIN");
insert Identifier(1403, 1402, "ADMIN");
insert FunctionBody(1404, 1388, "{\n        if (_implementation == address(0)) revert ZeroAddressImplementation();\n\n        uint256 _version = currentVersions[_type];\n        address currentImplementation = implementations[_type][_version];\n\n        if (currentImplementation == address(0)) {\n            implementations[_type][_version] = _implementation;\n        } else {\n            _version++;\n            implementations[_type][_version] = _implementation;\n            currentVersions[_type] = _version;\n        }\n\n        emit AddImplementation(_type, _version, _implementation);\n    }");
insert Statement(1405, 1404, "if (_implementation == address(0)) revert ZeroAddressImplementation();");
insert IfStatement(1406, 1405, "if (_implementation == address(0)) revert ZeroAddressImplementation();");
insert Expression(1407, 1406, "_implementation == address(0)");
insert BinaryExpression(1408, 1407, "_implementation == address(0)");
insert Expression(1409, 1408, "_implementation");
insert Identifier(1410, 1409, "_implementation");
insert Expression(1411, 1408, "address(0)");
insert TypeCastExpression(1412, 1411, "address(0)");
insert PrimitiveType(1413, 1412, "address");
insert CallArgument(1414, 1412, "0");
insert Expression(1415, 1414, "0");
insert NumberLiteral(1416, 1415, "0");
insert Statement(1417, 1406, "revert ZeroAddressImplementation();");
insert RevertStatement(1418, 1417, "revert ZeroAddressImplementation();");
insert Expression(1419, 1418, "ZeroAddressImplementation");
insert Identifier(1420, 1419, "ZeroAddressImplementation");
insert RevertArguments(1421, 1418, "()");
insert Statement(1422, 1404, "uint256 _version = currentVersions[_type];");
insert VariableDeclarationStatement(1423, 1422, "uint256 _version = currentVersions[_type];");
insert VariableDeclaration(1424, 1423, "uint256 _version");
insert TypeName(1425, 1424, "uint256");
insert PrimitiveType(1426, 1425, "uint256");
insert Identifier(1427, 1424, "_version");
insert Expression(1428, 1423, "currentVersions[_type]");
insert ArrayAccess(1429, 1428, "currentVersions[_type]");
insert Expression(1430, 1429, "currentVersions");
insert Identifier(1431, 1430, "currentVersions");
insert Expression(1432, 1429, "_type");
insert Identifier(1433, 1432, "_type");
insert Statement(1434, 1404, "address currentImplementation = implementations[_type][_version];");
insert VariableDeclarationStatement(1435, 1434, "address currentImplementation = implementations[_type][_version];");
insert VariableDeclaration(1436, 1435, "address currentImplementation");
insert TypeName(1437, 1436, "address");
insert PrimitiveType(1438, 1437, "address");
insert Identifier(1439, 1436, "currentImplementation");
insert Expression(1440, 1435, "implementations[_type][_version]");
insert ArrayAccess(1441, 1440, "implementations[_type][_version]");
insert Expression(1442, 1441, "implementations[_type]");
insert ArrayAccess(1443, 1442, "implementations[_type]");
insert Expression(1444, 1443, "implementations");
insert Identifier(1445, 1444, "implementations");
insert Expression(1446, 1443, "_type");
insert Identifier(1447, 1446, "_type");
insert Expression(1448, 1441, "_version");
insert Identifier(1449, 1448, "_version");
insert Statement(1450, 1404, "if (currentImplementation == address(0)) {\n            implementations[_type][_version] = _implementation;\n        } else {\n            _version++;\n            implementations[_type][_version] = _implementation;\n            currentVersions[_type] = _version;\n        }");
insert IfStatement(1451, 1450, "if (currentImplementation == address(0)) {\n            implementations[_type][_version] = _implementation;\n        } else {\n            _version++;\n            implementations[_type][_version] = _implementation;\n            currentVersions[_type] = _version;\n        }");
insert Expression(1452, 1451, "currentImplementation == address(0)");
insert BinaryExpression(1453, 1452, "currentImplementation == address(0)");
insert Expression(1454, 1453, "currentImplementation");
insert Identifier(1455, 1454, "currentImplementation");
insert Expression(1456, 1453, "address(0)");
insert TypeCastExpression(1457, 1456, "address(0)");
insert PrimitiveType(1458, 1457, "address");
insert CallArgument(1459, 1457, "0");
insert Expression(1460, 1459, "0");
insert NumberLiteral(1461, 1460, "0");
insert Statement(1462, 1451, "{\n            implementations[_type][_version] = _implementation;\n        }");
insert BlockStatement(1463, 1462, "{\n            implementations[_type][_version] = _implementation;\n        }");
insert Statement(1464, 1463, "implementations[_type][_version] = _implementation;");
insert ExpressionStatement(1465, 1464, "implementations[_type][_version] = _implementation;");
insert Expression(1466, 1465, "implementations[_type][_version] = _implementation");
insert AssignmentExpression(1467, 1466, "implementations[_type][_version] = _implementation");
insert Expression(1468, 1467, "implementations[_type][_version]");
insert ArrayAccess(1469, 1468, "implementations[_type][_version]");
insert Expression(1470, 1469, "implementations[_type]");
insert ArrayAccess(1471, 1470, "implementations[_type]");
insert Expression(1472, 1471, "implementations");
insert Identifier(1473, 1472, "implementations");
insert Expression(1474, 1471, "_type");
insert Identifier(1475, 1474, "_type");
insert Expression(1476, 1469, "_version");
insert Identifier(1477, 1476, "_version");
insert Expression(1478, 1467, "_implementation");
insert Identifier(1479, 1478, "_implementation");
insert Statement(1480, 1451, "{\n            _version++;\n            implementations[_type][_version] = _implementation;\n            currentVersions[_type] = _version;\n        }");
insert BlockStatement(1481, 1480, "{\n            _version++;\n            implementations[_type][_version] = _implementation;\n            currentVersions[_type] = _version;\n        }");
insert Statement(1482, 1481, "_version++;");
insert ExpressionStatement(1483, 1482, "_version++;");
insert Expression(1484, 1483, "_version++");
insert UpdateExpression(1485, 1484, "_version++");
insert Expression(1486, 1485, "_version");
insert Identifier(1487, 1486, "_version");
insert Statement(1488, 1481, "implementations[_type][_version] = _implementation;");
insert ExpressionStatement(1489, 1488, "implementations[_type][_version] = _implementation;");
insert Expression(1490, 1489, "implementations[_type][_version] = _implementation");
insert AssignmentExpression(1491, 1490, "implementations[_type][_version] = _implementation");
insert Expression(1492, 1491, "implementations[_type][_version]");
insert ArrayAccess(1493, 1492, "implementations[_type][_version]");
insert Expression(1494, 1493, "implementations[_type]");
insert ArrayAccess(1495, 1494, "implementations[_type]");
insert Expression(1496, 1495, "implementations");
insert Identifier(1497, 1496, "implementations");
insert Expression(1498, 1495, "_type");
insert Identifier(1499, 1498, "_type");
insert Expression(1500, 1493, "_version");
insert Identifier(1501, 1500, "_version");
insert Expression(1502, 1491, "_implementation");
insert Identifier(1503, 1502, "_implementation");
insert Statement(1504, 1481, "currentVersions[_type] = _version;");
insert ExpressionStatement(1505, 1504, "currentVersions[_type] = _version;");
insert Expression(1506, 1505, "currentVersions[_type] = _version");
insert AssignmentExpression(1507, 1506, "currentVersions[_type] = _version");
insert Expression(1508, 1507, "currentVersions[_type]");
insert ArrayAccess(1509, 1508, "currentVersions[_type]");
insert Expression(1510, 1509, "currentVersions");
insert Identifier(1511, 1510, "currentVersions");
insert Expression(1512, 1509, "_type");
insert Identifier(1513, 1512, "_type");
insert Expression(1514, 1507, "_version");
insert Identifier(1515, 1514, "_version");
insert Statement(1516, 1404, "emit AddImplementation(_type, _version, _implementation);");
insert EmitStatement(1517, 1516, "emit AddImplementation(_type, _version, _implementation);");
insert Expression(1518, 1517, "AddImplementation");
insert Identifier(1519, 1518, "AddImplementation");
insert CallArgument(1520, 1517, "_type");
insert Expression(1521, 1520, "_type");
insert Identifier(1522, 1521, "_type");
insert CallArgument(1523, 1517, "_version");
insert Expression(1524, 1523, "_version");
insert Identifier(1525, 1524, "_version");
insert CallArgument(1526, 1517, "_implementation");
insert Expression(1527, 1526, "_implementation");
insert Identifier(1528, 1527, "_implementation");
insert SourceFile(1529, 0, "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {ISmartInvoiceInstant} from \"./interfaces/ISmartInvoiceInstant.sol\";\nimport {IWRAPPED} from \"./interfaces/IWRAPPED.sol\";\n\n/// @title SmartInvoiceInstant\n/// @notice A contract for handling instant invoices with late fee calculations and token transfers.\ncontract SmartInvoiceInstant is\n    ISmartInvoiceInstant,\n    Initializable,\n    Context,\n    ReentrancyGuard\n{\n    using SafeERC20 for IERC20;\n\n    address public wrappedNativeToken;\n\n    address public client;\n    address public provider;\n    address public token;\n    bytes32 public details;\n    uint256 public override deadline;\n\n    uint256[] public amounts;\n    uint256 public total = 0;\n    uint256 public override totalFulfilled = 0;\n    bool public override fulfilled;\n    uint256 public fulfillTime = 0;\n    uint256 public constant MAX_DEADLINE = 63113904; // 2-year limit on locker\n\n    uint256 public override lateFee = 0;\n    uint256 public override lateFeeTimeInterval = 0;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract with the provided provider, amounts, and data.\n     * @param _provider The address of the provider\n     * @param _amounts The array of amounts associated with the provider\n     * @param _data The additional data needed for initialization\n     */\n    function init(\n        address _provider,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external override initializer {\n        if (_provider == address(0)) revert InvalidProvider();\n\n        _handleData(_data);\n\n        provider = _provider;\n\n        uint256 _total = 0;\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            _total += _amounts[i];\n        }\n        total = _total;\n    }\n\n    /**\n     * @notice Calculates the total amount due, including late fees if applicable.\n     * @return The total amount due\n     */\n    function getTotalDue() public view override returns (uint256) {\n        uint256 totalLateFee = 0;\n        if (block.timestamp > deadline && deadline > 0) {\n            uint256 timeAfterDeadline = 0;\n            if (fulfilled && fulfillTime > 0) {\n                if (fulfillTime >= deadline) {\n                    timeAfterDeadline = fulfillTime - deadline;\n                }\n            } else {\n                timeAfterDeadline = block.timestamp - deadline;\n            }\n            if (\n                timeAfterDeadline >= lateFeeTimeInterval &&\n                lateFeeTimeInterval != 0\n            ) {\n                totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval);\n            } else {\n                totalLateFee = 0;\n            }\n        }\n        return total + totalLateFee;\n    }\n\n    /**\n     * @notice Deposits tokens into the contract.\n     * @param _token The address of the token to deposit\n     * @param _amount The amount of tokens to deposit\n     */\n    function depositTokens(\n        address _token,\n        uint256 _amount\n    ) external override nonReentrant {\n        if (_token != token) revert TokenMismatch();\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        _deposit(_amount);\n    }\n\n    /**\n     * @notice Withdraws the balance of the invoice token to the provider.\n     */\n    function withdraw() external override nonReentrant {\n        return _withdraw();\n    }\n\n    /**\n     * @notice Withdraws tokens that are not the invoice token.\n     * @param _token The address of the token to withdraw\n     */\n    function withdrawTokens(address _token) external override nonReentrant {\n        if (_token == token) {\n            _withdraw();\n        } else {\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n            IERC20(_token).safeTransfer(provider, balance);\n        }\n    }\n\n    /**\n     * @notice Tips the provider with additional tokens.\n     * @param _token The address of the token to tip\n     * @param _amount The amount of tokens to tip\n     */\n    function tip(\n        address _token,\n        uint256 _amount\n    ) external override nonReentrant {\n        if (!fulfilled) revert AlreadyFulfilled();\n        if (_token != token) revert TokenMismatch();\n        totalFulfilled += _amount;\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        emit Tip(_msgSender(), _amount);\n    }\n\n    /**\n     * @dev Internal function to handle deposits.\n     * @param _amount The amount to deposit\n     */\n    function _deposit(uint256 _amount) internal {\n        uint256 totalDue = getTotalDue();\n        totalFulfilled += _amount;\n        if (totalFulfilled >= totalDue) {\n            fulfilled = true;\n            fulfillTime = block.timestamp;\n            emit Fulfilled(_msgSender());\n            if (totalFulfilled > totalDue) {\n                emit Tip(_msgSender(), totalFulfilled - totalDue);\n            }\n        }\n        emit Deposit(_msgSender(), _amount);\n    }\n\n    /**\n     * @dev Internal function to handle withdrawals.\n     */\n    function _withdraw() internal {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n        IERC20(token).safeTransfer(provider, balance);\n        emit Withdraw(balance);\n    }\n\n    /**\n     * @dev Internal function to handle initialization data.\n     * @param _data The data to be handled and decoded\n     */\n    function _handleData(bytes calldata _data) internal {\n        (\n            address _client,\n            address _token,\n            uint256 _deadline,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            uint256 _lateFee,\n            uint256 _lateFeeTimeInterval\n        ) = abi.decode(\n                _data,\n                (address, address, uint256, bytes32, address, uint256, uint256)\n            );\n\n        if (_client == address(0)) revert InvalidClient();\n        if (_token == address(0)) revert InvalidToken();\n        if (_deadline <= block.timestamp && _deadline != 0)\n            revert DurationEnded();\n        if (_deadline > block.timestamp + MAX_DEADLINE)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        client = _client;\n        token = _token;\n        deadline = _deadline;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        lateFee = _lateFee;\n        lateFeeTimeInterval = _lateFeeTimeInterval;\n    }\n\n    /**\n     * @notice Fallback function to receive native token transfers.\n     */\n    receive() external payable {\n        if (token != wrappedNativeToken) revert TokenNotWrappedNativeToken();\n        IWRAPPED(wrappedNativeToken).deposit{value: msg.value}();\n        _deposit(msg.value);\n    }\n}\n");
insert Comment(1530, 1529, "// SPDX-License-Identifier: MIT");
insert PragmaDirective(1531, 1529, "pragma solidity ^0.8.20;");
insert SolidityPragmaToken(1532, 1531, "solidity ^0.8.20");
insert SolidityVersionComparisonOperator(1533, 1532, " ^");
insert SolidityVersion(1534, 1532, "0.8.20");
insert ImportDirective(1535, 1529, "import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";");
insert Identifier(1536, 1535, "IERC20");
insert ImportDirective(1537, 1529, "import {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";");
insert Identifier(1538, 1537, "SafeERC20");
insert ImportDirective(1539, 1529, "import {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";");
insert Identifier(1540, 1539, "ReentrancyGuard");
insert ImportDirective(1541, 1529, "import {Context} from \"@openzeppelin/contracts/utils/Context.sol\";");
insert Identifier(1542, 1541, "Context");
insert ImportDirective(1543, 1529, "import {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";");
insert Identifier(1544, 1543, "Initializable");
insert ImportDirective(1545, 1529, "import {ISmartInvoiceInstant} from \"./interfaces/ISmartInvoiceInstant.sol\";");
insert Identifier(1546, 1545, "ISmartInvoiceInstant");
insert ImportDirective(1547, 1529, "import {IWRAPPED} from \"./interfaces/IWRAPPED.sol\";");
insert Identifier(1548, 1547, "IWRAPPED");
insert Comment(1549, 1529, "/// @title SmartInvoiceInstant");
insert Comment(1550, 1529, "/// @notice A contract for handling instant invoices with late fee calculations and token transfers.");
insert ContractDeclaration(1551, 1529, "contract SmartInvoiceInstant is\n    ISmartInvoiceInstant,\n    Initializable,\n    Context,\n    ReentrancyGuard\n{\n    using SafeERC20 for IERC20;\n\n    address public wrappedNativeToken;\n\n    address public client;\n    address public provider;\n    address public token;\n    bytes32 public details;\n    uint256 public override deadline;\n\n    uint256[] public amounts;\n    uint256 public total = 0;\n    uint256 public override totalFulfilled = 0;\n    bool public override fulfilled;\n    uint256 public fulfillTime = 0;\n    uint256 public constant MAX_DEADLINE = 63113904; // 2-year limit on locker\n\n    uint256 public override lateFee = 0;\n    uint256 public override lateFeeTimeInterval = 0;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract with the provided provider, amounts, and data.\n     * @param _provider The address of the provider\n     * @param _amounts The array of amounts associated with the provider\n     * @param _data The additional data needed for initialization\n     */\n    function init(\n        address _provider,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external override initializer {\n        if (_provider == address(0)) revert InvalidProvider();\n\n        _handleData(_data);\n\n        provider = _provider;\n\n        uint256 _total = 0;\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            _total += _amounts[i];\n        }\n        total = _total;\n    }\n\n    /**\n     * @notice Calculates the total amount due, including late fees if applicable.\n     * @return The total amount due\n     */\n    function getTotalDue() public view override returns (uint256) {\n        uint256 totalLateFee = 0;\n        if (block.timestamp > deadline && deadline > 0) {\n            uint256 timeAfterDeadline = 0;\n            if (fulfilled && fulfillTime > 0) {\n                if (fulfillTime >= deadline) {\n                    timeAfterDeadline = fulfillTime - deadline;\n                }\n            } else {\n                timeAfterDeadline = block.timestamp - deadline;\n            }\n            if (\n                timeAfterDeadline >= lateFeeTimeInterval &&\n                lateFeeTimeInterval != 0\n            ) {\n                totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval);\n            } else {\n                totalLateFee = 0;\n            }\n        }\n        return total + totalLateFee;\n    }\n\n    /**\n     * @notice Deposits tokens into the contract.\n     * @param _token The address of the token to deposit\n     * @param _amount The amount of tokens to deposit\n     */\n    function depositTokens(\n        address _token,\n        uint256 _amount\n    ) external override nonReentrant {\n        if (_token != token) revert TokenMismatch();\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        _deposit(_amount);\n    }\n\n    /**\n     * @notice Withdraws the balance of the invoice token to the provider.\n     */\n    function withdraw() external override nonReentrant {\n        return _withdraw();\n    }\n\n    /**\n     * @notice Withdraws tokens that are not the invoice token.\n     * @param _token The address of the token to withdraw\n     */\n    function withdrawTokens(address _token) external override nonReentrant {\n        if (_token == token) {\n            _withdraw();\n        } else {\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n            IERC20(_token).safeTransfer(provider, balance);\n        }\n    }\n\n    /**\n     * @notice Tips the provider with additional tokens.\n     * @param _token The address of the token to tip\n     * @param _amount The amount of tokens to tip\n     */\n    function tip(\n        address _token,\n        uint256 _amount\n    ) external override nonReentrant {\n        if (!fulfilled) revert AlreadyFulfilled();\n        if (_token != token) revert TokenMismatch();\n        totalFulfilled += _amount;\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        emit Tip(_msgSender(), _amount);\n    }\n\n    /**\n     * @dev Internal function to handle deposits.\n     * @param _amount The amount to deposit\n     */\n    function _deposit(uint256 _amount) internal {\n        uint256 totalDue = getTotalDue();\n        totalFulfilled += _amount;\n        if (totalFulfilled >= totalDue) {\n            fulfilled = true;\n            fulfillTime = block.timestamp;\n            emit Fulfilled(_msgSender());\n            if (totalFulfilled > totalDue) {\n                emit Tip(_msgSender(), totalFulfilled - totalDue);\n            }\n        }\n        emit Deposit(_msgSender(), _amount);\n    }\n\n    /**\n     * @dev Internal function to handle withdrawals.\n     */\n    function _withdraw() internal {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n        IERC20(token).safeTransfer(provider, balance);\n        emit Withdraw(balance);\n    }\n\n    /**\n     * @dev Internal function to handle initialization data.\n     * @param _data The data to be handled and decoded\n     */\n    function _handleData(bytes calldata _data) internal {\n        (\n            address _client,\n            address _token,\n            uint256 _deadline,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            uint256 _lateFee,\n            uint256 _lateFeeTimeInterval\n        ) = abi.decode(\n                _data,\n                (address, address, uint256, bytes32, address, uint256, uint256)\n            );\n\n        if (_client == address(0)) revert InvalidClient();\n        if (_token == address(0)) revert InvalidToken();\n        if (_deadline <= block.timestamp && _deadline != 0)\n            revert DurationEnded();\n        if (_deadline > block.timestamp + MAX_DEADLINE)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        client = _client;\n        token = _token;\n        deadline = _deadline;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        lateFee = _lateFee;\n        lateFeeTimeInterval = _lateFeeTimeInterval;\n    }\n\n    /**\n     * @notice Fallback function to receive native token transfers.\n     */\n    receive() external payable {\n        if (token != wrappedNativeToken) revert TokenNotWrappedNativeToken();\n        IWRAPPED(wrappedNativeToken).deposit{value: msg.value}();\n        _deposit(msg.value);\n    }\n}");
insert Identifier(1552, 1551, "SmartInvoiceInstant");
insert InheritanceSpecifier(1553, 1551, "ISmartInvoiceInstant");
insert UserDefinedType(1554, 1553, "ISmartInvoiceInstant");
insert Identifier(1555, 1554, "ISmartInvoiceInstant");
insert InheritanceSpecifier(1556, 1551, "Initializable");
insert UserDefinedType(1557, 1556, "Initializable");
insert Identifier(1558, 1557, "Initializable");
insert InheritanceSpecifier(1559, 1551, "Context");
insert UserDefinedType(1560, 1559, "Context");
insert Identifier(1561, 1560, "Context");
insert InheritanceSpecifier(1562, 1551, "ReentrancyGuard");
insert UserDefinedType(1563, 1562, "ReentrancyGuard");
insert Identifier(1564, 1563, "ReentrancyGuard");
insert ContractBody(1565, 1551, "{\n    using SafeERC20 for IERC20;\n\n    address public wrappedNativeToken;\n\n    address public client;\n    address public provider;\n    address public token;\n    bytes32 public details;\n    uint256 public override deadline;\n\n    uint256[] public amounts;\n    uint256 public total = 0;\n    uint256 public override totalFulfilled = 0;\n    bool public override fulfilled;\n    uint256 public fulfillTime = 0;\n    uint256 public constant MAX_DEADLINE = 63113904; // 2-year limit on locker\n\n    uint256 public override lateFee = 0;\n    uint256 public override lateFeeTimeInterval = 0;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract with the provided provider, amounts, and data.\n     * @param _provider The address of the provider\n     * @param _amounts The array of amounts associated with the provider\n     * @param _data The additional data needed for initialization\n     */\n    function init(\n        address _provider,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external override initializer {\n        if (_provider == address(0)) revert InvalidProvider();\n\n        _handleData(_data);\n\n        provider = _provider;\n\n        uint256 _total = 0;\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            _total += _amounts[i];\n        }\n        total = _total;\n    }\n\n    /**\n     * @notice Calculates the total amount due, including late fees if applicable.\n     * @return The total amount due\n     */\n    function getTotalDue() public view override returns (uint256) {\n        uint256 totalLateFee = 0;\n        if (block.timestamp > deadline && deadline > 0) {\n            uint256 timeAfterDeadline = 0;\n            if (fulfilled && fulfillTime > 0) {\n                if (fulfillTime >= deadline) {\n                    timeAfterDeadline = fulfillTime - deadline;\n                }\n            } else {\n                timeAfterDeadline = block.timestamp - deadline;\n            }\n            if (\n                timeAfterDeadline >= lateFeeTimeInterval &&\n                lateFeeTimeInterval != 0\n            ) {\n                totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval);\n            } else {\n                totalLateFee = 0;\n            }\n        }\n        return total + totalLateFee;\n    }\n\n    /**\n     * @notice Deposits tokens into the contract.\n     * @param _token The address of the token to deposit\n     * @param _amount The amount of tokens to deposit\n     */\n    function depositTokens(\n        address _token,\n        uint256 _amount\n    ) external override nonReentrant {\n        if (_token != token) revert TokenMismatch();\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        _deposit(_amount);\n    }\n\n    /**\n     * @notice Withdraws the balance of the invoice token to the provider.\n     */\n    function withdraw() external override nonReentrant {\n        return _withdraw();\n    }\n\n    /**\n     * @notice Withdraws tokens that are not the invoice token.\n     * @param _token The address of the token to withdraw\n     */\n    function withdrawTokens(address _token) external override nonReentrant {\n        if (_token == token) {\n            _withdraw();\n        } else {\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n            IERC20(_token).safeTransfer(provider, balance);\n        }\n    }\n\n    /**\n     * @notice Tips the provider with additional tokens.\n     * @param _token The address of the token to tip\n     * @param _amount The amount of tokens to tip\n     */\n    function tip(\n        address _token,\n        uint256 _amount\n    ) external override nonReentrant {\n        if (!fulfilled) revert AlreadyFulfilled();\n        if (_token != token) revert TokenMismatch();\n        totalFulfilled += _amount;\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        emit Tip(_msgSender(), _amount);\n    }\n\n    /**\n     * @dev Internal function to handle deposits.\n     * @param _amount The amount to deposit\n     */\n    function _deposit(uint256 _amount) internal {\n        uint256 totalDue = getTotalDue();\n        totalFulfilled += _amount;\n        if (totalFulfilled >= totalDue) {\n            fulfilled = true;\n            fulfillTime = block.timestamp;\n            emit Fulfilled(_msgSender());\n            if (totalFulfilled > totalDue) {\n                emit Tip(_msgSender(), totalFulfilled - totalDue);\n            }\n        }\n        emit Deposit(_msgSender(), _amount);\n    }\n\n    /**\n     * @dev Internal function to handle withdrawals.\n     */\n    function _withdraw() internal {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n        IERC20(token).safeTransfer(provider, balance);\n        emit Withdraw(balance);\n    }\n\n    /**\n     * @dev Internal function to handle initialization data.\n     * @param _data The data to be handled and decoded\n     */\n    function _handleData(bytes calldata _data) internal {\n        (\n            address _client,\n            address _token,\n            uint256 _deadline,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            uint256 _lateFee,\n            uint256 _lateFeeTimeInterval\n        ) = abi.decode(\n                _data,\n                (address, address, uint256, bytes32, address, uint256, uint256)\n            );\n\n        if (_client == address(0)) revert InvalidClient();\n        if (_token == address(0)) revert InvalidToken();\n        if (_deadline <= block.timestamp && _deadline != 0)\n            revert DurationEnded();\n        if (_deadline > block.timestamp + MAX_DEADLINE)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        client = _client;\n        token = _token;\n        deadline = _deadline;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        lateFee = _lateFee;\n        lateFeeTimeInterval = _lateFeeTimeInterval;\n    }\n\n    /**\n     * @notice Fallback function to receive native token transfers.\n     */\n    receive() external payable {\n        if (token != wrappedNativeToken) revert TokenNotWrappedNativeToken();\n        IWRAPPED(wrappedNativeToken).deposit{value: msg.value}();\n        _deposit(msg.value);\n    }\n}");
insert UsingDirective(1566, 1565, "using SafeERC20 for IERC20;");
insert TypeAlias(1567, 1566, "SafeERC20");
insert Identifier(1568, 1567, "SafeERC20");
insert TypeName(1569, 1566, "IERC20");
insert UserDefinedType(1570, 1569, "IERC20");
insert Identifier(1571, 1570, "IERC20");
insert StateVariableDeclaration(1572, 1565, "address public wrappedNativeToken;");
insert TypeName(1573, 1572, "address");
insert PrimitiveType(1574, 1573, "address");
insert Visibility(1575, 1572, "public");
insert Identifier(1576, 1572, "wrappedNativeToken");
insert StateVariableDeclaration(1577, 1565, "address public client;");
insert TypeName(1578, 1577, "address");
insert PrimitiveType(1579, 1578, "address");
insert Visibility(1580, 1577, "public");
insert Identifier(1581, 1577, "client");
insert StateVariableDeclaration(1582, 1565, "address public provider;");
insert TypeName(1583, 1582, "address");
insert PrimitiveType(1584, 1583, "address");
insert Visibility(1585, 1582, "public");
insert Identifier(1586, 1582, "provider");
insert StateVariableDeclaration(1587, 1565, "address public token;");
insert TypeName(1588, 1587, "address");
insert PrimitiveType(1589, 1588, "address");
insert Visibility(1590, 1587, "public");
insert Identifier(1591, 1587, "token");
insert StateVariableDeclaration(1592, 1565, "bytes32 public details;");
insert TypeName(1593, 1592, "bytes32");
insert PrimitiveType(1594, 1593, "bytes32");
insert Visibility(1595, 1592, "public");
insert Identifier(1596, 1592, "details");
insert StateVariableDeclaration(1597, 1565, "uint256 public override deadline;");
insert TypeName(1598, 1597, "uint256");
insert PrimitiveType(1599, 1598, "uint256");
insert Visibility(1600, 1597, "public");
insert OverrideSpecifier(1601, 1597, "override");
insert Identifier(1602, 1597, "deadline");
insert StateVariableDeclaration(1603, 1565, "uint256[] public amounts;");
insert TypeName(1604, 1603, "uint256[]");
insert TypeName(1605, 1604, "uint256");
insert PrimitiveType(1606, 1605, "uint256");
insert Visibility(1607, 1603, "public");
insert Identifier(1608, 1603, "amounts");
insert StateVariableDeclaration(1609, 1565, "uint256 public total = 0;");
insert TypeName(1610, 1609, "uint256");
insert PrimitiveType(1611, 1610, "uint256");
insert Visibility(1612, 1609, "public");
insert Identifier(1613, 1609, "total");
insert Expression(1614, 1609, "0");
insert NumberLiteral(1615, 1614, "0");
insert StateVariableDeclaration(1616, 1565, "uint256 public override totalFulfilled = 0;");
insert TypeName(1617, 1616, "uint256");
insert PrimitiveType(1618, 1617, "uint256");
insert Visibility(1619, 1616, "public");
insert OverrideSpecifier(1620, 1616, "override");
insert Identifier(1621, 1616, "totalFulfilled");
insert Expression(1622, 1616, "0");
insert NumberLiteral(1623, 1622, "0");
insert StateVariableDeclaration(1624, 1565, "bool public override fulfilled;");
insert TypeName(1625, 1624, "bool");
insert PrimitiveType(1626, 1625, "bool");
insert Visibility(1627, 1624, "public");
insert OverrideSpecifier(1628, 1624, "override");
insert Identifier(1629, 1624, "fulfilled");
insert StateVariableDeclaration(1630, 1565, "uint256 public fulfillTime = 0;");
insert TypeName(1631, 1630, "uint256");
insert PrimitiveType(1632, 1631, "uint256");
insert Visibility(1633, 1630, "public");
insert Identifier(1634, 1630, "fulfillTime");
insert Expression(1635, 1630, "0");
insert NumberLiteral(1636, 1635, "0");
insert StateVariableDeclaration(1637, 1565, "uint256 public constant MAX_DEADLINE = 63113904;");
insert TypeName(1638, 1637, "uint256");
insert PrimitiveType(1639, 1638, "uint256");
insert Visibility(1640, 1637, "public");
insert Identifier(1641, 1637, "MAX_DEADLINE");
insert Expression(1642, 1637, "63113904");
insert NumberLiteral(1643, 1642, "63113904");
insert Comment(1644, 1565, "// 2-year limit on locker");
insert StateVariableDeclaration(1645, 1565, "uint256 public override lateFee = 0;");
insert TypeName(1646, 1645, "uint256");
insert PrimitiveType(1647, 1646, "uint256");
insert Visibility(1648, 1645, "public");
insert OverrideSpecifier(1649, 1645, "override");
insert Identifier(1650, 1645, "lateFee");
insert Expression(1651, 1645, "0");
insert NumberLiteral(1652, 1651, "0");
insert StateVariableDeclaration(1653, 1565, "uint256 public override lateFeeTimeInterval = 0;");
insert TypeName(1654, 1653, "uint256");
insert PrimitiveType(1655, 1654, "uint256");
insert Visibility(1656, 1653, "public");
insert OverrideSpecifier(1657, 1653, "override");
insert Identifier(1658, 1653, "lateFeeTimeInterval");
insert Expression(1659, 1653, "0");
insert NumberLiteral(1660, 1659, "0");
insert ConstructorDefinition(1661, 1565, "constructor() {\n        _disableInitializers();\n    }");
insert FunctionBody(1662, 1661, "{\n        _disableInitializers();\n    }");
insert Statement(1663, 1662, "_disableInitializers();");
insert ExpressionStatement(1664, 1663, "_disableInitializers();");
insert Expression(1665, 1664, "_disableInitializers()");
insert CallExpression(1666, 1665, "_disableInitializers()");
insert Expression(1667, 1666, "_disableInitializers");
insert Identifier(1668, 1667, "_disableInitializers");
insert Comment(1669, 1565, "/**\n     * @notice Initializes the contract with the provided provider, amounts, and data.\n     * @param _provider The address of the provider\n     * @param _amounts The array of amounts associated with the provider\n     * @param _data The additional data needed for initialization\n     */");
insert FunctionDefinition(1670, 1565, "function init(\n        address _provider,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external override initializer {\n        if (_provider == address(0)) revert InvalidProvider();\n\n        _handleData(_data);\n\n        provider = _provider;\n\n        uint256 _total = 0;\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            _total += _amounts[i];\n        }\n        total = _total;\n    }");
insert Identifier(1671, 1670, "init");
insert Parameter(1672, 1670, "address _provider");
insert TypeName(1673, 1672, "address");
insert PrimitiveType(1674, 1673, "address");
insert Identifier(1675, 1672, "_provider");
insert Parameter(1676, 1670, "uint256[] calldata _amounts");
insert TypeName(1677, 1676, "uint256[]");
insert TypeName(1678, 1677, "uint256");
insert PrimitiveType(1679, 1678, "uint256");
insert Identifier(1680, 1676, "_amounts");
insert Parameter(1681, 1670, "bytes calldata _data");
insert TypeName(1682, 1681, "bytes");
insert PrimitiveType(1683, 1682, "bytes");
insert Identifier(1684, 1681, "_data");
insert Visibility(1685, 1670, "external");
insert OverrideSpecifier(1686, 1670, "override");
insert ModifierInvocation(1687, 1670, "initializer");
insert Identifier(1688, 1687, "initializer");
insert FunctionBody(1689, 1670, "{\n        if (_provider == address(0)) revert InvalidProvider();\n\n        _handleData(_data);\n\n        provider = _provider;\n\n        uint256 _total = 0;\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            _total += _amounts[i];\n        }\n        total = _total;\n    }");
insert Statement(1690, 1689, "if (_provider == address(0)) revert InvalidProvider();");
insert IfStatement(1691, 1690, "if (_provider == address(0)) revert InvalidProvider();");
insert Expression(1692, 1691, "_provider == address(0)");
insert BinaryExpression(1693, 1692, "_provider == address(0)");
insert Expression(1694, 1693, "_provider");
insert Identifier(1695, 1694, "_provider");
insert Expression(1696, 1693, "address(0)");
insert TypeCastExpression(1697, 1696, "address(0)");
insert PrimitiveType(1698, 1697, "address");
insert CallArgument(1699, 1697, "0");
insert Expression(1700, 1699, "0");
insert NumberLiteral(1701, 1700, "0");
insert Statement(1702, 1691, "revert InvalidProvider();");
insert RevertStatement(1703, 1702, "revert InvalidProvider();");
insert Expression(1704, 1703, "InvalidProvider");
insert Identifier(1705, 1704, "InvalidProvider");
insert RevertArguments(1706, 1703, "()");
insert Statement(1707, 1689, "_handleData(_data);");
insert ExpressionStatement(1708, 1707, "_handleData(_data);");
insert Expression(1709, 1708, "_handleData(_data)");
insert CallExpression(1710, 1709, "_handleData(_data)");
insert Expression(1711, 1710, "_handleData");
insert Identifier(1712, 1711, "_handleData");
insert CallArgument(1713, 1710, "_data");
insert Expression(1714, 1713, "_data");
insert Identifier(1715, 1714, "_data");
insert Statement(1716, 1689, "provider = _provider;");
insert ExpressionStatement(1717, 1716, "provider = _provider;");
insert Expression(1718, 1717, "provider = _provider");
insert AssignmentExpression(1719, 1718, "provider = _provider");
insert Expression(1720, 1719, "provider");
insert Identifier(1721, 1720, "provider");
insert Expression(1722, 1719, "_provider");
insert Identifier(1723, 1722, "_provider");
insert Statement(1724, 1689, "uint256 _total = 0;");
insert VariableDeclarationStatement(1725, 1724, "uint256 _total = 0;");
insert VariableDeclaration(1726, 1725, "uint256 _total");
insert TypeName(1727, 1726, "uint256");
insert PrimitiveType(1728, 1727, "uint256");
insert Identifier(1729, 1726, "_total");
insert Expression(1730, 1725, "0");
insert NumberLiteral(1731, 1730, "0");
insert Statement(1732, 1689, "for (uint256 i = 0; i < _amounts.length; i++) {\n            _total += _amounts[i];\n        }");
insert ForStatement(1733, 1732, "for (uint256 i = 0; i < _amounts.length; i++) {\n            _total += _amounts[i];\n        }");
insert VariableDeclarationStatement(1734, 1733, "uint256 i = 0;");
insert VariableDeclaration(1735, 1734, "uint256 i");
insert TypeName(1736, 1735, "uint256");
insert PrimitiveType(1737, 1736, "uint256");
insert Identifier(1738, 1735, "i");
insert Expression(1739, 1734, "0");
insert NumberLiteral(1740, 1739, "0");
insert ExpressionStatement(1741, 1733, "i < _amounts.length;");
insert Expression(1742, 1741, "i < _amounts.length");
insert BinaryExpression(1743, 1742, "i < _amounts.length");
insert Expression(1744, 1743, "i");
insert Identifier(1745, 1744, "i");
insert Expression(1746, 1743, "_amounts.length");
insert MemberExpression(1747, 1746, "_amounts.length");
insert Identifier(1748, 1747, "_amounts");
insert Identifier(1749, 1747, "length");
insert Expression(1750, 1733, "i++");
insert UpdateExpression(1751, 1750, "i++");
insert Expression(1752, 1751, "i");
insert Identifier(1753, 1752, "i");
insert Statement(1754, 1733, "{\n            _total += _amounts[i];\n        }");
insert BlockStatement(1755, 1754, "{\n            _total += _amounts[i];\n        }");
insert Statement(1756, 1755, "_total += _amounts[i];");
insert ExpressionStatement(1757, 1756, "_total += _amounts[i];");
insert Expression(1758, 1757, "_total += _amounts[i]");
insert AugmentedAssignmentExpression(1759, 1758, "_total += _amounts[i]");
insert Expression(1760, 1759, "_total");
insert Identifier(1761, 1760, "_total");
insert Expression(1762, 1759, "_amounts[i]");
insert ArrayAccess(1763, 1762, "_amounts[i]");
insert Expression(1764, 1763, "_amounts");
insert Identifier(1765, 1764, "_amounts");
insert Expression(1766, 1763, "i");
insert Identifier(1767, 1766, "i");
insert Statement(1768, 1689, "total = _total;");
insert ExpressionStatement(1769, 1768, "total = _total;");
insert Expression(1770, 1769, "total = _total");
insert AssignmentExpression(1771, 1770, "total = _total");
insert Expression(1772, 1771, "total");
insert Identifier(1773, 1772, "total");
insert Expression(1774, 1771, "_total");
insert Identifier(1775, 1774, "_total");
insert Comment(1776, 1565, "/**\n     * @notice Calculates the total amount due, including late fees if applicable.\n     * @return The total amount due\n     */");
insert FunctionDefinition(1777, 1565, "function getTotalDue() public view override returns (uint256) {\n        uint256 totalLateFee = 0;\n        if (block.timestamp > deadline && deadline > 0) {\n            uint256 timeAfterDeadline = 0;\n            if (fulfilled && fulfillTime > 0) {\n                if (fulfillTime >= deadline) {\n                    timeAfterDeadline = fulfillTime - deadline;\n                }\n            } else {\n                timeAfterDeadline = block.timestamp - deadline;\n            }\n            if (\n                timeAfterDeadline >= lateFeeTimeInterval &&\n                lateFeeTimeInterval != 0\n            ) {\n                totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval);\n            } else {\n                totalLateFee = 0;\n            }\n        }\n        return total + totalLateFee;\n    }");
insert Identifier(1778, 1777, "getTotalDue");
insert Visibility(1779, 1777, "public");
insert StateMutability(1780, 1777, "view");
insert OverrideSpecifier(1781, 1777, "override");
insert ReturnTypeDefinition(1782, 1777, "returns (uint256)");
insert Parameter(1783, 1782, "uint256");
insert TypeName(1784, 1783, "uint256");
insert PrimitiveType(1785, 1784, "uint256");
insert FunctionBody(1786, 1777, "{\n        uint256 totalLateFee = 0;\n        if (block.timestamp > deadline && deadline > 0) {\n            uint256 timeAfterDeadline = 0;\n            if (fulfilled && fulfillTime > 0) {\n                if (fulfillTime >= deadline) {\n                    timeAfterDeadline = fulfillTime - deadline;\n                }\n            } else {\n                timeAfterDeadline = block.timestamp - deadline;\n            }\n            if (\n                timeAfterDeadline >= lateFeeTimeInterval &&\n                lateFeeTimeInterval != 0\n            ) {\n                totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval);\n            } else {\n                totalLateFee = 0;\n            }\n        }\n        return total + totalLateFee;\n    }");
insert Statement(1787, 1786, "uint256 totalLateFee = 0;");
insert VariableDeclarationStatement(1788, 1787, "uint256 totalLateFee = 0;");
insert VariableDeclaration(1789, 1788, "uint256 totalLateFee");
insert TypeName(1790, 1789, "uint256");
insert PrimitiveType(1791, 1790, "uint256");
insert Identifier(1792, 1789, "totalLateFee");
insert Expression(1793, 1788, "0");
insert NumberLiteral(1794, 1793, "0");
insert Statement(1795, 1786, "if (block.timestamp > deadline && deadline > 0) {\n            uint256 timeAfterDeadline = 0;\n            if (fulfilled && fulfillTime > 0) {\n                if (fulfillTime >= deadline) {\n                    timeAfterDeadline = fulfillTime - deadline;\n                }\n            } else {\n                timeAfterDeadline = block.timestamp - deadline;\n            }\n            if (\n                timeAfterDeadline >= lateFeeTimeInterval &&\n                lateFeeTimeInterval != 0\n            ) {\n                totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval);\n            } else {\n                totalLateFee = 0;\n            }\n        }");
insert IfStatement(1796, 1795, "if (block.timestamp > deadline && deadline > 0) {\n            uint256 timeAfterDeadline = 0;\n            if (fulfilled && fulfillTime > 0) {\n                if (fulfillTime >= deadline) {\n                    timeAfterDeadline = fulfillTime - deadline;\n                }\n            } else {\n                timeAfterDeadline = block.timestamp - deadline;\n            }\n            if (\n                timeAfterDeadline >= lateFeeTimeInterval &&\n                lateFeeTimeInterval != 0\n            ) {\n                totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval);\n            } else {\n                totalLateFee = 0;\n            }\n        }");
insert Expression(1797, 1796, "block.timestamp > deadline && deadline > 0");
insert BinaryExpression(1798, 1797, "block.timestamp > deadline && deadline > 0");
insert Expression(1799, 1798, "block.timestamp > deadline");
insert BinaryExpression(1800, 1799, "block.timestamp > deadline");
insert Expression(1801, 1800, "block.timestamp");
insert MemberExpression(1802, 1801, "block.timestamp");
insert Identifier(1803, 1802, "block");
insert Identifier(1804, 1802, "timestamp");
insert Expression(1805, 1800, "deadline");
insert Identifier(1806, 1805, "deadline");
insert Expression(1807, 1798, "deadline > 0");
insert BinaryExpression(1808, 1807, "deadline > 0");
insert Expression(1809, 1808, "deadline");
insert Identifier(1810, 1809, "deadline");
insert Expression(1811, 1808, "0");
insert NumberLiteral(1812, 1811, "0");
insert Statement(1813, 1796, "{\n            uint256 timeAfterDeadline = 0;\n            if (fulfilled && fulfillTime > 0) {\n                if (fulfillTime >= deadline) {\n                    timeAfterDeadline = fulfillTime - deadline;\n                }\n            } else {\n                timeAfterDeadline = block.timestamp - deadline;\n            }\n            if (\n                timeAfterDeadline >= lateFeeTimeInterval &&\n                lateFeeTimeInterval != 0\n            ) {\n                totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval);\n            } else {\n                totalLateFee = 0;\n            }\n        }");
insert BlockStatement(1814, 1813, "{\n            uint256 timeAfterDeadline = 0;\n            if (fulfilled && fulfillTime > 0) {\n                if (fulfillTime >= deadline) {\n                    timeAfterDeadline = fulfillTime - deadline;\n                }\n            } else {\n                timeAfterDeadline = block.timestamp - deadline;\n            }\n            if (\n                timeAfterDeadline >= lateFeeTimeInterval &&\n                lateFeeTimeInterval != 0\n            ) {\n                totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval);\n            } else {\n                totalLateFee = 0;\n            }\n        }");
insert Statement(1815, 1814, "uint256 timeAfterDeadline = 0;");
insert VariableDeclarationStatement(1816, 1815, "uint256 timeAfterDeadline = 0;");
insert VariableDeclaration(1817, 1816, "uint256 timeAfterDeadline");
insert TypeName(1818, 1817, "uint256");
insert PrimitiveType(1819, 1818, "uint256");
insert Identifier(1820, 1817, "timeAfterDeadline");
insert Expression(1821, 1816, "0");
insert NumberLiteral(1822, 1821, "0");
insert Statement(1823, 1814, "if (fulfilled && fulfillTime > 0) {\n                if (fulfillTime >= deadline) {\n                    timeAfterDeadline = fulfillTime - deadline;\n                }\n            } else {\n                timeAfterDeadline = block.timestamp - deadline;\n            }");
insert IfStatement(1824, 1823, "if (fulfilled && fulfillTime > 0) {\n                if (fulfillTime >= deadline) {\n                    timeAfterDeadline = fulfillTime - deadline;\n                }\n            } else {\n                timeAfterDeadline = block.timestamp - deadline;\n            }");
insert Expression(1825, 1824, "fulfilled && fulfillTime > 0");
insert BinaryExpression(1826, 1825, "fulfilled && fulfillTime > 0");
insert Expression(1827, 1826, "fulfilled");
insert Identifier(1828, 1827, "fulfilled");
insert Expression(1829, 1826, "fulfillTime > 0");
insert BinaryExpression(1830, 1829, "fulfillTime > 0");
insert Expression(1831, 1830, "fulfillTime");
insert Identifier(1832, 1831, "fulfillTime");
insert Expression(1833, 1830, "0");
insert NumberLiteral(1834, 1833, "0");
insert Statement(1835, 1824, "{\n                if (fulfillTime >= deadline) {\n                    timeAfterDeadline = fulfillTime - deadline;\n                }\n            }");
insert BlockStatement(1836, 1835, "{\n                if (fulfillTime >= deadline) {\n                    timeAfterDeadline = fulfillTime - deadline;\n                }\n            }");
insert Statement(1837, 1836, "if (fulfillTime >= deadline) {\n                    timeAfterDeadline = fulfillTime - deadline;\n                }");
insert IfStatement(1838, 1837, "if (fulfillTime >= deadline) {\n                    timeAfterDeadline = fulfillTime - deadline;\n                }");
insert Expression(1839, 1838, "fulfillTime >= deadline");
insert BinaryExpression(1840, 1839, "fulfillTime >= deadline");
insert Expression(1841, 1840, "fulfillTime");
insert Identifier(1842, 1841, "fulfillTime");
insert Expression(1843, 1840, "deadline");
insert Identifier(1844, 1843, "deadline");
insert Statement(1845, 1838, "{\n                    timeAfterDeadline = fulfillTime - deadline;\n                }");
insert BlockStatement(1846, 1845, "{\n                    timeAfterDeadline = fulfillTime - deadline;\n                }");
insert Statement(1847, 1846, "timeAfterDeadline = fulfillTime - deadline;");
insert ExpressionStatement(1848, 1847, "timeAfterDeadline = fulfillTime - deadline;");
insert Expression(1849, 1848, "timeAfterDeadline = fulfillTime - deadline");
insert AssignmentExpression(1850, 1849, "timeAfterDeadline = fulfillTime - deadline");
insert Expression(1851, 1850, "timeAfterDeadline");
insert Identifier(1852, 1851, "timeAfterDeadline");
insert Expression(1853, 1850, "fulfillTime - deadline");
insert BinaryExpression(1854, 1853, "fulfillTime - deadline");
insert Expression(1855, 1854, "fulfillTime");
insert Identifier(1856, 1855, "fulfillTime");
insert Expression(1857, 1854, "deadline");
insert Identifier(1858, 1857, "deadline");
insert Statement(1859, 1824, "{\n                timeAfterDeadline = block.timestamp - deadline;\n            }");
insert BlockStatement(1860, 1859, "{\n                timeAfterDeadline = block.timestamp - deadline;\n            }");
insert Statement(1861, 1860, "timeAfterDeadline = block.timestamp - deadline;");
insert ExpressionStatement(1862, 1861, "timeAfterDeadline = block.timestamp - deadline;");
insert Expression(1863, 1862, "timeAfterDeadline = block.timestamp - deadline");
insert AssignmentExpression(1864, 1863, "timeAfterDeadline = block.timestamp - deadline");
insert Expression(1865, 1864, "timeAfterDeadline");
insert Identifier(1866, 1865, "timeAfterDeadline");
insert Expression(1867, 1864, "block.timestamp - deadline");
insert BinaryExpression(1868, 1867, "block.timestamp - deadline");
insert Expression(1869, 1868, "block.timestamp");
insert MemberExpression(1870, 1869, "block.timestamp");
insert Identifier(1871, 1870, "block");
insert Identifier(1872, 1870, "timestamp");
insert Expression(1873, 1868, "deadline");
insert Identifier(1874, 1873, "deadline");
insert Statement(1875, 1814, "if (\n                timeAfterDeadline >= lateFeeTimeInterval &&\n                lateFeeTimeInterval != 0\n            ) {\n                totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval);\n            } else {\n                totalLateFee = 0;\n            }");
insert IfStatement(1876, 1875, "if (\n                timeAfterDeadline >= lateFeeTimeInterval &&\n                lateFeeTimeInterval != 0\n            ) {\n                totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval);\n            } else {\n                totalLateFee = 0;\n            }");
insert Expression(1877, 1876, "timeAfterDeadline >= lateFeeTimeInterval &&\n                lateFeeTimeInterval != 0");
insert BinaryExpression(1878, 1877, "timeAfterDeadline >= lateFeeTimeInterval &&\n                lateFeeTimeInterval != 0");
insert Expression(1879, 1878, "timeAfterDeadline >= lateFeeTimeInterval");
insert BinaryExpression(1880, 1879, "timeAfterDeadline >= lateFeeTimeInterval");
insert Expression(1881, 1880, "timeAfterDeadline");
insert Identifier(1882, 1881, "timeAfterDeadline");
insert Expression(1883, 1880, "lateFeeTimeInterval");
insert Identifier(1884, 1883, "lateFeeTimeInterval");
insert Expression(1885, 1878, "lateFeeTimeInterval != 0");
insert BinaryExpression(1886, 1885, "lateFeeTimeInterval != 0");
insert Expression(1887, 1886, "lateFeeTimeInterval");
insert Identifier(1888, 1887, "lateFeeTimeInterval");
insert Expression(1889, 1886, "0");
insert NumberLiteral(1890, 1889, "0");
insert Statement(1891, 1876, "{\n                totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval);\n            }");
insert BlockStatement(1892, 1891, "{\n                totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval);\n            }");
insert Statement(1893, 1892, "totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval);");
insert ExpressionStatement(1894, 1893, "totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval);");
insert Expression(1895, 1894, "totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval)");
insert AssignmentExpression(1896, 1895, "totalLateFee =\n                    lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval)");
insert Expression(1897, 1896, "totalLateFee");
insert Identifier(1898, 1897, "totalLateFee");
insert Expression(1899, 1896, "lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval)");
insert BinaryExpression(1900, 1899, "lateFee *\n                    (timeAfterDeadline / lateFeeTimeInterval)");
insert Expression(1901, 1900, "lateFee");
insert Identifier(1902, 1901, "lateFee");
insert Expression(1903, 1900, "(timeAfterDeadline / lateFeeTimeInterval)");
insert ParenthesizedExpression(1904, 1903, "(timeAfterDeadline / lateFeeTimeInterval)");
insert Expression(1905, 1904, "timeAfterDeadline / lateFeeTimeInterval");
insert BinaryExpression(1906, 1905, "timeAfterDeadline / lateFeeTimeInterval");
insert Expression(1907, 1906, "timeAfterDeadline");
insert Identifier(1908, 1907, "timeAfterDeadline");
insert Expression(1909, 1906, "lateFeeTimeInterval");
insert Identifier(1910, 1909, "lateFeeTimeInterval");
insert Statement(1911, 1876, "{\n                totalLateFee = 0;\n            }");
insert BlockStatement(1912, 1911, "{\n                totalLateFee = 0;\n            }");
insert Statement(1913, 1912, "totalLateFee = 0;");
insert ExpressionStatement(1914, 1913, "totalLateFee = 0;");
insert Expression(1915, 1914, "totalLateFee = 0");
insert AssignmentExpression(1916, 1915, "totalLateFee = 0");
insert Expression(1917, 1916, "totalLateFee");
insert Identifier(1918, 1917, "totalLateFee");
insert Expression(1919, 1916, "0");
insert NumberLiteral(1920, 1919, "0");
insert Statement(1921, 1786, "return total + totalLateFee;");
insert ReturnStatement(1922, 1921, "return total + totalLateFee;");
insert Expression(1923, 1922, "total + totalLateFee");
insert BinaryExpression(1924, 1923, "total + totalLateFee");
insert Expression(1925, 1924, "total");
insert Identifier(1926, 1925, "total");
insert Expression(1927, 1924, "totalLateFee");
insert Identifier(1928, 1927, "totalLateFee");
insert Comment(1929, 1565, "/**\n     * @notice Deposits tokens into the contract.\n     * @param _token The address of the token to deposit\n     * @param _amount The amount of tokens to deposit\n     */");
insert FunctionDefinition(1930, 1565, "function depositTokens(\n        address _token,\n        uint256 _amount\n    ) external override nonReentrant {\n        if (_token != token) revert TokenMismatch();\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        _deposit(_amount);\n    }");
insert Identifier(1931, 1930, "depositTokens");
insert Parameter(1932, 1930, "address _token");
insert TypeName(1933, 1932, "address");
insert PrimitiveType(1934, 1933, "address");
insert Identifier(1935, 1932, "_token");
insert Parameter(1936, 1930, "uint256 _amount");
insert TypeName(1937, 1936, "uint256");
insert PrimitiveType(1938, 1937, "uint256");
insert Identifier(1939, 1936, "_amount");
insert Visibility(1940, 1930, "external");
insert OverrideSpecifier(1941, 1930, "override");
insert ModifierInvocation(1942, 1930, "nonReentrant");
insert Identifier(1943, 1942, "nonReentrant");
insert FunctionBody(1944, 1930, "{\n        if (_token != token) revert TokenMismatch();\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        _deposit(_amount);\n    }");
insert Statement(1945, 1944, "if (_token != token) revert TokenMismatch();");
insert IfStatement(1946, 1945, "if (_token != token) revert TokenMismatch();");
insert Expression(1947, 1946, "_token != token");
insert BinaryExpression(1948, 1947, "_token != token");
insert Expression(1949, 1948, "_token");
insert Identifier(1950, 1949, "_token");
insert Expression(1951, 1948, "token");
insert Identifier(1952, 1951, "token");
insert Statement(1953, 1946, "revert TokenMismatch();");
insert RevertStatement(1954, 1953, "revert TokenMismatch();");
insert Expression(1955, 1954, "TokenMismatch");
insert Identifier(1956, 1955, "TokenMismatch");
insert RevertArguments(1957, 1954, "()");
insert Statement(1958, 1944, "IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);");
insert ExpressionStatement(1959, 1958, "IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);");
insert Expression(1960, 1959, "IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount)");
insert CallExpression(1961, 1960, "IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount)");
insert Expression(1962, 1961, "IERC20(_token).safeTransferFrom");
insert MemberExpression(1963, 1962, "IERC20(_token).safeTransferFrom");
insert Expression(1964, 1963, "IERC20(_token)");
insert CallExpression(1965, 1964, "IERC20(_token)");
insert Expression(1966, 1965, "IERC20");
insert Identifier(1967, 1966, "IERC20");
insert CallArgument(1968, 1965, "_token");
insert Expression(1969, 1968, "_token");
insert Identifier(1970, 1969, "_token");
insert Identifier(1971, 1963, "safeTransferFrom");
insert CallArgument(1972, 1961, "msg.sender");
insert Expression(1973, 1972, "msg.sender");
insert MemberExpression(1974, 1973, "msg.sender");
insert Identifier(1975, 1974, "msg");
insert Identifier(1976, 1974, "sender");
insert CallArgument(1977, 1961, "address(this)");
insert Expression(1978, 1977, "address(this)");
insert TypeCastExpression(1979, 1978, "address(this)");
insert PrimitiveType(1980, 1979, "address");
insert CallArgument(1981, 1979, "this");
insert Expression(1982, 1981, "this");
insert Identifier(1983, 1982, "this");
insert CallArgument(1984, 1961, "_amount");
insert Expression(1985, 1984, "_amount");
insert Identifier(1986, 1985, "_amount");
insert Statement(1987, 1944, "_deposit(_amount);");
insert ExpressionStatement(1988, 1987, "_deposit(_amount);");
insert Expression(1989, 1988, "_deposit(_amount)");
insert CallExpression(1990, 1989, "_deposit(_amount)");
insert Expression(1991, 1990, "_deposit");
insert Identifier(1992, 1991, "_deposit");
insert CallArgument(1993, 1990, "_amount");
insert Expression(1994, 1993, "_amount");
insert Identifier(1995, 1994, "_amount");
insert Comment(1996, 1565, "/**\n     * @notice Withdraws the balance of the invoice token to the provider.\n     */");
insert FunctionDefinition(1997, 1565, "function withdraw() external override nonReentrant {\n        return _withdraw();\n    }");
insert Identifier(1998, 1997, "withdraw");
insert Visibility(1999, 1997, "external");
insert OverrideSpecifier(2000, 1997, "override");
insert ModifierInvocation(2001, 1997, "nonReentrant");
insert Identifier(2002, 2001, "nonReentrant");
insert FunctionBody(2003, 1997, "{\n        return _withdraw();\n    }");
insert Statement(2004, 2003, "return _withdraw();");
insert ReturnStatement(2005, 2004, "return _withdraw();");
insert Expression(2006, 2005, "_withdraw()");
insert CallExpression(2007, 2006, "_withdraw()");
insert Expression(2008, 2007, "_withdraw");
insert Identifier(2009, 2008, "_withdraw");
insert Comment(2010, 1565, "/**\n     * @notice Withdraws tokens that are not the invoice token.\n     * @param _token The address of the token to withdraw\n     */");
insert FunctionDefinition(2011, 1565, "function withdrawTokens(address _token) external override nonReentrant {\n        if (_token == token) {\n            _withdraw();\n        } else {\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n            IERC20(_token).safeTransfer(provider, balance);\n        }\n    }");
insert Identifier(2012, 2011, "withdrawTokens");
insert Parameter(2013, 2011, "address _token");
insert TypeName(2014, 2013, "address");
insert PrimitiveType(2015, 2014, "address");
insert Identifier(2016, 2013, "_token");
insert Visibility(2017, 2011, "external");
insert OverrideSpecifier(2018, 2011, "override");
insert ModifierInvocation(2019, 2011, "nonReentrant");
insert Identifier(2020, 2019, "nonReentrant");
insert FunctionBody(2021, 2011, "{\n        if (_token == token) {\n            _withdraw();\n        } else {\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n            IERC20(_token).safeTransfer(provider, balance);\n        }\n    }");
insert Statement(2022, 2021, "if (_token == token) {\n            _withdraw();\n        } else {\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n            IERC20(_token).safeTransfer(provider, balance);\n        }");
insert IfStatement(2023, 2022, "if (_token == token) {\n            _withdraw();\n        } else {\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n            IERC20(_token).safeTransfer(provider, balance);\n        }");
insert Expression(2024, 2023, "_token == token");
insert BinaryExpression(2025, 2024, "_token == token");
insert Expression(2026, 2025, "_token");
insert Identifier(2027, 2026, "_token");
insert Expression(2028, 2025, "token");
insert Identifier(2029, 2028, "token");
insert Statement(2030, 2023, "{\n            _withdraw();\n        }");
insert BlockStatement(2031, 2030, "{\n            _withdraw();\n        }");
insert Statement(2032, 2031, "_withdraw();");
insert ExpressionStatement(2033, 2032, "_withdraw();");
insert Expression(2034, 2033, "_withdraw()");
insert CallExpression(2035, 2034, "_withdraw()");
insert Expression(2036, 2035, "_withdraw");
insert Identifier(2037, 2036, "_withdraw");
insert Statement(2038, 2023, "{\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n            IERC20(_token).safeTransfer(provider, balance);\n        }");
insert BlockStatement(2039, 2038, "{\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n            IERC20(_token).safeTransfer(provider, balance);\n        }");
insert Statement(2040, 2039, "uint256 balance = IERC20(_token).balanceOf(address(this));");
insert VariableDeclarationStatement(2041, 2040, "uint256 balance = IERC20(_token).balanceOf(address(this));");
insert VariableDeclaration(2042, 2041, "uint256 balance");
insert TypeName(2043, 2042, "uint256");
insert PrimitiveType(2044, 2043, "uint256");
insert Identifier(2045, 2042, "balance");
insert Expression(2046, 2041, "IERC20(_token).balanceOf(address(this))");
insert CallExpression(2047, 2046, "IERC20(_token).balanceOf(address(this))");
insert Expression(2048, 2047, "IERC20(_token).balanceOf");
insert MemberExpression(2049, 2048, "IERC20(_token).balanceOf");
insert Expression(2050, 2049, "IERC20(_token)");
insert CallExpression(2051, 2050, "IERC20(_token)");
insert Expression(2052, 2051, "IERC20");
insert Identifier(2053, 2052, "IERC20");
insert CallArgument(2054, 2051, "_token");
insert Expression(2055, 2054, "_token");
insert Identifier(2056, 2055, "_token");
insert Identifier(2057, 2049, "balanceOf");
insert CallArgument(2058, 2047, "address(this)");
insert Expression(2059, 2058, "address(this)");
insert TypeCastExpression(2060, 2059, "address(this)");
insert PrimitiveType(2061, 2060, "address");
insert CallArgument(2062, 2060, "this");
insert Expression(2063, 2062, "this");
insert Identifier(2064, 2063, "this");
insert Statement(2065, 2039, "if (balance == 0) revert BalanceIsZero();");
insert IfStatement(2066, 2065, "if (balance == 0) revert BalanceIsZero();");
insert Expression(2067, 2066, "balance == 0");
insert BinaryExpression(2068, 2067, "balance == 0");
insert Expression(2069, 2068, "balance");
insert Identifier(2070, 2069, "balance");
insert Expression(2071, 2068, "0");
insert NumberLiteral(2072, 2071, "0");
insert Statement(2073, 2066, "revert BalanceIsZero();");
insert RevertStatement(2074, 2073, "revert BalanceIsZero();");
insert Expression(2075, 2074, "BalanceIsZero");
insert Identifier(2076, 2075, "BalanceIsZero");
insert RevertArguments(2077, 2074, "()");
insert Statement(2078, 2039, "IERC20(_token).safeTransfer(provider, balance);");
insert ExpressionStatement(2079, 2078, "IERC20(_token).safeTransfer(provider, balance);");
insert Expression(2080, 2079, "IERC20(_token).safeTransfer(provider, balance)");
insert CallExpression(2081, 2080, "IERC20(_token).safeTransfer(provider, balance)");
insert Expression(2082, 2081, "IERC20(_token).safeTransfer");
insert MemberExpression(2083, 2082, "IERC20(_token).safeTransfer");
insert Expression(2084, 2083, "IERC20(_token)");
insert CallExpression(2085, 2084, "IERC20(_token)");
insert Expression(2086, 2085, "IERC20");
insert Identifier(2087, 2086, "IERC20");
insert CallArgument(2088, 2085, "_token");
insert Expression(2089, 2088, "_token");
insert Identifier(2090, 2089, "_token");
insert Identifier(2091, 2083, "safeTransfer");
insert CallArgument(2092, 2081, "provider");
insert Expression(2093, 2092, "provider");
insert Identifier(2094, 2093, "provider");
insert CallArgument(2095, 2081, "balance");
insert Expression(2096, 2095, "balance");
insert Identifier(2097, 2096, "balance");
insert Comment(2098, 1565, "/**\n     * @notice Tips the provider with additional tokens.\n     * @param _token The address of the token to tip\n     * @param _amount The amount of tokens to tip\n     */");
insert FunctionDefinition(2099, 1565, "function tip(\n        address _token,\n        uint256 _amount\n    ) external override nonReentrant {\n        if (!fulfilled) revert AlreadyFulfilled();\n        if (_token != token) revert TokenMismatch();\n        totalFulfilled += _amount;\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        emit Tip(_msgSender(), _amount);\n    }");
insert Identifier(2100, 2099, "tip");
insert Parameter(2101, 2099, "address _token");
insert TypeName(2102, 2101, "address");
insert PrimitiveType(2103, 2102, "address");
insert Identifier(2104, 2101, "_token");
insert Parameter(2105, 2099, "uint256 _amount");
insert TypeName(2106, 2105, "uint256");
insert PrimitiveType(2107, 2106, "uint256");
insert Identifier(2108, 2105, "_amount");
insert Visibility(2109, 2099, "external");
insert OverrideSpecifier(2110, 2099, "override");
insert ModifierInvocation(2111, 2099, "nonReentrant");
insert Identifier(2112, 2111, "nonReentrant");
insert FunctionBody(2113, 2099, "{\n        if (!fulfilled) revert AlreadyFulfilled();\n        if (_token != token) revert TokenMismatch();\n        totalFulfilled += _amount;\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        emit Tip(_msgSender(), _amount);\n    }");
insert Statement(2114, 2113, "if (!fulfilled) revert AlreadyFulfilled();");
insert IfStatement(2115, 2114, "if (!fulfilled) revert AlreadyFulfilled();");
insert Expression(2116, 2115, "!fulfilled");
insert UnaryExpression(2117, 2116, "!fulfilled");
insert Expression(2118, 2117, "fulfilled");
insert Identifier(2119, 2118, "fulfilled");
insert Statement(2120, 2115, "revert AlreadyFulfilled();");
insert RevertStatement(2121, 2120, "revert AlreadyFulfilled();");
insert Expression(2122, 2121, "AlreadyFulfilled");
insert Identifier(2123, 2122, "AlreadyFulfilled");
insert RevertArguments(2124, 2121, "()");
insert Statement(2125, 2113, "if (_token != token) revert TokenMismatch();");
insert IfStatement(2126, 2125, "if (_token != token) revert TokenMismatch();");
insert Expression(2127, 2126, "_token != token");
insert BinaryExpression(2128, 2127, "_token != token");
insert Expression(2129, 2128, "_token");
insert Identifier(2130, 2129, "_token");
insert Expression(2131, 2128, "token");
insert Identifier(2132, 2131, "token");
insert Statement(2133, 2126, "revert TokenMismatch();");
insert RevertStatement(2134, 2133, "revert TokenMismatch();");
insert Expression(2135, 2134, "TokenMismatch");
insert Identifier(2136, 2135, "TokenMismatch");
insert RevertArguments(2137, 2134, "()");
insert Statement(2138, 2113, "totalFulfilled += _amount;");
insert ExpressionStatement(2139, 2138, "totalFulfilled += _amount;");
insert Expression(2140, 2139, "totalFulfilled += _amount");
insert AugmentedAssignmentExpression(2141, 2140, "totalFulfilled += _amount");
insert Expression(2142, 2141, "totalFulfilled");
insert Identifier(2143, 2142, "totalFulfilled");
insert Expression(2144, 2141, "_amount");
insert Identifier(2145, 2144, "_amount");
insert Statement(2146, 2113, "IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);");
insert ExpressionStatement(2147, 2146, "IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);");
insert Expression(2148, 2147, "IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount)");
insert CallExpression(2149, 2148, "IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount)");
insert Expression(2150, 2149, "IERC20(_token).safeTransferFrom");
insert MemberExpression(2151, 2150, "IERC20(_token).safeTransferFrom");
insert Expression(2152, 2151, "IERC20(_token)");
insert CallExpression(2153, 2152, "IERC20(_token)");
insert Expression(2154, 2153, "IERC20");
insert Identifier(2155, 2154, "IERC20");
insert CallArgument(2156, 2153, "_token");
insert Expression(2157, 2156, "_token");
insert Identifier(2158, 2157, "_token");
insert Identifier(2159, 2151, "safeTransferFrom");
insert CallArgument(2160, 2149, "msg.sender");
insert Expression(2161, 2160, "msg.sender");
insert MemberExpression(2162, 2161, "msg.sender");
insert Identifier(2163, 2162, "msg");
insert Identifier(2164, 2162, "sender");
insert CallArgument(2165, 2149, "address(this)");
insert Expression(2166, 2165, "address(this)");
insert TypeCastExpression(2167, 2166, "address(this)");
insert PrimitiveType(2168, 2167, "address");
insert CallArgument(2169, 2167, "this");
insert Expression(2170, 2169, "this");
insert Identifier(2171, 2170, "this");
insert CallArgument(2172, 2149, "_amount");
insert Expression(2173, 2172, "_amount");
insert Identifier(2174, 2173, "_amount");
insert Statement(2175, 2113, "emit Tip(_msgSender(), _amount);");
insert EmitStatement(2176, 2175, "emit Tip(_msgSender(), _amount);");
insert Expression(2177, 2176, "Tip");
insert Identifier(2178, 2177, "Tip");
insert CallArgument(2179, 2176, "_msgSender()");
insert Expression(2180, 2179, "_msgSender()");
insert CallExpression(2181, 2180, "_msgSender()");
insert Expression(2182, 2181, "_msgSender");
insert Identifier(2183, 2182, "_msgSender");
insert CallArgument(2184, 2176, "_amount");
insert Expression(2185, 2184, "_amount");
insert Identifier(2186, 2185, "_amount");
insert Comment(2187, 1565, "/**\n     * @dev Internal function to handle deposits.\n     * @param _amount The amount to deposit\n     */");
insert FunctionDefinition(2188, 1565, "function _deposit(uint256 _amount) internal {\n        uint256 totalDue = getTotalDue();\n        totalFulfilled += _amount;\n        if (totalFulfilled >= totalDue) {\n            fulfilled = true;\n            fulfillTime = block.timestamp;\n            emit Fulfilled(_msgSender());\n            if (totalFulfilled > totalDue) {\n                emit Tip(_msgSender(), totalFulfilled - totalDue);\n            }\n        }\n        emit Deposit(_msgSender(), _amount);\n    }");
insert Identifier(2189, 2188, "_deposit");
insert Parameter(2190, 2188, "uint256 _amount");
insert TypeName(2191, 2190, "uint256");
insert PrimitiveType(2192, 2191, "uint256");
insert Identifier(2193, 2190, "_amount");
insert Visibility(2194, 2188, "internal");
insert FunctionBody(2195, 2188, "{\n        uint256 totalDue = getTotalDue();\n        totalFulfilled += _amount;\n        if (totalFulfilled >= totalDue) {\n            fulfilled = true;\n            fulfillTime = block.timestamp;\n            emit Fulfilled(_msgSender());\n            if (totalFulfilled > totalDue) {\n                emit Tip(_msgSender(), totalFulfilled - totalDue);\n            }\n        }\n        emit Deposit(_msgSender(), _amount);\n    }");
insert Statement(2196, 2195, "uint256 totalDue = getTotalDue();");
insert VariableDeclarationStatement(2197, 2196, "uint256 totalDue = getTotalDue();");
insert VariableDeclaration(2198, 2197, "uint256 totalDue");
insert TypeName(2199, 2198, "uint256");
insert PrimitiveType(2200, 2199, "uint256");
insert Identifier(2201, 2198, "totalDue");
insert Expression(2202, 2197, "getTotalDue()");
insert CallExpression(2203, 2202, "getTotalDue()");
insert Expression(2204, 2203, "getTotalDue");
insert Identifier(2205, 2204, "getTotalDue");
insert Statement(2206, 2195, "totalFulfilled += _amount;");
insert ExpressionStatement(2207, 2206, "totalFulfilled += _amount;");
insert Expression(2208, 2207, "totalFulfilled += _amount");
insert AugmentedAssignmentExpression(2209, 2208, "totalFulfilled += _amount");
insert Expression(2210, 2209, "totalFulfilled");
insert Identifier(2211, 2210, "totalFulfilled");
insert Expression(2212, 2209, "_amount");
insert Identifier(2213, 2212, "_amount");
insert Statement(2214, 2195, "if (totalFulfilled >= totalDue) {\n            fulfilled = true;\n            fulfillTime = block.timestamp;\n            emit Fulfilled(_msgSender());\n            if (totalFulfilled > totalDue) {\n                emit Tip(_msgSender(), totalFulfilled - totalDue);\n            }\n        }");
insert IfStatement(2215, 2214, "if (totalFulfilled >= totalDue) {\n            fulfilled = true;\n            fulfillTime = block.timestamp;\n            emit Fulfilled(_msgSender());\n            if (totalFulfilled > totalDue) {\n                emit Tip(_msgSender(), totalFulfilled - totalDue);\n            }\n        }");
insert Expression(2216, 2215, "totalFulfilled >= totalDue");
insert BinaryExpression(2217, 2216, "totalFulfilled >= totalDue");
insert Expression(2218, 2217, "totalFulfilled");
insert Identifier(2219, 2218, "totalFulfilled");
insert Expression(2220, 2217, "totalDue");
insert Identifier(2221, 2220, "totalDue");
insert Statement(2222, 2215, "{\n            fulfilled = true;\n            fulfillTime = block.timestamp;\n            emit Fulfilled(_msgSender());\n            if (totalFulfilled > totalDue) {\n                emit Tip(_msgSender(), totalFulfilled - totalDue);\n            }\n        }");
insert BlockStatement(2223, 2222, "{\n            fulfilled = true;\n            fulfillTime = block.timestamp;\n            emit Fulfilled(_msgSender());\n            if (totalFulfilled > totalDue) {\n                emit Tip(_msgSender(), totalFulfilled - totalDue);\n            }\n        }");
insert Statement(2224, 2223, "fulfilled = true;");
insert ExpressionStatement(2225, 2224, "fulfilled = true;");
insert Expression(2226, 2225, "fulfilled = true");
insert AssignmentExpression(2227, 2226, "fulfilled = true");
insert Expression(2228, 2227, "fulfilled");
insert Identifier(2229, 2228, "fulfilled");
insert Expression(2230, 2227, "true");
insert BooleanLiteral(2231, 2230, "true");
insert True(2232, 2231, "true");
insert Statement(2233, 2223, "fulfillTime = block.timestamp;");
insert ExpressionStatement(2234, 2233, "fulfillTime = block.timestamp;");
insert Expression(2235, 2234, "fulfillTime = block.timestamp");
insert AssignmentExpression(2236, 2235, "fulfillTime = block.timestamp");
insert Expression(2237, 2236, "fulfillTime");
insert Identifier(2238, 2237, "fulfillTime");
insert Expression(2239, 2236, "block.timestamp");
insert MemberExpression(2240, 2239, "block.timestamp");
insert Identifier(2241, 2240, "block");
insert Identifier(2242, 2240, "timestamp");
insert Statement(2243, 2223, "emit Fulfilled(_msgSender());");
insert EmitStatement(2244, 2243, "emit Fulfilled(_msgSender());");
insert Expression(2245, 2244, "Fulfilled");
insert Identifier(2246, 2245, "Fulfilled");
insert CallArgument(2247, 2244, "_msgSender()");
insert Expression(2248, 2247, "_msgSender()");
insert CallExpression(2249, 2248, "_msgSender()");
insert Expression(2250, 2249, "_msgSender");
insert Identifier(2251, 2250, "_msgSender");
insert Statement(2252, 2223, "if (totalFulfilled > totalDue) {\n                emit Tip(_msgSender(), totalFulfilled - totalDue);\n            }");
insert IfStatement(2253, 2252, "if (totalFulfilled > totalDue) {\n                emit Tip(_msgSender(), totalFulfilled - totalDue);\n            }");
insert Expression(2254, 2253, "totalFulfilled > totalDue");
insert BinaryExpression(2255, 2254, "totalFulfilled > totalDue");
insert Expression(2256, 2255, "totalFulfilled");
insert Identifier(2257, 2256, "totalFulfilled");
insert Expression(2258, 2255, "totalDue");
insert Identifier(2259, 2258, "totalDue");
insert Statement(2260, 2253, "{\n                emit Tip(_msgSender(), totalFulfilled - totalDue);\n            }");
insert BlockStatement(2261, 2260, "{\n                emit Tip(_msgSender(), totalFulfilled - totalDue);\n            }");
insert Statement(2262, 2261, "emit Tip(_msgSender(), totalFulfilled - totalDue);");
insert EmitStatement(2263, 2262, "emit Tip(_msgSender(), totalFulfilled - totalDue);");
insert Expression(2264, 2263, "Tip");
insert Identifier(2265, 2264, "Tip");
insert CallArgument(2266, 2263, "_msgSender()");
insert Expression(2267, 2266, "_msgSender()");
insert CallExpression(2268, 2267, "_msgSender()");
insert Expression(2269, 2268, "_msgSender");
insert Identifier(2270, 2269, "_msgSender");
insert CallArgument(2271, 2263, "totalFulfilled - totalDue");
insert Expression(2272, 2271, "totalFulfilled - totalDue");
insert BinaryExpression(2273, 2272, "totalFulfilled - totalDue");
insert Expression(2274, 2273, "totalFulfilled");
insert Identifier(2275, 2274, "totalFulfilled");
insert Expression(2276, 2273, "totalDue");
insert Identifier(2277, 2276, "totalDue");
insert Statement(2278, 2195, "emit Deposit(_msgSender(), _amount);");
insert EmitStatement(2279, 2278, "emit Deposit(_msgSender(), _amount);");
insert Expression(2280, 2279, "Deposit");
insert Identifier(2281, 2280, "Deposit");
insert CallArgument(2282, 2279, "_msgSender()");
insert Expression(2283, 2282, "_msgSender()");
insert CallExpression(2284, 2283, "_msgSender()");
insert Expression(2285, 2284, "_msgSender");
insert Identifier(2286, 2285, "_msgSender");
insert CallArgument(2287, 2279, "_amount");
insert Expression(2288, 2287, "_amount");
insert Identifier(2289, 2288, "_amount");
insert Comment(2290, 1565, "/**\n     * @dev Internal function to handle withdrawals.\n     */");
insert FunctionDefinition(2291, 1565, "function _withdraw() internal {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n        IERC20(token).safeTransfer(provider, balance);\n        emit Withdraw(balance);\n    }");
insert Identifier(2292, 2291, "_withdraw");
insert Visibility(2293, 2291, "internal");
insert FunctionBody(2294, 2291, "{\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n        IERC20(token).safeTransfer(provider, balance);\n        emit Withdraw(balance);\n    }");
insert Statement(2295, 2294, "uint256 balance = IERC20(token).balanceOf(address(this));");
insert VariableDeclarationStatement(2296, 2295, "uint256 balance = IERC20(token).balanceOf(address(this));");
insert VariableDeclaration(2297, 2296, "uint256 balance");
insert TypeName(2298, 2297, "uint256");
insert PrimitiveType(2299, 2298, "uint256");
insert Identifier(2300, 2297, "balance");
insert Expression(2301, 2296, "IERC20(token).balanceOf(address(this))");
insert CallExpression(2302, 2301, "IERC20(token).balanceOf(address(this))");
insert Expression(2303, 2302, "IERC20(token).balanceOf");
insert MemberExpression(2304, 2303, "IERC20(token).balanceOf");
insert Expression(2305, 2304, "IERC20(token)");
insert CallExpression(2306, 2305, "IERC20(token)");
insert Expression(2307, 2306, "IERC20");
insert Identifier(2308, 2307, "IERC20");
insert CallArgument(2309, 2306, "token");
insert Expression(2310, 2309, "token");
insert Identifier(2311, 2310, "token");
insert Identifier(2312, 2304, "balanceOf");
insert CallArgument(2313, 2302, "address(this)");
insert Expression(2314, 2313, "address(this)");
insert TypeCastExpression(2315, 2314, "address(this)");
insert PrimitiveType(2316, 2315, "address");
insert CallArgument(2317, 2315, "this");
insert Expression(2318, 2317, "this");
insert Identifier(2319, 2318, "this");
insert Statement(2320, 2294, "if (balance == 0) revert BalanceIsZero();");
insert IfStatement(2321, 2320, "if (balance == 0) revert BalanceIsZero();");
insert Expression(2322, 2321, "balance == 0");
insert BinaryExpression(2323, 2322, "balance == 0");
insert Expression(2324, 2323, "balance");
insert Identifier(2325, 2324, "balance");
insert Expression(2326, 2323, "0");
insert NumberLiteral(2327, 2326, "0");
insert Statement(2328, 2321, "revert BalanceIsZero();");
insert RevertStatement(2329, 2328, "revert BalanceIsZero();");
insert Expression(2330, 2329, "BalanceIsZero");
insert Identifier(2331, 2330, "BalanceIsZero");
insert RevertArguments(2332, 2329, "()");
insert Statement(2333, 2294, "IERC20(token).safeTransfer(provider, balance);");
insert ExpressionStatement(2334, 2333, "IERC20(token).safeTransfer(provider, balance);");
insert Expression(2335, 2334, "IERC20(token).safeTransfer(provider, balance)");
insert CallExpression(2336, 2335, "IERC20(token).safeTransfer(provider, balance)");
insert Expression(2337, 2336, "IERC20(token).safeTransfer");
insert MemberExpression(2338, 2337, "IERC20(token).safeTransfer");
insert Expression(2339, 2338, "IERC20(token)");
insert CallExpression(2340, 2339, "IERC20(token)");
insert Expression(2341, 2340, "IERC20");
insert Identifier(2342, 2341, "IERC20");
insert CallArgument(2343, 2340, "token");
insert Expression(2344, 2343, "token");
insert Identifier(2345, 2344, "token");
insert Identifier(2346, 2338, "safeTransfer");
insert CallArgument(2347, 2336, "provider");
insert Expression(2348, 2347, "provider");
insert Identifier(2349, 2348, "provider");
insert CallArgument(2350, 2336, "balance");
insert Expression(2351, 2350, "balance");
insert Identifier(2352, 2351, "balance");
insert Statement(2353, 2294, "emit Withdraw(balance);");
insert EmitStatement(2354, 2353, "emit Withdraw(balance);");
insert Expression(2355, 2354, "Withdraw");
insert Identifier(2356, 2355, "Withdraw");
insert CallArgument(2357, 2354, "balance");
insert Expression(2358, 2357, "balance");
insert Identifier(2359, 2358, "balance");
insert Comment(2360, 1565, "/**\n     * @dev Internal function to handle initialization data.\n     * @param _data The data to be handled and decoded\n     */");
insert FunctionDefinition(2361, 1565, "function _handleData(bytes calldata _data) internal {\n        (\n            address _client,\n            address _token,\n            uint256 _deadline,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            uint256 _lateFee,\n            uint256 _lateFeeTimeInterval\n        ) = abi.decode(\n                _data,\n                (address, address, uint256, bytes32, address, uint256, uint256)\n            );\n\n        if (_client == address(0)) revert InvalidClient();\n        if (_token == address(0)) revert InvalidToken();\n        if (_deadline <= block.timestamp && _deadline != 0)\n            revert DurationEnded();\n        if (_deadline > block.timestamp + MAX_DEADLINE)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        client = _client;\n        token = _token;\n        deadline = _deadline;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        lateFee = _lateFee;\n        lateFeeTimeInterval = _lateFeeTimeInterval;\n    }");
insert Identifier(2362, 2361, "_handleData");
insert Parameter(2363, 2361, "bytes calldata _data");
insert TypeName(2364, 2363, "bytes");
insert PrimitiveType(2365, 2364, "bytes");
insert Identifier(2366, 2363, "_data");
insert Visibility(2367, 2361, "internal");
insert FunctionBody(2368, 2361, "{\n        (\n            address _client,\n            address _token,\n            uint256 _deadline,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            uint256 _lateFee,\n            uint256 _lateFeeTimeInterval\n        ) = abi.decode(\n                _data,\n                (address, address, uint256, bytes32, address, uint256, uint256)\n            );\n\n        if (_client == address(0)) revert InvalidClient();\n        if (_token == address(0)) revert InvalidToken();\n        if (_deadline <= block.timestamp && _deadline != 0)\n            revert DurationEnded();\n        if (_deadline > block.timestamp + MAX_DEADLINE)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        client = _client;\n        token = _token;\n        deadline = _deadline;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        lateFee = _lateFee;\n        lateFeeTimeInterval = _lateFeeTimeInterval;\n    }");
insert Statement(2369, 2368, "(\n            address _client,\n            address _token,\n            uint256 _deadline,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            uint256 _lateFee,\n            uint256 _lateFeeTimeInterval\n        ) = abi.decode(\n                _data,\n                (address, address, uint256, bytes32, address, uint256, uint256)\n            );");
insert VariableDeclarationStatement(2370, 2369, "(\n            address _client,\n            address _token,\n            uint256 _deadline,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            uint256 _lateFee,\n            uint256 _lateFeeTimeInterval\n        ) = abi.decode(\n                _data,\n                (address, address, uint256, bytes32, address, uint256, uint256)\n            );");
insert VariableDeclarationTuple(2371, 2370, "(\n            address _client,\n            address _token,\n            uint256 _deadline,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            uint256 _lateFee,\n            uint256 _lateFeeTimeInterval\n        )");
insert VariableDeclaration(2372, 2371, "address _client");
insert TypeName(2373, 2372, "address");
insert PrimitiveType(2374, 2373, "address");
insert Identifier(2375, 2372, "_client");
insert VariableDeclaration(2376, 2371, "address _token");
insert TypeName(2377, 2376, "address");
insert PrimitiveType(2378, 2377, "address");
insert Identifier(2379, 2376, "_token");
insert VariableDeclaration(2380, 2371, "uint256 _deadline");
insert TypeName(2381, 2380, "uint256");
insert PrimitiveType(2382, 2381, "uint256");
insert Identifier(2383, 2380, "_deadline");
insert VariableDeclaration(2384, 2371, "bytes32 _details");
insert TypeName(2385, 2384, "bytes32");
insert PrimitiveType(2386, 2385, "bytes32");
insert Identifier(2387, 2384, "_details");
insert VariableDeclaration(2388, 2371, "address _wrappedNativeToken");
insert TypeName(2389, 2388, "address");
insert PrimitiveType(2390, 2389, "address");
insert Identifier(2391, 2388, "_wrappedNativeToken");
insert VariableDeclaration(2392, 2371, "uint256 _lateFee");
insert TypeName(2393, 2392, "uint256");
insert PrimitiveType(2394, 2393, "uint256");
insert Identifier(2395, 2392, "_lateFee");
insert VariableDeclaration(2396, 2371, "uint256 _lateFeeTimeInterval");
insert TypeName(2397, 2396, "uint256");
insert PrimitiveType(2398, 2397, "uint256");
insert Identifier(2399, 2396, "_lateFeeTimeInterval");
insert Expression(2400, 2370, "abi.decode(\n                _data,\n                (address, address, uint256, bytes32, address, uint256, uint256)\n            )");
insert CallExpression(2401, 2400, "abi.decode(\n                _data,\n                (address, address, uint256, bytes32, address, uint256, uint256)\n            )");
insert Expression(2402, 2401, "abi.decode");
insert MemberExpression(2403, 2402, "abi.decode");
insert Identifier(2404, 2403, "abi");
insert Identifier(2405, 2403, "decode");
insert CallArgument(2406, 2401, "_data");
insert Expression(2407, 2406, "_data");
insert Identifier(2408, 2407, "_data");
insert CallArgument(2409, 2401, "(address, address, uint256, bytes32, address, uint256, uint256)");
insert Expression(2410, 2409, "(address, address, uint256, bytes32, address, uint256, uint256)");
insert TupleExpression(2411, 2410, "(address, address, uint256, bytes32, address, uint256, uint256)");
insert Expression(2412, 2411, "address");
insert PrimitiveType(2413, 2412, "address");
insert Expression(2414, 2411, "address");
insert PrimitiveType(2415, 2414, "address");
insert Expression(2416, 2411, "uint256");
insert PrimitiveType(2417, 2416, "uint256");
insert Expression(2418, 2411, "bytes32");
insert PrimitiveType(2419, 2418, "bytes32");
insert Expression(2420, 2411, "address");
insert PrimitiveType(2421, 2420, "address");
insert Expression(2422, 2411, "uint256");
insert PrimitiveType(2423, 2422, "uint256");
insert Expression(2424, 2411, "uint256");
insert PrimitiveType(2425, 2424, "uint256");
insert Statement(2426, 2368, "if (_client == address(0)) revert InvalidClient();");
insert IfStatement(2427, 2426, "if (_client == address(0)) revert InvalidClient();");
insert Expression(2428, 2427, "_client == address(0)");
insert BinaryExpression(2429, 2428, "_client == address(0)");
insert Expression(2430, 2429, "_client");
insert Identifier(2431, 2430, "_client");
insert Expression(2432, 2429, "address(0)");
insert TypeCastExpression(2433, 2432, "address(0)");
insert PrimitiveType(2434, 2433, "address");
insert CallArgument(2435, 2433, "0");
insert Expression(2436, 2435, "0");
insert NumberLiteral(2437, 2436, "0");
insert Statement(2438, 2427, "revert InvalidClient();");
insert RevertStatement(2439, 2438, "revert InvalidClient();");
insert Expression(2440, 2439, "InvalidClient");
insert Identifier(2441, 2440, "InvalidClient");
insert RevertArguments(2442, 2439, "()");
insert Statement(2443, 2368, "if (_token == address(0)) revert InvalidToken();");
insert IfStatement(2444, 2443, "if (_token == address(0)) revert InvalidToken();");
insert Expression(2445, 2444, "_token == address(0)");
insert BinaryExpression(2446, 2445, "_token == address(0)");
insert Expression(2447, 2446, "_token");
insert Identifier(2448, 2447, "_token");
insert Expression(2449, 2446, "address(0)");
insert TypeCastExpression(2450, 2449, "address(0)");
insert PrimitiveType(2451, 2450, "address");
insert CallArgument(2452, 2450, "0");
insert Expression(2453, 2452, "0");
insert NumberLiteral(2454, 2453, "0");
insert Statement(2455, 2444, "revert InvalidToken();");
insert RevertStatement(2456, 2455, "revert InvalidToken();");
insert Expression(2457, 2456, "InvalidToken");
insert Identifier(2458, 2457, "InvalidToken");
insert RevertArguments(2459, 2456, "()");
insert Statement(2460, 2368, "if (_deadline <= block.timestamp && _deadline != 0)\n            revert DurationEnded();");
insert IfStatement(2461, 2460, "if (_deadline <= block.timestamp && _deadline != 0)\n            revert DurationEnded();");
insert Expression(2462, 2461, "_deadline <= block.timestamp && _deadline != 0");
insert BinaryExpression(2463, 2462, "_deadline <= block.timestamp && _deadline != 0");
insert Expression(2464, 2463, "_deadline <= block.timestamp");
insert BinaryExpression(2465, 2464, "_deadline <= block.timestamp");
insert Expression(2466, 2465, "_deadline");
insert Identifier(2467, 2466, "_deadline");
insert Expression(2468, 2465, "block.timestamp");
insert MemberExpression(2469, 2468, "block.timestamp");
insert Identifier(2470, 2469, "block");
insert Identifier(2471, 2469, "timestamp");
insert Expression(2472, 2463, "_deadline != 0");
insert BinaryExpression(2473, 2472, "_deadline != 0");
insert Expression(2474, 2473, "_deadline");
insert Identifier(2475, 2474, "_deadline");
insert Expression(2476, 2473, "0");
insert NumberLiteral(2477, 2476, "0");
insert Statement(2478, 2461, "revert DurationEnded();");
insert RevertStatement(2479, 2478, "revert DurationEnded();");
insert Expression(2480, 2479, "DurationEnded");
insert Identifier(2481, 2480, "DurationEnded");
insert RevertArguments(2482, 2479, "()");
insert Statement(2483, 2368, "if (_deadline > block.timestamp + MAX_DEADLINE)\n            revert DurationTooLong();");
insert IfStatement(2484, 2483, "if (_deadline > block.timestamp + MAX_DEADLINE)\n            revert DurationTooLong();");
insert Expression(2485, 2484, "_deadline > block.timestamp + MAX_DEADLINE");
insert BinaryExpression(2486, 2485, "_deadline > block.timestamp + MAX_DEADLINE");
insert Expression(2487, 2486, "_deadline > block.timestamp");
insert MemberExpression(2488, 2487, "_deadline > block.timestamp");
insert Expression(2489, 2488, "_deadline > block");
insert BinaryExpression(2490, 2489, "_deadline > block");
insert Expression(2491, 2490, "_deadline");
insert Identifier(2492, 2491, "_deadline");
insert Expression(2493, 2490, "block");
insert Identifier(2494, 2493, "block");
insert Identifier(2495, 2488, "timestamp");
insert Expression(2496, 2486, "MAX_DEADLINE");
insert Identifier(2497, 2496, "MAX_DEADLINE");
insert Statement(2498, 2484, "revert DurationTooLong();");
insert RevertStatement(2499, 2498, "revert DurationTooLong();");
insert Expression(2500, 2499, "DurationTooLong");
insert Identifier(2501, 2500, "DurationTooLong");
insert RevertArguments(2502, 2499, "()");
insert Statement(2503, 2368, "if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();");
insert IfStatement(2504, 2503, "if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();");
insert Expression(2505, 2504, "_wrappedNativeToken == address(0)");
insert BinaryExpression(2506, 2505, "_wrappedNativeToken == address(0)");
insert Expression(2507, 2506, "_wrappedNativeToken");
insert Identifier(2508, 2507, "_wrappedNativeToken");
insert Expression(2509, 2506, "address(0)");
insert TypeCastExpression(2510, 2509, "address(0)");
insert PrimitiveType(2511, 2510, "address");
insert CallArgument(2512, 2510, "0");
insert Expression(2513, 2512, "0");
insert NumberLiteral(2514, 2513, "0");
insert Statement(2515, 2504, "revert InvalidWrappedNativeToken();");
insert RevertStatement(2516, 2515, "revert InvalidWrappedNativeToken();");
insert Expression(2517, 2516, "InvalidWrappedNativeToken");
insert Identifier(2518, 2517, "InvalidWrappedNativeToken");
insert RevertArguments(2519, 2516, "()");
insert Statement(2520, 2368, "client = _client;");
insert ExpressionStatement(2521, 2520, "client = _client;");
insert Expression(2522, 2521, "client = _client");
insert AssignmentExpression(2523, 2522, "client = _client");
insert Expression(2524, 2523, "client");
insert Identifier(2525, 2524, "client");
insert Expression(2526, 2523, "_client");
insert Identifier(2527, 2526, "_client");
insert Statement(2528, 2368, "token = _token;");
insert ExpressionStatement(2529, 2528, "token = _token;");
insert Expression(2530, 2529, "token = _token");
insert AssignmentExpression(2531, 2530, "token = _token");
insert Expression(2532, 2531, "token");
insert Identifier(2533, 2532, "token");
insert Expression(2534, 2531, "_token");
insert Identifier(2535, 2534, "_token");
insert Statement(2536, 2368, "deadline = _deadline;");
insert ExpressionStatement(2537, 2536, "deadline = _deadline;");
insert Expression(2538, 2537, "deadline = _deadline");
insert AssignmentExpression(2539, 2538, "deadline = _deadline");
insert Expression(2540, 2539, "deadline");
insert Identifier(2541, 2540, "deadline");
insert Expression(2542, 2539, "_deadline");
insert Identifier(2543, 2542, "_deadline");
insert Statement(2544, 2368, "details = _details;");
insert ExpressionStatement(2545, 2544, "details = _details;");
insert Expression(2546, 2545, "details = _details");
insert AssignmentExpression(2547, 2546, "details = _details");
insert Expression(2548, 2547, "details");
insert Identifier(2549, 2548, "details");
insert Expression(2550, 2547, "_details");
insert Identifier(2551, 2550, "_details");
insert Statement(2552, 2368, "wrappedNativeToken = _wrappedNativeToken;");
insert ExpressionStatement(2553, 2552, "wrappedNativeToken = _wrappedNativeToken;");
insert Expression(2554, 2553, "wrappedNativeToken = _wrappedNativeToken");
insert AssignmentExpression(2555, 2554, "wrappedNativeToken = _wrappedNativeToken");
insert Expression(2556, 2555, "wrappedNativeToken");
insert Identifier(2557, 2556, "wrappedNativeToken");
insert Expression(2558, 2555, "_wrappedNativeToken");
insert Identifier(2559, 2558, "_wrappedNativeToken");
insert Statement(2560, 2368, "lateFee = _lateFee;");
insert ExpressionStatement(2561, 2560, "lateFee = _lateFee;");
insert Expression(2562, 2561, "lateFee = _lateFee");
insert AssignmentExpression(2563, 2562, "lateFee = _lateFee");
insert Expression(2564, 2563, "lateFee");
insert Identifier(2565, 2564, "lateFee");
insert Expression(2566, 2563, "_lateFee");
insert Identifier(2567, 2566, "_lateFee");
insert Statement(2568, 2368, "lateFeeTimeInterval = _lateFeeTimeInterval;");
insert ExpressionStatement(2569, 2568, "lateFeeTimeInterval = _lateFeeTimeInterval;");
insert Expression(2570, 2569, "lateFeeTimeInterval = _lateFeeTimeInterval");
insert AssignmentExpression(2571, 2570, "lateFeeTimeInterval = _lateFeeTimeInterval");
insert Expression(2572, 2571, "lateFeeTimeInterval");
insert Identifier(2573, 2572, "lateFeeTimeInterval");
insert Expression(2574, 2571, "_lateFeeTimeInterval");
insert Identifier(2575, 2574, "_lateFeeTimeInterval");
insert Comment(2576, 1565, "/**\n     * @notice Fallback function to receive native token transfers.\n     */");
insert FallbackReceiveDefinition(2577, 1565, "receive() external payable {\n        if (token != wrappedNativeToken) revert TokenNotWrappedNativeToken();\n        IWRAPPED(wrappedNativeToken).deposit{value: msg.value}();\n        _deposit(msg.value);\n    }");
insert Visibility(2578, 2577, "external");
insert StateMutability(2579, 2577, "payable");
insert FunctionBody(2580, 2577, "{\n        if (token != wrappedNativeToken) revert TokenNotWrappedNativeToken();\n        IWRAPPED(wrappedNativeToken).deposit{value: msg.value}();\n        _deposit(msg.value);\n    }");
insert Statement(2581, 2580, "if (token != wrappedNativeToken) revert TokenNotWrappedNativeToken();");
insert IfStatement(2582, 2581, "if (token != wrappedNativeToken) revert TokenNotWrappedNativeToken();");
insert Expression(2583, 2582, "token != wrappedNativeToken");
insert BinaryExpression(2584, 2583, "token != wrappedNativeToken");
insert Expression(2585, 2584, "token");
insert Identifier(2586, 2585, "token");
insert Expression(2587, 2584, "wrappedNativeToken");
insert Identifier(2588, 2587, "wrappedNativeToken");
insert Statement(2589, 2582, "revert TokenNotWrappedNativeToken();");
insert RevertStatement(2590, 2589, "revert TokenNotWrappedNativeToken();");
insert Expression(2591, 2590, "TokenNotWrappedNativeToken");
insert Identifier(2592, 2591, "TokenNotWrappedNativeToken");
insert RevertArguments(2593, 2590, "()");
insert Statement(2594, 2580, "IWRAPPED(wrappedNativeToken).deposit{value: msg.value}();");
insert ExpressionStatement(2595, 2594, "IWRAPPED(wrappedNativeToken).deposit{value: msg.value}();");
insert Expression(2596, 2595, "IWRAPPED(wrappedNativeToken).deposit{value: msg.value}()");
insert CallExpression(2597, 2596, "IWRAPPED(wrappedNativeToken).deposit{value: msg.value}()");
insert Expression(2598, 2597, "IWRAPPED(wrappedNativeToken).deposit{value: msg.value}");
insert StructExpression(2599, 2598, "IWRAPPED(wrappedNativeToken).deposit{value: msg.value}");
insert Expression(2600, 2599, "IWRAPPED(wrappedNativeToken).deposit");
insert MemberExpression(2601, 2600, "IWRAPPED(wrappedNativeToken).deposit");
insert Expression(2602, 2601, "IWRAPPED(wrappedNativeToken)");
insert CallExpression(2603, 2602, "IWRAPPED(wrappedNativeToken)");
insert Expression(2604, 2603, "IWRAPPED");
insert Identifier(2605, 2604, "IWRAPPED");
insert CallArgument(2606, 2603, "wrappedNativeToken");
insert Expression(2607, 2606, "wrappedNativeToken");
insert Identifier(2608, 2607, "wrappedNativeToken");
insert Identifier(2609, 2601, "deposit");
insert StructFieldAssignment(2610, 2599, "value: msg.value");
insert Identifier(2611, 2610, "value");
insert Expression(2612, 2610, "msg.value");
insert MemberExpression(2613, 2612, "msg.value");
insert Identifier(2614, 2613, "msg");
insert Identifier(2615, 2613, "value");
insert Statement(2616, 2580, "_deposit(msg.value);");
insert ExpressionStatement(2617, 2616, "_deposit(msg.value);");
insert Expression(2618, 2617, "_deposit(msg.value)");
insert CallExpression(2619, 2618, "_deposit(msg.value)");
insert Expression(2620, 2619, "_deposit");
insert Identifier(2621, 2620, "_deposit");
insert CallArgument(2622, 2619, "msg.value");
insert Expression(2623, 2622, "msg.value");
insert MemberExpression(2624, 2623, "msg.value");
insert Identifier(2625, 2624, "msg");
insert Identifier(2626, 2624, "value");
insert SourceFile(2627, 0, "// SPDX-License-Identifier: MIT\n// solhint-disable not-rely-on-time, max-states-count\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";\nimport {SmartInvoiceEscrow} from \"./SmartInvoiceEscrow.sol\";\n\n/// @title SmartInvoiceSplitEscrow\n/// @notice An extension of the SmartInvoiceEscrow contract that adds DAO fee handling.\ncontract SmartInvoiceSplitEscrow is SmartInvoiceEscrow {\n    using SafeERC20 for IERC20;\n\n    address public dao;\n    uint256 public daoFee;\n\n    /// @dev Error definitions for more efficient gas usage.\n    error InvalidDAO();\n\n    /**\n     * @notice Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded\n     */\n    function _handleData(bytes calldata _data) internal override {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _dao,\n            uint256 _daoFee\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    uint256\n                )\n            );\n\n        if (_daoFee > 0 && _dao == address(0)) revert InvalidDAO();\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20; // Default resolution rate if not specified\n        }\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        dao = _dao;\n        daoFee = _daoFee;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }\n\n    /**\n     * @dev Internal function to transfer payment to the provider and DAO.\n     * @param _token The address of the token to transfer.\n     * @param _amount The amount of tokens to transfer.\n     */\n    function _transferPayment(\n        address _token,\n        uint256 _amount\n    ) internal virtual override {\n        uint256 daoAmount = (_amount * daoFee) / 10000;\n        uint256 providerAmount = _amount - daoAmount;\n\n        IERC20(_token).safeTransfer(dao, daoAmount);\n        IERC20(_token).safeTransfer(provider, providerAmount);\n    }\n}\n");
insert Comment(2628, 2627, "// SPDX-License-Identifier: MIT");
insert Comment(2629, 2627, "// solhint-disable not-rely-on-time, max-states-count");
insert PragmaDirective(2630, 2627, "pragma solidity ^0.8.20;");
insert SolidityPragmaToken(2631, 2630, "solidity ^0.8.20");
insert SolidityVersionComparisonOperator(2632, 2631, " ^");
insert SolidityVersion(2633, 2631, "0.8.20");
insert ImportDirective(2634, 2627, "import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";");
insert Identifier(2635, 2634, "IERC20");
insert ImportDirective(2636, 2627, "import {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";");
insert Identifier(2637, 2636, "SafeERC20");
insert ImportDirective(2638, 2627, "import {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";");
insert Identifier(2639, 2638, "ISmartInvoiceFactory");
insert ImportDirective(2640, 2627, "import {SmartInvoiceEscrow} from \"./SmartInvoiceEscrow.sol\";");
insert Identifier(2641, 2640, "SmartInvoiceEscrow");
insert Comment(2642, 2627, "/// @title SmartInvoiceSplitEscrow");
insert Comment(2643, 2627, "/// @notice An extension of the SmartInvoiceEscrow contract that adds DAO fee handling.");
insert ContractDeclaration(2644, 2627, "contract SmartInvoiceSplitEscrow is SmartInvoiceEscrow {\n    using SafeERC20 for IERC20;\n\n    address public dao;\n    uint256 public daoFee;\n\n    /// @dev Error definitions for more efficient gas usage.\n    error InvalidDAO();\n\n    /**\n     * @notice Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded\n     */\n    function _handleData(bytes calldata _data) internal override {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _dao,\n            uint256 _daoFee\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    uint256\n                )\n            );\n\n        if (_daoFee > 0 && _dao == address(0)) revert InvalidDAO();\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20; // Default resolution rate if not specified\n        }\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        dao = _dao;\n        daoFee = _daoFee;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }\n\n    /**\n     * @dev Internal function to transfer payment to the provider and DAO.\n     * @param _token The address of the token to transfer.\n     * @param _amount The amount of tokens to transfer.\n     */\n    function _transferPayment(\n        address _token,\n        uint256 _amount\n    ) internal virtual override {\n        uint256 daoAmount = (_amount * daoFee) / 10000;\n        uint256 providerAmount = _amount - daoAmount;\n\n        IERC20(_token).safeTransfer(dao, daoAmount);\n        IERC20(_token).safeTransfer(provider, providerAmount);\n    }\n}");
insert Identifier(2645, 2644, "SmartInvoiceSplitEscrow");
insert InheritanceSpecifier(2646, 2644, "SmartInvoiceEscrow");
insert UserDefinedType(2647, 2646, "SmartInvoiceEscrow");
insert Identifier(2648, 2647, "SmartInvoiceEscrow");
insert ContractBody(2649, 2644, "{\n    using SafeERC20 for IERC20;\n\n    address public dao;\n    uint256 public daoFee;\n\n    /// @dev Error definitions for more efficient gas usage.\n    error InvalidDAO();\n\n    /**\n     * @notice Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded\n     */\n    function _handleData(bytes calldata _data) internal override {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _dao,\n            uint256 _daoFee\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    uint256\n                )\n            );\n\n        if (_daoFee > 0 && _dao == address(0)) revert InvalidDAO();\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20; // Default resolution rate if not specified\n        }\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        dao = _dao;\n        daoFee = _daoFee;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }\n\n    /**\n     * @dev Internal function to transfer payment to the provider and DAO.\n     * @param _token The address of the token to transfer.\n     * @param _amount The amount of tokens to transfer.\n     */\n    function _transferPayment(\n        address _token,\n        uint256 _amount\n    ) internal virtual override {\n        uint256 daoAmount = (_amount * daoFee) / 10000;\n        uint256 providerAmount = _amount - daoAmount;\n\n        IERC20(_token).safeTransfer(dao, daoAmount);\n        IERC20(_token).safeTransfer(provider, providerAmount);\n    }\n}");
insert UsingDirective(2650, 2649, "using SafeERC20 for IERC20;");
insert TypeAlias(2651, 2650, "SafeERC20");
insert Identifier(2652, 2651, "SafeERC20");
insert TypeName(2653, 2650, "IERC20");
insert UserDefinedType(2654, 2653, "IERC20");
insert Identifier(2655, 2654, "IERC20");
insert StateVariableDeclaration(2656, 2649, "address public dao;");
insert TypeName(2657, 2656, "address");
insert PrimitiveType(2658, 2657, "address");
insert Visibility(2659, 2656, "public");
insert Identifier(2660, 2656, "dao");
insert StateVariableDeclaration(2661, 2649, "uint256 public daoFee;");
insert TypeName(2662, 2661, "uint256");
insert PrimitiveType(2663, 2662, "uint256");
insert Visibility(2664, 2661, "public");
insert Identifier(2665, 2661, "daoFee");
insert Comment(2666, 2649, "/// @dev Error definitions for more efficient gas usage.");
insert ErrorDeclaration(2667, 2649, "error InvalidDAO();");
insert Identifier(2668, 2667, "InvalidDAO");
insert Comment(2669, 2649, "/**\n     * @notice Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded\n     */");
insert FunctionDefinition(2670, 2649, "function _handleData(bytes calldata _data) internal override {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _dao,\n            uint256 _daoFee\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    uint256\n                )\n            );\n\n        if (_daoFee > 0 && _dao == address(0)) revert InvalidDAO();\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20; // Default resolution rate if not specified\n        }\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        dao = _dao;\n        daoFee = _daoFee;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }");
insert Identifier(2671, 2670, "_handleData");
insert Parameter(2672, 2670, "bytes calldata _data");
insert TypeName(2673, 2672, "bytes");
insert PrimitiveType(2674, 2673, "bytes");
insert Identifier(2675, 2672, "_data");
insert Visibility(2676, 2670, "internal");
insert OverrideSpecifier(2677, 2670, "override");
insert FunctionBody(2678, 2670, "{\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _dao,\n            uint256 _daoFee\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    uint256\n                )\n            );\n\n        if (_daoFee > 0 && _dao == address(0)) revert InvalidDAO();\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20; // Default resolution rate if not specified\n        }\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        dao = _dao;\n        daoFee = _daoFee;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }");
insert Statement(2679, 2678, "(\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _dao,\n            uint256 _daoFee\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    uint256\n                )\n            );");
insert VariableDeclarationStatement(2680, 2679, "(\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _dao,\n            uint256 _daoFee\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    uint256\n                )\n            );");
insert VariableDeclarationTuple(2681, 2680, "(\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _dao,\n            uint256 _daoFee\n        )");
insert VariableDeclaration(2682, 2681, "address _client");
insert TypeName(2683, 2682, "address");
insert PrimitiveType(2684, 2683, "address");
insert Identifier(2685, 2682, "_client");
insert VariableDeclaration(2686, 2681, "uint8 _resolverType");
insert TypeName(2687, 2686, "uint8");
insert PrimitiveType(2688, 2687, "uint8");
insert Identifier(2689, 2686, "_resolverType");
insert VariableDeclaration(2690, 2681, "address _resolver");
insert TypeName(2691, 2690, "address");
insert PrimitiveType(2692, 2691, "address");
insert Identifier(2693, 2690, "_resolver");
insert VariableDeclaration(2694, 2681, "address _token");
insert TypeName(2695, 2694, "address");
insert PrimitiveType(2696, 2695, "address");
insert Identifier(2697, 2694, "_token");
insert VariableDeclaration(2698, 2681, "uint256 _terminationTime");
insert TypeName(2699, 2698, "uint256");
insert PrimitiveType(2700, 2699, "uint256");
insert Identifier(2701, 2698, "_terminationTime");
insert Comment(2702, 2681, "// exact termination date in seconds since epoch");
insert VariableDeclaration(2703, 2681, "bytes32 _details");
insert TypeName(2704, 2703, "bytes32");
insert PrimitiveType(2705, 2704, "bytes32");
insert Identifier(2706, 2703, "_details");
insert VariableDeclaration(2707, 2681, "address _wrappedNativeToken");
insert TypeName(2708, 2707, "address");
insert PrimitiveType(2709, 2708, "address");
insert Identifier(2710, 2707, "_wrappedNativeToken");
insert VariableDeclaration(2711, 2681, "bool _requireVerification");
insert TypeName(2712, 2711, "bool");
insert PrimitiveType(2713, 2712, "bool");
insert Identifier(2714, 2711, "_requireVerification");
insert VariableDeclaration(2715, 2681, "address _factory");
insert TypeName(2716, 2715, "address");
insert PrimitiveType(2717, 2716, "address");
insert Identifier(2718, 2715, "_factory");
insert VariableDeclaration(2719, 2681, "address _dao");
insert TypeName(2720, 2719, "address");
insert PrimitiveType(2721, 2720, "address");
insert Identifier(2722, 2719, "_dao");
insert VariableDeclaration(2723, 2681, "uint256 _daoFee");
insert TypeName(2724, 2723, "uint256");
insert PrimitiveType(2725, 2724, "uint256");
insert Identifier(2726, 2723, "_daoFee");
insert Expression(2727, 2680, "abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    uint256\n                )\n            )");
insert CallExpression(2728, 2727, "abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    uint256\n                )\n            )");
insert Expression(2729, 2728, "abi.decode");
insert MemberExpression(2730, 2729, "abi.decode");
insert Identifier(2731, 2730, "abi");
insert Identifier(2732, 2730, "decode");
insert CallArgument(2733, 2728, "_data");
insert Expression(2734, 2733, "_data");
insert Identifier(2735, 2734, "_data");
insert CallArgument(2736, 2728, "(\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    uint256\n                )");
insert Expression(2737, 2736, "(\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    uint256\n                )");
insert TupleExpression(2738, 2737, "(\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    uint256\n                )");
insert Expression(2739, 2738, "address");
insert PrimitiveType(2740, 2739, "address");
insert Expression(2741, 2738, "uint8");
insert PrimitiveType(2742, 2741, "uint8");
insert Expression(2743, 2738, "address");
insert PrimitiveType(2744, 2743, "address");
insert Expression(2745, 2738, "address");
insert PrimitiveType(2746, 2745, "address");
insert Expression(2747, 2738, "uint256");
insert PrimitiveType(2748, 2747, "uint256");
insert Expression(2749, 2738, "bytes32");
insert PrimitiveType(2750, 2749, "bytes32");
insert Expression(2751, 2738, "address");
insert PrimitiveType(2752, 2751, "address");
insert Expression(2753, 2738, "bool");
insert PrimitiveType(2754, 2753, "bool");
insert Expression(2755, 2738, "address");
insert PrimitiveType(2756, 2755, "address");
insert Expression(2757, 2738, "address");
insert PrimitiveType(2758, 2757, "address");
insert Expression(2759, 2738, "uint256");
insert PrimitiveType(2760, 2759, "uint256");
insert Statement(2761, 2678, "if (_daoFee > 0 && _dao == address(0)) revert InvalidDAO();");
insert IfStatement(2762, 2761, "if (_daoFee > 0 && _dao == address(0)) revert InvalidDAO();");
insert Expression(2763, 2762, "_daoFee > 0 && _dao == address(0)");
insert BinaryExpression(2764, 2763, "_daoFee > 0 && _dao == address(0)");
insert Expression(2765, 2764, "_daoFee > 0");
insert BinaryExpression(2766, 2765, "_daoFee > 0");
insert Expression(2767, 2766, "_daoFee");
insert Identifier(2768, 2767, "_daoFee");
insert Expression(2769, 2766, "0");
insert NumberLiteral(2770, 2769, "0");
insert Expression(2771, 2764, "_dao == address(0)");
insert BinaryExpression(2772, 2771, "_dao == address(0)");
insert Expression(2773, 2772, "_dao");
insert Identifier(2774, 2773, "_dao");
insert Expression(2775, 2772, "address(0)");
insert TypeCastExpression(2776, 2775, "address(0)");
insert PrimitiveType(2777, 2776, "address");
insert CallArgument(2778, 2776, "0");
insert Expression(2779, 2778, "0");
insert NumberLiteral(2780, 2779, "0");
insert Statement(2781, 2762, "revert InvalidDAO();");
insert RevertStatement(2782, 2781, "revert InvalidDAO();");
insert Expression(2783, 2782, "InvalidDAO");
insert Identifier(2784, 2783, "InvalidDAO");
insert RevertArguments(2785, 2782, "()");
insert Statement(2786, 2678, "if (_client == address(0)) revert InvalidClient();");
insert IfStatement(2787, 2786, "if (_client == address(0)) revert InvalidClient();");
insert Expression(2788, 2787, "_client == address(0)");
insert BinaryExpression(2789, 2788, "_client == address(0)");
insert Expression(2790, 2789, "_client");
insert Identifier(2791, 2790, "_client");
insert Expression(2792, 2789, "address(0)");
insert TypeCastExpression(2793, 2792, "address(0)");
insert PrimitiveType(2794, 2793, "address");
insert CallArgument(2795, 2793, "0");
insert Expression(2796, 2795, "0");
insert NumberLiteral(2797, 2796, "0");
insert Statement(2798, 2787, "revert InvalidClient();");
insert RevertStatement(2799, 2798, "revert InvalidClient();");
insert Expression(2800, 2799, "InvalidClient");
insert Identifier(2801, 2800, "InvalidClient");
insert RevertArguments(2802, 2799, "()");
insert Statement(2803, 2678, "if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();");
insert IfStatement(2804, 2803, "if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();");
insert Expression(2805, 2804, "_resolverType > uint8(ADR.ARBITRATOR)");
insert BinaryExpression(2806, 2805, "_resolverType > uint8(ADR.ARBITRATOR)");
insert Expression(2807, 2806, "_resolverType");
insert Identifier(2808, 2807, "_resolverType");
insert Expression(2809, 2806, "uint8(ADR.ARBITRATOR)");
insert TypeCastExpression(2810, 2809, "uint8(ADR.ARBITRATOR)");
insert PrimitiveType(2811, 2810, "uint8");
insert CallArgument(2812, 2810, "ADR.ARBITRATOR");
insert Expression(2813, 2812, "ADR.ARBITRATOR");
insert MemberExpression(2814, 2813, "ADR.ARBITRATOR");
insert Identifier(2815, 2814, "ADR");
insert Identifier(2816, 2814, "ARBITRATOR");
insert Statement(2817, 2804, "revert InvalidResolverType();");
insert RevertStatement(2818, 2817, "revert InvalidResolverType();");
insert Expression(2819, 2818, "InvalidResolverType");
insert Identifier(2820, 2819, "InvalidResolverType");
insert RevertArguments(2821, 2818, "()");
insert Statement(2822, 2678, "if (_resolver == address(0)) revert InvalidResolver();");
insert IfStatement(2823, 2822, "if (_resolver == address(0)) revert InvalidResolver();");
insert Expression(2824, 2823, "_resolver == address(0)");
insert BinaryExpression(2825, 2824, "_resolver == address(0)");
insert Expression(2826, 2825, "_resolver");
insert Identifier(2827, 2826, "_resolver");
insert Expression(2828, 2825, "address(0)");
insert TypeCastExpression(2829, 2828, "address(0)");
insert PrimitiveType(2830, 2829, "address");
insert CallArgument(2831, 2829, "0");
insert Expression(2832, 2831, "0");
insert NumberLiteral(2833, 2832, "0");
insert Statement(2834, 2823, "revert InvalidResolver();");
insert RevertStatement(2835, 2834, "revert InvalidResolver();");
insert Expression(2836, 2835, "InvalidResolver");
insert Identifier(2837, 2836, "InvalidResolver");
insert RevertArguments(2838, 2835, "()");
insert Statement(2839, 2678, "if (_token == address(0)) revert InvalidToken();");
insert IfStatement(2840, 2839, "if (_token == address(0)) revert InvalidToken();");
insert Expression(2841, 2840, "_token == address(0)");
insert BinaryExpression(2842, 2841, "_token == address(0)");
insert Expression(2843, 2842, "_token");
insert Identifier(2844, 2843, "_token");
insert Expression(2845, 2842, "address(0)");
insert TypeCastExpression(2846, 2845, "address(0)");
insert PrimitiveType(2847, 2846, "address");
insert CallArgument(2848, 2846, "0");
insert Expression(2849, 2848, "0");
insert NumberLiteral(2850, 2849, "0");
insert Statement(2851, 2840, "revert InvalidToken();");
insert RevertStatement(2852, 2851, "revert InvalidToken();");
insert Expression(2853, 2852, "InvalidToken");
insert Identifier(2854, 2853, "InvalidToken");
insert RevertArguments(2855, 2852, "()");
insert Statement(2856, 2678, "if (_terminationTime <= block.timestamp) revert DurationEnded();");
insert IfStatement(2857, 2856, "if (_terminationTime <= block.timestamp) revert DurationEnded();");
insert Expression(2858, 2857, "_terminationTime <= block.timestamp");
insert BinaryExpression(2859, 2858, "_terminationTime <= block.timestamp");
insert Expression(2860, 2859, "_terminationTime");
insert Identifier(2861, 2860, "_terminationTime");
insert Expression(2862, 2859, "block.timestamp");
insert MemberExpression(2863, 2862, "block.timestamp");
insert Identifier(2864, 2863, "block");
insert Identifier(2865, 2863, "timestamp");
insert Statement(2866, 2857, "revert DurationEnded();");
insert RevertStatement(2867, 2866, "revert DurationEnded();");
insert Expression(2868, 2867, "DurationEnded");
insert Identifier(2869, 2868, "DurationEnded");
insert RevertArguments(2870, 2867, "()");
insert Statement(2871, 2678, "if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();");
insert IfStatement(2872, 2871, "if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();");
insert Expression(2873, 2872, "_terminationTime > block.timestamp + MAX_TERMINATION_TIME");
insert BinaryExpression(2874, 2873, "_terminationTime > block.timestamp + MAX_TERMINATION_TIME");
insert Expression(2875, 2874, "_terminationTime > block.timestamp");
insert MemberExpression(2876, 2875, "_terminationTime > block.timestamp");
insert Expression(2877, 2876, "_terminationTime > block");
insert BinaryExpression(2878, 2877, "_terminationTime > block");
insert Expression(2879, 2878, "_terminationTime");
insert Identifier(2880, 2879, "_terminationTime");
insert Expression(2881, 2878, "block");
insert Identifier(2882, 2881, "block");
insert Identifier(2883, 2876, "timestamp");
insert Expression(2884, 2874, "MAX_TERMINATION_TIME");
insert Identifier(2885, 2884, "MAX_TERMINATION_TIME");
insert Statement(2886, 2872, "revert DurationTooLong();");
insert RevertStatement(2887, 2886, "revert DurationTooLong();");
insert Expression(2888, 2887, "DurationTooLong");
insert Identifier(2889, 2888, "DurationTooLong");
insert RevertArguments(2890, 2887, "()");
insert Statement(2891, 2678, "if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();");
insert IfStatement(2892, 2891, "if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();");
insert Expression(2893, 2892, "_wrappedNativeToken == address(0)");
insert BinaryExpression(2894, 2893, "_wrappedNativeToken == address(0)");
insert Expression(2895, 2894, "_wrappedNativeToken");
insert Identifier(2896, 2895, "_wrappedNativeToken");
insert Expression(2897, 2894, "address(0)");
insert TypeCastExpression(2898, 2897, "address(0)");
insert PrimitiveType(2899, 2898, "address");
insert CallArgument(2900, 2898, "0");
insert Expression(2901, 2900, "0");
insert NumberLiteral(2902, 2901, "0");
insert Statement(2903, 2892, "revert InvalidWrappedNativeToken();");
insert RevertStatement(2904, 2903, "revert InvalidWrappedNativeToken();");
insert Expression(2905, 2904, "InvalidWrappedNativeToken");
insert Identifier(2906, 2905, "InvalidWrappedNativeToken");
insert RevertArguments(2907, 2904, "()");
insert Statement(2908, 2678, "uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);");
insert VariableDeclarationStatement(2909, 2908, "uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);");
insert VariableDeclaration(2910, 2909, "uint256 _resolutionRate");
insert TypeName(2911, 2910, "uint256");
insert PrimitiveType(2912, 2911, "uint256");
insert Identifier(2913, 2910, "_resolutionRate");
insert Expression(2914, 2909, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver)");
insert CallExpression(2915, 2914, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver)");
insert Expression(2916, 2915, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf");
insert MemberExpression(2917, 2916, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf");
insert Expression(2918, 2917, "ISmartInvoiceFactory(_factory)");
insert CallExpression(2919, 2918, "ISmartInvoiceFactory(_factory)");
insert Expression(2920, 2919, "ISmartInvoiceFactory");
insert Identifier(2921, 2920, "ISmartInvoiceFactory");
insert CallArgument(2922, 2919, "_factory");
insert Expression(2923, 2922, "_factory");
insert Identifier(2924, 2923, "_factory");
insert Identifier(2925, 2917, "resolutionRateOf");
insert CallArgument(2926, 2915, "_resolver");
insert Expression(2927, 2926, "_resolver");
insert Identifier(2928, 2927, "_resolver");
insert Statement(2929, 2678, "if (_resolutionRate == 0) {\n            _resolutionRate = 20; // Default resolution rate if not specified\n        }");
insert IfStatement(2930, 2929, "if (_resolutionRate == 0) {\n            _resolutionRate = 20; // Default resolution rate if not specified\n        }");
insert Expression(2931, 2930, "_resolutionRate == 0");
insert BinaryExpression(2932, 2931, "_resolutionRate == 0");
insert Expression(2933, 2932, "_resolutionRate");
insert Identifier(2934, 2933, "_resolutionRate");
insert Expression(2935, 2932, "0");
insert NumberLiteral(2936, 2935, "0");
insert Statement(2937, 2930, "{\n            _resolutionRate = 20; // Default resolution rate if not specified\n        }");
insert BlockStatement(2938, 2937, "{\n            _resolutionRate = 20; // Default resolution rate if not specified\n        }");
insert Statement(2939, 2938, "_resolutionRate = 20;");
insert ExpressionStatement(2940, 2939, "_resolutionRate = 20;");
insert Expression(2941, 2940, "_resolutionRate = 20");
insert AssignmentExpression(2942, 2941, "_resolutionRate = 20");
insert Expression(2943, 2942, "_resolutionRate");
insert Identifier(2944, 2943, "_resolutionRate");
insert Expression(2945, 2942, "20");
insert NumberLiteral(2946, 2945, "20");
insert Comment(2947, 2938, "// Default resolution rate if not specified");
insert Statement(2948, 2678, "client = _client;");
insert ExpressionStatement(2949, 2948, "client = _client;");
insert Expression(2950, 2949, "client = _client");
insert AssignmentExpression(2951, 2950, "client = _client");
insert Expression(2952, 2951, "client");
insert Identifier(2953, 2952, "client");
insert Expression(2954, 2951, "_client");
insert Identifier(2955, 2954, "_client");
insert Statement(2956, 2678, "resolverType = ADR(_resolverType);");
insert ExpressionStatement(2957, 2956, "resolverType = ADR(_resolverType);");
insert Expression(2958, 2957, "resolverType = ADR(_resolverType)");
insert AssignmentExpression(2959, 2958, "resolverType = ADR(_resolverType)");
insert Expression(2960, 2959, "resolverType");
insert Identifier(2961, 2960, "resolverType");
insert Expression(2962, 2959, "ADR(_resolverType)");
insert CallExpression(2963, 2962, "ADR(_resolverType)");
insert Expression(2964, 2963, "ADR");
insert Identifier(2965, 2964, "ADR");
insert CallArgument(2966, 2963, "_resolverType");
insert Expression(2967, 2966, "_resolverType");
insert Identifier(2968, 2967, "_resolverType");
insert Statement(2969, 2678, "resolver = _resolver;");
insert ExpressionStatement(2970, 2969, "resolver = _resolver;");
insert Expression(2971, 2970, "resolver = _resolver");
insert AssignmentExpression(2972, 2971, "resolver = _resolver");
insert Expression(2973, 2972, "resolver");
insert Identifier(2974, 2973, "resolver");
insert Expression(2975, 2972, "_resolver");
insert Identifier(2976, 2975, "_resolver");
insert Statement(2977, 2678, "token = _token;");
insert ExpressionStatement(2978, 2977, "token = _token;");
insert Expression(2979, 2978, "token = _token");
insert AssignmentExpression(2980, 2979, "token = _token");
insert Expression(2981, 2980, "token");
insert Identifier(2982, 2981, "token");
insert Expression(2983, 2980, "_token");
insert Identifier(2984, 2983, "_token");
insert Statement(2985, 2678, "terminationTime = _terminationTime;");
insert ExpressionStatement(2986, 2985, "terminationTime = _terminationTime;");
insert Expression(2987, 2986, "terminationTime = _terminationTime");
insert AssignmentExpression(2988, 2987, "terminationTime = _terminationTime");
insert Expression(2989, 2988, "terminationTime");
insert Identifier(2990, 2989, "terminationTime");
insert Expression(2991, 2988, "_terminationTime");
insert Identifier(2992, 2991, "_terminationTime");
insert Statement(2993, 2678, "resolutionRate = _resolutionRate;");
insert ExpressionStatement(2994, 2993, "resolutionRate = _resolutionRate;");
insert Expression(2995, 2994, "resolutionRate = _resolutionRate");
insert AssignmentExpression(2996, 2995, "resolutionRate = _resolutionRate");
insert Expression(2997, 2996, "resolutionRate");
insert Identifier(2998, 2997, "resolutionRate");
insert Expression(2999, 2996, "_resolutionRate");
insert Identifier(3000, 2999, "_resolutionRate");
insert Statement(3001, 2678, "details = _details;");
insert ExpressionStatement(3002, 3001, "details = _details;");
insert Expression(3003, 3002, "details = _details");
insert AssignmentExpression(3004, 3003, "details = _details");
insert Expression(3005, 3004, "details");
insert Identifier(3006, 3005, "details");
insert Expression(3007, 3004, "_details");
insert Identifier(3008, 3007, "_details");
insert Statement(3009, 2678, "wrappedNativeToken = _wrappedNativeToken;");
insert ExpressionStatement(3010, 3009, "wrappedNativeToken = _wrappedNativeToken;");
insert Expression(3011, 3010, "wrappedNativeToken = _wrappedNativeToken");
insert AssignmentExpression(3012, 3011, "wrappedNativeToken = _wrappedNativeToken");
insert Expression(3013, 3012, "wrappedNativeToken");
insert Identifier(3014, 3013, "wrappedNativeToken");
insert Expression(3015, 3012, "_wrappedNativeToken");
insert Identifier(3016, 3015, "_wrappedNativeToken");
insert Statement(3017, 2678, "dao = _dao;");
insert ExpressionStatement(3018, 3017, "dao = _dao;");
insert Expression(3019, 3018, "dao = _dao");
insert AssignmentExpression(3020, 3019, "dao = _dao");
insert Expression(3021, 3020, "dao");
insert Identifier(3022, 3021, "dao");
insert Expression(3023, 3020, "_dao");
insert Identifier(3024, 3023, "_dao");
insert Statement(3025, 2678, "daoFee = _daoFee;");
insert ExpressionStatement(3026, 3025, "daoFee = _daoFee;");
insert Expression(3027, 3026, "daoFee = _daoFee");
insert AssignmentExpression(3028, 3027, "daoFee = _daoFee");
insert Expression(3029, 3028, "daoFee");
insert Identifier(3030, 3029, "daoFee");
insert Expression(3031, 3028, "_daoFee");
insert Identifier(3032, 3031, "_daoFee");
insert Statement(3033, 2678, "if (!_requireVerification) emit Verified(client, address(this));");
insert IfStatement(3034, 3033, "if (!_requireVerification) emit Verified(client, address(this));");
insert Expression(3035, 3034, "!_requireVerification");
insert UnaryExpression(3036, 3035, "!_requireVerification");
insert Expression(3037, 3036, "_requireVerification");
insert Identifier(3038, 3037, "_requireVerification");
insert Statement(3039, 3034, "emit Verified(client, address(this));");
insert EmitStatement(3040, 3039, "emit Verified(client, address(this));");
insert Expression(3041, 3040, "Verified");
insert Identifier(3042, 3041, "Verified");
insert CallArgument(3043, 3040, "client");
insert Expression(3044, 3043, "client");
insert Identifier(3045, 3044, "client");
insert CallArgument(3046, 3040, "address(this)");
insert Expression(3047, 3046, "address(this)");
insert TypeCastExpression(3048, 3047, "address(this)");
insert PrimitiveType(3049, 3048, "address");
insert CallArgument(3050, 3048, "this");
insert Expression(3051, 3050, "this");
insert Identifier(3052, 3051, "this");
insert Comment(3053, 2649, "/**\n     * @dev Internal function to transfer payment to the provider and DAO.\n     * @param _token The address of the token to transfer.\n     * @param _amount The amount of tokens to transfer.\n     */");
insert FunctionDefinition(3054, 2649, "function _transferPayment(\n        address _token,\n        uint256 _amount\n    ) internal virtual override {\n        uint256 daoAmount = (_amount * daoFee) / 10000;\n        uint256 providerAmount = _amount - daoAmount;\n\n        IERC20(_token).safeTransfer(dao, daoAmount);\n        IERC20(_token).safeTransfer(provider, providerAmount);\n    }");
insert Identifier(3055, 3054, "_transferPayment");
insert Parameter(3056, 3054, "address _token");
insert TypeName(3057, 3056, "address");
insert PrimitiveType(3058, 3057, "address");
insert Identifier(3059, 3056, "_token");
insert Parameter(3060, 3054, "uint256 _amount");
insert TypeName(3061, 3060, "uint256");
insert PrimitiveType(3062, 3061, "uint256");
insert Identifier(3063, 3060, "_amount");
insert Visibility(3064, 3054, "internal");
insert Virtual(3065, 3054, "virtual");
insert OverrideSpecifier(3066, 3054, "override");
insert FunctionBody(3067, 3054, "{\n        uint256 daoAmount = (_amount * daoFee) / 10000;\n        uint256 providerAmount = _amount - daoAmount;\n\n        IERC20(_token).safeTransfer(dao, daoAmount);\n        IERC20(_token).safeTransfer(provider, providerAmount);\n    }");
insert Statement(3068, 3067, "uint256 daoAmount = (_amount * daoFee) / 10000;");
insert VariableDeclarationStatement(3069, 3068, "uint256 daoAmount = (_amount * daoFee) / 10000;");
insert VariableDeclaration(3070, 3069, "uint256 daoAmount");
insert TypeName(3071, 3070, "uint256");
insert PrimitiveType(3072, 3071, "uint256");
insert Identifier(3073, 3070, "daoAmount");
insert Expression(3074, 3069, "(_amount * daoFee) / 10000");
insert BinaryExpression(3075, 3074, "(_amount * daoFee) / 10000");
insert Expression(3076, 3075, "(_amount * daoFee)");
insert ParenthesizedExpression(3077, 3076, "(_amount * daoFee)");
insert Expression(3078, 3077, "_amount * daoFee");
insert BinaryExpression(3079, 3078, "_amount * daoFee");
insert Expression(3080, 3079, "_amount");
insert Identifier(3081, 3080, "_amount");
insert Expression(3082, 3079, "daoFee");
insert Identifier(3083, 3082, "daoFee");
insert Expression(3084, 3075, "10000");
insert NumberLiteral(3085, 3084, "10000");
insert Statement(3086, 3067, "uint256 providerAmount = _amount - daoAmount;");
insert VariableDeclarationStatement(3087, 3086, "uint256 providerAmount = _amount - daoAmount;");
insert VariableDeclaration(3088, 3087, "uint256 providerAmount");
insert TypeName(3089, 3088, "uint256");
insert PrimitiveType(3090, 3089, "uint256");
insert Identifier(3091, 3088, "providerAmount");
insert Expression(3092, 3087, "_amount - daoAmount");
insert BinaryExpression(3093, 3092, "_amount - daoAmount");
insert Expression(3094, 3093, "_amount");
insert Identifier(3095, 3094, "_amount");
insert Expression(3096, 3093, "daoAmount");
insert Identifier(3097, 3096, "daoAmount");
insert Statement(3098, 3067, "IERC20(_token).safeTransfer(dao, daoAmount);");
insert ExpressionStatement(3099, 3098, "IERC20(_token).safeTransfer(dao, daoAmount);");
insert Expression(3100, 3099, "IERC20(_token).safeTransfer(dao, daoAmount)");
insert CallExpression(3101, 3100, "IERC20(_token).safeTransfer(dao, daoAmount)");
insert Expression(3102, 3101, "IERC20(_token).safeTransfer");
insert MemberExpression(3103, 3102, "IERC20(_token).safeTransfer");
insert Expression(3104, 3103, "IERC20(_token)");
insert CallExpression(3105, 3104, "IERC20(_token)");
insert Expression(3106, 3105, "IERC20");
insert Identifier(3107, 3106, "IERC20");
insert CallArgument(3108, 3105, "_token");
insert Expression(3109, 3108, "_token");
insert Identifier(3110, 3109, "_token");
insert Identifier(3111, 3103, "safeTransfer");
insert CallArgument(3112, 3101, "dao");
insert Expression(3113, 3112, "dao");
insert Identifier(3114, 3113, "dao");
insert CallArgument(3115, 3101, "daoAmount");
insert Expression(3116, 3115, "daoAmount");
insert Identifier(3117, 3116, "daoAmount");
insert Statement(3118, 3067, "IERC20(_token).safeTransfer(provider, providerAmount);");
insert ExpressionStatement(3119, 3118, "IERC20(_token).safeTransfer(provider, providerAmount);");
insert Expression(3120, 3119, "IERC20(_token).safeTransfer(provider, providerAmount)");
insert CallExpression(3121, 3120, "IERC20(_token).safeTransfer(provider, providerAmount)");
insert Expression(3122, 3121, "IERC20(_token).safeTransfer");
insert MemberExpression(3123, 3122, "IERC20(_token).safeTransfer");
insert Expression(3124, 3123, "IERC20(_token)");
insert CallExpression(3125, 3124, "IERC20(_token)");
insert Expression(3126, 3125, "IERC20");
insert Identifier(3127, 3126, "IERC20");
insert CallArgument(3128, 3125, "_token");
insert Expression(3129, 3128, "_token");
insert Identifier(3130, 3129, "_token");
insert Identifier(3131, 3123, "safeTransfer");
insert CallArgument(3132, 3121, "provider");
insert Expression(3133, 3132, "provider");
insert Identifier(3134, 3133, "provider");
insert CallArgument(3135, 3121, "providerAmount");
insert Expression(3136, 3135, "providerAmount");
insert Identifier(3137, 3136, "providerAmount");
insert SourceFile(3138, 0, "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {SpoilsManager} from \"./SpoilsManager.sol\";\n\n/// @title Spoils Manager Factory Contract\n/// @notice Factory contract for deploying new instances of the SpoilsManager contract, allowing configuration of spoils percentage and receiver.\ncontract SpoilsManagerFactory {\n    address public implementation;\n\n    error InvalidSpoilsAmount();\n    error InvalidReceiverAddress();\n\n    event SpoilsManagerCreated(\n        address indexed spoilsManager,\n        address indexed implementation,\n        bytes32 indexed salt\n    );\n\n    constructor(address _implementation) {\n        implementation = _implementation;\n    }\n\n    /**\n     * @dev Create a new SpoilsManager contract\n     * @param _spoils Percentage of each payment to be sent to the owner's receiver\n     * @param _receiver Address of the owner's receiver\n     * @param _newOwner Address of the initial owner of the SpoilsManager contract\n     * @param _salt Salt used to create the contract address\n     */\n    function createSpoilsManager(\n        uint32 _spoils,\n        uint32 _percentageScale,\n        address _receiver,\n        address _newOwner,\n        bytes32 _salt\n    ) external returns (address) {\n        if (_spoils == uint32(0)) {\n            revert InvalidSpoilsAmount();\n        }\n        if (_receiver == address(0)) {\n            revert InvalidReceiverAddress();\n        }\n\n        address spoilsManager = Clones.cloneDeterministic(\n            implementation,\n            _salt\n        );\n        address newOwner = _newOwner;\n        if (newOwner == address(0)) {\n            newOwner = msg.sender;\n        }\n        SpoilsManager(spoilsManager).init(\n            _spoils,\n            _percentageScale,\n            _receiver,\n            newOwner\n        );\n        emit SpoilsManagerCreated(spoilsManager, implementation, _salt);\n        return spoilsManager;\n    }\n}\n");
insert Comment(3139, 3138, "// SPDX-License-Identifier: MIT");
insert PragmaDirective(3140, 3138, "pragma solidity ^0.8.20;");
insert SolidityPragmaToken(3141, 3140, "solidity ^0.8.20");
insert SolidityVersionComparisonOperator(3142, 3141, " ^");
insert SolidityVersion(3143, 3141, "0.8.20");
insert ImportDirective(3144, 3138, "import {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";");
insert Identifier(3145, 3144, "Clones");
insert ImportDirective(3146, 3138, "import {SpoilsManager} from \"./SpoilsManager.sol\";");
insert Identifier(3147, 3146, "SpoilsManager");
insert Comment(3148, 3138, "/// @title Spoils Manager Factory Contract");
insert Comment(3149, 3138, "/// @notice Factory contract for deploying new instances of the SpoilsManager contract, allowing configuration of spoils percentage and receiver.");
insert ContractDeclaration(3150, 3138, "contract SpoilsManagerFactory {\n    address public implementation;\n\n    error InvalidSpoilsAmount();\n    error InvalidReceiverAddress();\n\n    event SpoilsManagerCreated(\n        address indexed spoilsManager,\n        address indexed implementation,\n        bytes32 indexed salt\n    );\n\n    constructor(address _implementation) {\n        implementation = _implementation;\n    }\n\n    /**\n     * @dev Create a new SpoilsManager contract\n     * @param _spoils Percentage of each payment to be sent to the owner's receiver\n     * @param _receiver Address of the owner's receiver\n     * @param _newOwner Address of the initial owner of the SpoilsManager contract\n     * @param _salt Salt used to create the contract address\n     */\n    function createSpoilsManager(\n        uint32 _spoils,\n        uint32 _percentageScale,\n        address _receiver,\n        address _newOwner,\n        bytes32 _salt\n    ) external returns (address) {\n        if (_spoils == uint32(0)) {\n            revert InvalidSpoilsAmount();\n        }\n        if (_receiver == address(0)) {\n            revert InvalidReceiverAddress();\n        }\n\n        address spoilsManager = Clones.cloneDeterministic(\n            implementation,\n            _salt\n        );\n        address newOwner = _newOwner;\n        if (newOwner == address(0)) {\n            newOwner = msg.sender;\n        }\n        SpoilsManager(spoilsManager).init(\n            _spoils,\n            _percentageScale,\n            _receiver,\n            newOwner\n        );\n        emit SpoilsManagerCreated(spoilsManager, implementation, _salt);\n        return spoilsManager;\n    }\n}");
insert Identifier(3151, 3150, "SpoilsManagerFactory");
insert ContractBody(3152, 3150, "{\n    address public implementation;\n\n    error InvalidSpoilsAmount();\n    error InvalidReceiverAddress();\n\n    event SpoilsManagerCreated(\n        address indexed spoilsManager,\n        address indexed implementation,\n        bytes32 indexed salt\n    );\n\n    constructor(address _implementation) {\n        implementation = _implementation;\n    }\n\n    /**\n     * @dev Create a new SpoilsManager contract\n     * @param _spoils Percentage of each payment to be sent to the owner's receiver\n     * @param _receiver Address of the owner's receiver\n     * @param _newOwner Address of the initial owner of the SpoilsManager contract\n     * @param _salt Salt used to create the contract address\n     */\n    function createSpoilsManager(\n        uint32 _spoils,\n        uint32 _percentageScale,\n        address _receiver,\n        address _newOwner,\n        bytes32 _salt\n    ) external returns (address) {\n        if (_spoils == uint32(0)) {\n            revert InvalidSpoilsAmount();\n        }\n        if (_receiver == address(0)) {\n            revert InvalidReceiverAddress();\n        }\n\n        address spoilsManager = Clones.cloneDeterministic(\n            implementation,\n            _salt\n        );\n        address newOwner = _newOwner;\n        if (newOwner == address(0)) {\n            newOwner = msg.sender;\n        }\n        SpoilsManager(spoilsManager).init(\n            _spoils,\n            _percentageScale,\n            _receiver,\n            newOwner\n        );\n        emit SpoilsManagerCreated(spoilsManager, implementation, _salt);\n        return spoilsManager;\n    }\n}");
insert StateVariableDeclaration(3153, 3152, "address public implementation;");
insert TypeName(3154, 3153, "address");
insert PrimitiveType(3155, 3154, "address");
insert Visibility(3156, 3153, "public");
insert Identifier(3157, 3153, "implementation");
insert ErrorDeclaration(3158, 3152, "error InvalidSpoilsAmount();");
insert Identifier(3159, 3158, "InvalidSpoilsAmount");
insert ErrorDeclaration(3160, 3152, "error InvalidReceiverAddress();");
insert Identifier(3161, 3160, "InvalidReceiverAddress");
insert EventDefinition(3162, 3152, "event SpoilsManagerCreated(\n        address indexed spoilsManager,\n        address indexed implementation,\n        bytes32 indexed salt\n    );");
insert Identifier(3163, 3162, "SpoilsManagerCreated");
insert EventParameter(3164, 3162, "address indexed spoilsManager");
insert TypeName(3165, 3164, "address");
insert PrimitiveType(3166, 3165, "address");
insert Identifier(3167, 3164, "spoilsManager");
insert EventParameter(3168, 3162, "address indexed implementation");
insert TypeName(3169, 3168, "address");
insert PrimitiveType(3170, 3169, "address");
insert Identifier(3171, 3168, "implementation");
insert EventParameter(3172, 3162, "bytes32 indexed salt");
insert TypeName(3173, 3172, "bytes32");
insert PrimitiveType(3174, 3173, "bytes32");
insert Identifier(3175, 3172, "salt");
insert ConstructorDefinition(3176, 3152, "constructor(address _implementation) {\n        implementation = _implementation;\n    }");
insert Parameter(3177, 3176, "address _implementation");
insert TypeName(3178, 3177, "address");
insert PrimitiveType(3179, 3178, "address");
insert Identifier(3180, 3177, "_implementation");
insert FunctionBody(3181, 3176, "{\n        implementation = _implementation;\n    }");
insert Statement(3182, 3181, "implementation = _implementation;");
insert ExpressionStatement(3183, 3182, "implementation = _implementation;");
insert Expression(3184, 3183, "implementation = _implementation");
insert AssignmentExpression(3185, 3184, "implementation = _implementation");
insert Expression(3186, 3185, "implementation");
insert Identifier(3187, 3186, "implementation");
insert Expression(3188, 3185, "_implementation");
insert Identifier(3189, 3188, "_implementation");
insert Comment(3190, 3152, "/**\n     * @dev Create a new SpoilsManager contract\n     * @param _spoils Percentage of each payment to be sent to the owner's receiver\n     * @param _receiver Address of the owner's receiver\n     * @param _newOwner Address of the initial owner of the SpoilsManager contract\n     * @param _salt Salt used to create the contract address\n     */");
insert FunctionDefinition(3191, 3152, "function createSpoilsManager(\n        uint32 _spoils,\n        uint32 _percentageScale,\n        address _receiver,\n        address _newOwner,\n        bytes32 _salt\n    ) external returns (address) {\n        if (_spoils == uint32(0)) {\n            revert InvalidSpoilsAmount();\n        }\n        if (_receiver == address(0)) {\n            revert InvalidReceiverAddress();\n        }\n\n        address spoilsManager = Clones.cloneDeterministic(\n            implementation,\n            _salt\n        );\n        address newOwner = _newOwner;\n        if (newOwner == address(0)) {\n            newOwner = msg.sender;\n        }\n        SpoilsManager(spoilsManager).init(\n            _spoils,\n            _percentageScale,\n            _receiver,\n            newOwner\n        );\n        emit SpoilsManagerCreated(spoilsManager, implementation, _salt);\n        return spoilsManager;\n    }");
insert Identifier(3192, 3191, "createSpoilsManager");
insert Parameter(3193, 3191, "uint32 _spoils");
insert TypeName(3194, 3193, "uint32");
insert PrimitiveType(3195, 3194, "uint32");
insert Identifier(3196, 3193, "_spoils");
insert Parameter(3197, 3191, "uint32 _percentageScale");
insert TypeName(3198, 3197, "uint32");
insert PrimitiveType(3199, 3198, "uint32");
insert Identifier(3200, 3197, "_percentageScale");
insert Parameter(3201, 3191, "address _receiver");
insert TypeName(3202, 3201, "address");
insert PrimitiveType(3203, 3202, "address");
insert Identifier(3204, 3201, "_receiver");
insert Parameter(3205, 3191, "address _newOwner");
insert TypeName(3206, 3205, "address");
insert PrimitiveType(3207, 3206, "address");
insert Identifier(3208, 3205, "_newOwner");
insert Parameter(3209, 3191, "bytes32 _salt");
insert TypeName(3210, 3209, "bytes32");
insert PrimitiveType(3211, 3210, "bytes32");
insert Identifier(3212, 3209, "_salt");
insert Visibility(3213, 3191, "external");
insert ReturnTypeDefinition(3214, 3191, "returns (address)");
insert Parameter(3215, 3214, "address");
insert TypeName(3216, 3215, "address");
insert PrimitiveType(3217, 3216, "address");
insert FunctionBody(3218, 3191, "{\n        if (_spoils == uint32(0)) {\n            revert InvalidSpoilsAmount();\n        }\n        if (_receiver == address(0)) {\n            revert InvalidReceiverAddress();\n        }\n\n        address spoilsManager = Clones.cloneDeterministic(\n            implementation,\n            _salt\n        );\n        address newOwner = _newOwner;\n        if (newOwner == address(0)) {\n            newOwner = msg.sender;\n        }\n        SpoilsManager(spoilsManager).init(\n            _spoils,\n            _percentageScale,\n            _receiver,\n            newOwner\n        );\n        emit SpoilsManagerCreated(spoilsManager, implementation, _salt);\n        return spoilsManager;\n    }");
insert Statement(3219, 3218, "if (_spoils == uint32(0)) {\n            revert InvalidSpoilsAmount();\n        }");
insert IfStatement(3220, 3219, "if (_spoils == uint32(0)) {\n            revert InvalidSpoilsAmount();\n        }");
insert Expression(3221, 3220, "_spoils == uint32(0)");
insert BinaryExpression(3222, 3221, "_spoils == uint32(0)");
insert Expression(3223, 3222, "_spoils");
insert Identifier(3224, 3223, "_spoils");
insert Expression(3225, 3222, "uint32(0)");
insert TypeCastExpression(3226, 3225, "uint32(0)");
insert PrimitiveType(3227, 3226, "uint32");
insert CallArgument(3228, 3226, "0");
insert Expression(3229, 3228, "0");
insert NumberLiteral(3230, 3229, "0");
insert Statement(3231, 3220, "{\n            revert InvalidSpoilsAmount();\n        }");
insert BlockStatement(3232, 3231, "{\n            revert InvalidSpoilsAmount();\n        }");
insert Statement(3233, 3232, "revert InvalidSpoilsAmount();");
insert RevertStatement(3234, 3233, "revert InvalidSpoilsAmount();");
insert Expression(3235, 3234, "InvalidSpoilsAmount");
insert Identifier(3236, 3235, "InvalidSpoilsAmount");
insert RevertArguments(3237, 3234, "()");
insert Statement(3238, 3218, "if (_receiver == address(0)) {\n            revert InvalidReceiverAddress();\n        }");
insert IfStatement(3239, 3238, "if (_receiver == address(0)) {\n            revert InvalidReceiverAddress();\n        }");
insert Expression(3240, 3239, "_receiver == address(0)");
insert BinaryExpression(3241, 3240, "_receiver == address(0)");
insert Expression(3242, 3241, "_receiver");
insert Identifier(3243, 3242, "_receiver");
insert Expression(3244, 3241, "address(0)");
insert TypeCastExpression(3245, 3244, "address(0)");
insert PrimitiveType(3246, 3245, "address");
insert CallArgument(3247, 3245, "0");
insert Expression(3248, 3247, "0");
insert NumberLiteral(3249, 3248, "0");
insert Statement(3250, 3239, "{\n            revert InvalidReceiverAddress();\n        }");
insert BlockStatement(3251, 3250, "{\n            revert InvalidReceiverAddress();\n        }");
insert Statement(3252, 3251, "revert InvalidReceiverAddress();");
insert RevertStatement(3253, 3252, "revert InvalidReceiverAddress();");
insert Expression(3254, 3253, "InvalidReceiverAddress");
insert Identifier(3255, 3254, "InvalidReceiverAddress");
insert RevertArguments(3256, 3253, "()");
insert Statement(3257, 3218, "address spoilsManager = Clones.cloneDeterministic(\n            implementation,\n            _salt\n        );");
insert VariableDeclarationStatement(3258, 3257, "address spoilsManager = Clones.cloneDeterministic(\n            implementation,\n            _salt\n        );");
insert VariableDeclaration(3259, 3258, "address spoilsManager");
insert TypeName(3260, 3259, "address");
insert PrimitiveType(3261, 3260, "address");
insert Identifier(3262, 3259, "spoilsManager");
insert Expression(3263, 3258, "Clones.cloneDeterministic(\n            implementation,\n            _salt\n        )");
insert CallExpression(3264, 3263, "Clones.cloneDeterministic(\n            implementation,\n            _salt\n        )");
insert Expression(3265, 3264, "Clones.cloneDeterministic");
insert MemberExpression(3266, 3265, "Clones.cloneDeterministic");
insert Identifier(3267, 3266, "Clones");
insert Identifier(3268, 3266, "cloneDeterministic");
insert CallArgument(3269, 3264, "implementation");
insert Expression(3270, 3269, "implementation");
insert Identifier(3271, 3270, "implementation");
insert CallArgument(3272, 3264, "_salt");
insert Expression(3273, 3272, "_salt");
insert Identifier(3274, 3273, "_salt");
insert Statement(3275, 3218, "address newOwner = _newOwner;");
insert VariableDeclarationStatement(3276, 3275, "address newOwner = _newOwner;");
insert VariableDeclaration(3277, 3276, "address newOwner");
insert TypeName(3278, 3277, "address");
insert PrimitiveType(3279, 3278, "address");
insert Identifier(3280, 3277, "newOwner");
insert Expression(3281, 3276, "_newOwner");
insert Identifier(3282, 3281, "_newOwner");
insert Statement(3283, 3218, "if (newOwner == address(0)) {\n            newOwner = msg.sender;\n        }");
insert IfStatement(3284, 3283, "if (newOwner == address(0)) {\n            newOwner = msg.sender;\n        }");
insert Expression(3285, 3284, "newOwner == address(0)");
insert BinaryExpression(3286, 3285, "newOwner == address(0)");
insert Expression(3287, 3286, "newOwner");
insert Identifier(3288, 3287, "newOwner");
insert Expression(3289, 3286, "address(0)");
insert TypeCastExpression(3290, 3289, "address(0)");
insert PrimitiveType(3291, 3290, "address");
insert CallArgument(3292, 3290, "0");
insert Expression(3293, 3292, "0");
insert NumberLiteral(3294, 3293, "0");
insert Statement(3295, 3284, "{\n            newOwner = msg.sender;\n        }");
insert BlockStatement(3296, 3295, "{\n            newOwner = msg.sender;\n        }");
insert Statement(3297, 3296, "newOwner = msg.sender;");
insert ExpressionStatement(3298, 3297, "newOwner = msg.sender;");
insert Expression(3299, 3298, "newOwner = msg.sender");
insert AssignmentExpression(3300, 3299, "newOwner = msg.sender");
insert Expression(3301, 3300, "newOwner");
insert Identifier(3302, 3301, "newOwner");
insert Expression(3303, 3300, "msg.sender");
insert MemberExpression(3304, 3303, "msg.sender");
insert Identifier(3305, 3304, "msg");
insert Identifier(3306, 3304, "sender");
insert Statement(3307, 3218, "SpoilsManager(spoilsManager).init(\n            _spoils,\n            _percentageScale,\n            _receiver,\n            newOwner\n        );");
insert ExpressionStatement(3308, 3307, "SpoilsManager(spoilsManager).init(\n            _spoils,\n            _percentageScale,\n            _receiver,\n            newOwner\n        );");
insert Expression(3309, 3308, "SpoilsManager(spoilsManager).init(\n            _spoils,\n            _percentageScale,\n            _receiver,\n            newOwner\n        )");
insert CallExpression(3310, 3309, "SpoilsManager(spoilsManager).init(\n            _spoils,\n            _percentageScale,\n            _receiver,\n            newOwner\n        )");
insert Expression(3311, 3310, "SpoilsManager(spoilsManager).init");
insert MemberExpression(3312, 3311, "SpoilsManager(spoilsManager).init");
insert Expression(3313, 3312, "SpoilsManager(spoilsManager)");
insert CallExpression(3314, 3313, "SpoilsManager(spoilsManager)");
insert Expression(3315, 3314, "SpoilsManager");
insert Identifier(3316, 3315, "SpoilsManager");
insert CallArgument(3317, 3314, "spoilsManager");
insert Expression(3318, 3317, "spoilsManager");
insert Identifier(3319, 3318, "spoilsManager");
insert Identifier(3320, 3312, "init");
insert CallArgument(3321, 3310, "_spoils");
insert Expression(3322, 3321, "_spoils");
insert Identifier(3323, 3322, "_spoils");
insert CallArgument(3324, 3310, "_percentageScale");
insert Expression(3325, 3324, "_percentageScale");
insert Identifier(3326, 3325, "_percentageScale");
insert CallArgument(3327, 3310, "_receiver");
insert Expression(3328, 3327, "_receiver");
insert Identifier(3329, 3328, "_receiver");
insert CallArgument(3330, 3310, "newOwner");
insert Expression(3331, 3330, "newOwner");
insert Identifier(3332, 3331, "newOwner");
insert Statement(3333, 3218, "emit SpoilsManagerCreated(spoilsManager, implementation, _salt);");
insert EmitStatement(3334, 3333, "emit SpoilsManagerCreated(spoilsManager, implementation, _salt);");
insert Expression(3335, 3334, "SpoilsManagerCreated");
insert Identifier(3336, 3335, "SpoilsManagerCreated");
insert CallArgument(3337, 3334, "spoilsManager");
insert Expression(3338, 3337, "spoilsManager");
insert Identifier(3339, 3338, "spoilsManager");
insert CallArgument(3340, 3334, "implementation");
insert Expression(3341, 3340, "implementation");
insert Identifier(3342, 3341, "implementation");
insert CallArgument(3343, 3334, "_salt");
insert Expression(3344, 3343, "_salt");
insert Identifier(3345, 3344, "_salt");
insert Statement(3346, 3218, "return spoilsManager;");
insert ReturnStatement(3347, 3346, "return spoilsManager;");
insert Expression(3348, 3347, "spoilsManager");
insert Identifier(3349, 3348, "spoilsManager");
insert SourceFile(3350, 0, "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport {ISafeSplitsEscrowZap} from \"./interfaces/ISafeSplitsEscrowZap.sol\";\nimport {ISafeProxyFactory} from \"./interfaces/ISafeProxyFactory.sol\";\nimport {ISplitMain} from \"./interfaces/ISplitMain.sol\";\nimport {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";\nimport {IWRAPPED} from \"./interfaces/IWRAPPED.sol\";\n\n/// @title SafeSplitsEscrowZap\n/// @notice Contract for creating and managing Safe splits escrow with customizable settings.\ncontract SafeSplitsEscrowZap is\n    AccessControl,\n    Initializable,\n    ISafeSplitsEscrowZap\n{\n    /// @notice The SafeL2 singleton address\n    address public safeSingleton;\n\n    /// @notice The fallback handler address\n    address public fallbackHandler;\n\n    /// @notice The Safe proxy factory address\n    ISafeProxyFactory public safeFactory;\n\n    /// @notice The SplitMain address\n    ISplitMain public splitMain;\n\n    /// @notice The SmartInvoiceFactory address\n    ISmartInvoiceFactory public escrowFactory;\n\n    /// @notice The wrapped native token (WETH) address\n    IWRAPPED public wrappedNativeToken;\n\n    /// @notice The distributor fee provided for processing 0xSplits\n    uint32 public distributorFee = 0;\n\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    struct ZapData {\n        address safe;\n        address projectTeamSplit;\n        address escrow;\n    }\n\n    struct EscrowData {\n        address client;\n        uint8 arbitration;\n        address resolver;\n        address token;\n        uint256 terminationTime;\n        bytes32 saltNonce;\n        bytes32 details;\n        address providerReceiver;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract with provided data.\n     * @param _data The initialization data.\n     */\n    function init(bytes calldata _data) external virtual initializer {\n        _handleData(_data);\n    }\n\n    /**\n     * @dev Internal function to handle initialization data.\n     * @param _data The initialization data.\n     */\n    function _handleData(bytes calldata _data) internal virtual {\n        (\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory,\n            address _wrappedNativeToken\n        ) = abi.decode(\n                _data,\n                (address, address, address, address, address, address)\n            );\n\n        safeSingleton = _safeSingleton;\n        fallbackHandler = _fallbackHandler;\n        safeFactory = ISafeProxyFactory(_safeFactory);\n        splitMain = ISplitMain(_splitMain);\n        escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n        wrappedNativeToken = IWRAPPED(_wrappedNativeToken);\n    }\n\n    /**\n     * @dev Internal function to deploy a new Safe with the provided owners and threshold.\n     * @param _owners The address list of owners for the Safe.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _zapData The data struct for storing deployment results.\n     */\n    function _deploySafe(\n        address[] memory _owners,\n        bytes calldata _safeData,\n        ZapData memory _zapData\n    ) internal returns (ZapData memory) {\n        (uint256 _threshold, uint256 _saltNonce) = abi.decode(\n            _safeData,\n            (uint256, uint256)\n        );\n\n        bytes memory safeInitializer = abi.encodeWithSelector(\n            bytes4(\n                keccak256(\n                    \"setup(address[],uint256,address,bytes,address,address,uint256,address)\"\n                )\n            ),\n            _owners,\n            _threshold,\n            address(0), // to\n            bytes(\"0x\"), // data\n            fallbackHandler, // fallbackHandlerAddress\n            address(0), // paymentToken\n            0, // payment\n            address(0) // paymentReceiver\n        );\n\n        // Create the Safe proxy\n        _zapData.safe = safeFactory.createProxyWithNonce(\n            safeSingleton,\n            safeInitializer,\n            _saltNonce\n        );\n        if (_zapData.safe == address(0)) revert SafeNotCreated();\n\n        return _zapData;\n    }\n\n    /**\n     * @dev Internal function to create a new Split with the provided owners and percent allocations.\n     * @param _owners The address list of owners for the split.\n     * @param _percentAllocations The percent allocations for the split.\n     * @param _splitData The encoded data for split setup.\n     * @param _zapData The data struct for storing deployment results.\n     */\n    function _createSplit(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        bytes calldata _splitData,\n        ZapData memory _zapData\n    ) internal returns (ZapData memory) {\n        bool projectSplit = abi.decode(_splitData, (bool));\n        if (!projectSplit) return _zapData;\n\n        // Create the project team split\n        _zapData.projectTeamSplit = splitMain.createSplit(\n            _owners,\n            _percentAllocations,\n            distributorFee,\n            _zapData.safe\n        );\n\n        if (_zapData.projectTeamSplit == address(0))\n            revert ProjectTeamSplitNotCreated();\n\n        return _zapData;\n    }\n\n    /**\n     * @dev Internal function to handle escrow data.\n     * @param _escrowData The encoded data for escrow setup.\n     */\n    function _handleEscrowData(\n        bytes calldata _escrowData\n    ) internal pure returns (EscrowData memory) {\n        (\n            address client,\n            uint32 arbitration,\n            address resolver,\n            address token,\n            uint256 terminationTime,\n            uint256 _saltNonce,\n            bytes32 details\n        ) = abi.decode(\n                _escrowData,\n                (address, uint32, address, address, uint256, uint256, bytes32)\n            );\n\n        return\n            EscrowData({\n                client: client,\n                arbitration: uint8(arbitration),\n                resolver: resolver,\n                token: token,\n                terminationTime: terminationTime,\n                saltNonce: bytes32(_saltNonce),\n                details: details,\n                providerReceiver: address(0)\n            });\n    }\n\n    /**\n     * @dev Internal function to deploy a new Escrow with the provided details.\n     * @param _milestoneAmounts The milestone amounts for the escrow.\n     * @param _escrowData The encoded data for escrow setup.\n     * @param _escrowParams The parameters required for escrow deployment.\n     * @param _zapData The data struct for storing deployment results.\n     */\n    function _deployEscrow(\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _escrowData,\n        address[] memory _escrowParams,\n        ZapData memory _zapData\n    ) internal returns (ZapData memory) {\n        EscrowData memory escrowData = _handleEscrowData(_escrowData);\n\n        // Encode data for escrow setup\n        bytes memory escrowDetails = abi.encode(\n            escrowData.client,\n            escrowData.arbitration,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            false, // requireVerification\n            address(escrowFactory), // factory address\n            _escrowParams[1] // providerReceiver\n        );\n\n        // Deploy the escrow\n        _zapData.escrow = escrowFactory.createDeterministic(\n            _escrowParams[0], // provider\n            _milestoneAmounts, // milestoneAmounts\n            escrowDetails,\n            bytes32(\"updatable\"),\n            escrowData.saltNonce\n        );\n        if (_zapData.escrow == address(0)) revert EscrowNotCreated();\n\n        return _zapData;\n    }\n\n    /**\n     * @dev Internal function to handle escrow parameters.\n     * @param _zapData The data struct for storing deployment results.\n     */\n    function _handleEscrowParams(\n        ZapData memory _zapData\n    ) internal pure returns (address[] memory) {\n        address[] memory escrowParams = new address[](2);\n        escrowParams[0] = _zapData.safe;\n        escrowParams[1] = _zapData.projectTeamSplit != address(0)\n            ? _zapData.projectTeamSplit\n            : _zapData.safe;\n        return escrowParams;\n    }\n\n    /**\n     * @dev Internal function to create a new Safe, Split, and Escrow.\n     * @param _owners The list of owners for the Safe and Split.\n     * @param _percentAllocations The percent allocations for the Split.\n     * @param _milestoneAmounts The milestone amounts for the Escrow.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitData The encoded data for Split setup.\n     * @param _escrowData The encoded data for Escrow setup.\n     */\n    function _createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitData,\n        bytes calldata _escrowData\n    ) internal virtual {\n        ZapData memory zapData = ZapData({\n            safe: _safeAddress,\n            projectTeamSplit: address(0),\n            escrow: address(0)\n        });\n\n        if (zapData.safe == address(0)) {\n            zapData = _deploySafe(_owners, _safeData, zapData);\n        }\n\n        zapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitData,\n            zapData\n        );\n\n        address[] memory escrowParams = _handleEscrowParams(zapData);\n\n        zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            zapData\n        );\n\n        emit SafeSplitsEscrowCreated(\n            zapData.safe,\n            zapData.projectTeamSplit,\n            zapData.escrow\n        );\n    }\n\n    /**\n     * @notice Deploys a new Safe, Project Team Split, and Escrow with the provided details.\n     * @param _owners The Safe owners and project team participants.\n     * @param _percentAllocations The percent allocations for the project team split.\n     * @param _milestoneAmounts The milestone amounts for the escrow.\n     * @param _safeData The encoded data for deploying a Safe.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitData The encoded data for deploying a Split.\n     * @param _escrowData The encoded data for escrow deployment.\n     */\n    function createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitData,\n        bytes calldata _escrowData\n    ) public virtual {\n        if (_percentAllocations.length != _owners.length)\n            revert InvalidAllocationsOwnersData();\n\n        _createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitData,\n            _escrowData\n        );\n    }\n\n    /**\n     * @dev Internal function to update addresses used by the contract.\n     * @param _data The encoded data for updating addresses.\n     */\n    function _updateAddresses(bytes calldata _data) internal {\n        (\n            address _safeSingleton,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory\n        ) = abi.decode(_data, (address, address, address, address));\n\n        if (_safeSingleton != address(0)) safeSingleton = _safeSingleton;\n        if (_safeFactory != address(0))\n            safeFactory = ISafeProxyFactory(_safeFactory);\n        if (_splitMain != address(0)) splitMain = ISplitMain(_splitMain);\n        if (_escrowFactory != address(0))\n            escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n\n        emit UpdatedAddresses(\n            _safeSingleton,\n            _safeFactory,\n            _splitMain,\n            _escrowFactory\n        );\n    }\n\n    /**\n     * @notice Updates the addresses used by the contract.\n     * @param _data The encoded data for updating addresses.\n     */\n    function updateAddresses(bytes calldata _data) external {\n        if (!hasRole(ADMIN, _msgSender())) revert NotAuthorized();\n        _updateAddresses(_data);\n    }\n\n    /**\n     * @notice Updates the distributor fee.\n     * @param _distributorFee The new distributor fee.\n     */\n    function updateDistributorFee(uint32 _distributorFee) external {\n        if (!hasRole(ADMIN, _msgSender())) revert NotAuthorized();\n        distributorFee = _distributorFee;\n        emit UpdatedDistributorFee(_distributorFee);\n    }\n}\n");
insert Comment(3351, 3350, "// SPDX-License-Identifier: MIT");
insert PragmaDirective(3352, 3350, "pragma solidity ^0.8.20;");
insert SolidityPragmaToken(3353, 3352, "solidity ^0.8.20");
insert SolidityVersionComparisonOperator(3354, 3353, " ^");
insert SolidityVersion(3355, 3353, "0.8.20");
insert ImportDirective(3356, 3350, "import {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";");
insert Identifier(3357, 3356, "AccessControl");
insert ImportDirective(3358, 3350, "import {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";");
insert Identifier(3359, 3358, "Initializable");
insert ImportDirective(3360, 3350, "import {ISafeSplitsEscrowZap} from \"./interfaces/ISafeSplitsEscrowZap.sol\";");
insert Identifier(3361, 3360, "ISafeSplitsEscrowZap");
insert ImportDirective(3362, 3350, "import {ISafeProxyFactory} from \"./interfaces/ISafeProxyFactory.sol\";");
insert Identifier(3363, 3362, "ISafeProxyFactory");
insert ImportDirective(3364, 3350, "import {ISplitMain} from \"./interfaces/ISplitMain.sol\";");
insert Identifier(3365, 3364, "ISplitMain");
insert ImportDirective(3366, 3350, "import {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";");
insert Identifier(3367, 3366, "ISmartInvoiceFactory");
insert ImportDirective(3368, 3350, "import {IWRAPPED} from \"./interfaces/IWRAPPED.sol\";");
insert Identifier(3369, 3368, "IWRAPPED");
insert Comment(3370, 3350, "/// @title SafeSplitsEscrowZap");
insert Comment(3371, 3350, "/// @notice Contract for creating and managing Safe splits escrow with customizable settings.");
insert ContractDeclaration(3372, 3350, "contract SafeSplitsEscrowZap is\n    AccessControl,\n    Initializable,\n    ISafeSplitsEscrowZap\n{\n    /// @notice The SafeL2 singleton address\n    address public safeSingleton;\n\n    /// @notice The fallback handler address\n    address public fallbackHandler;\n\n    /// @notice The Safe proxy factory address\n    ISafeProxyFactory public safeFactory;\n\n    /// @notice The SplitMain address\n    ISplitMain public splitMain;\n\n    /// @notice The SmartInvoiceFactory address\n    ISmartInvoiceFactory public escrowFactory;\n\n    /// @notice The wrapped native token (WETH) address\n    IWRAPPED public wrappedNativeToken;\n\n    /// @notice The distributor fee provided for processing 0xSplits\n    uint32 public distributorFee = 0;\n\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    struct ZapData {\n        address safe;\n        address projectTeamSplit;\n        address escrow;\n    }\n\n    struct EscrowData {\n        address client;\n        uint8 arbitration;\n        address resolver;\n        address token;\n        uint256 terminationTime;\n        bytes32 saltNonce;\n        bytes32 details;\n        address providerReceiver;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract with provided data.\n     * @param _data The initialization data.\n     */\n    function init(bytes calldata _data) external virtual initializer {\n        _handleData(_data);\n    }\n\n    /**\n     * @dev Internal function to handle initialization data.\n     * @param _data The initialization data.\n     */\n    function _handleData(bytes calldata _data) internal virtual {\n        (\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory,\n            address _wrappedNativeToken\n        ) = abi.decode(\n                _data,\n                (address, address, address, address, address, address)\n            );\n\n        safeSingleton = _safeSingleton;\n        fallbackHandler = _fallbackHandler;\n        safeFactory = ISafeProxyFactory(_safeFactory);\n        splitMain = ISplitMain(_splitMain);\n        escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n        wrappedNativeToken = IWRAPPED(_wrappedNativeToken);\n    }\n\n    /**\n     * @dev Internal function to deploy a new Safe with the provided owners and threshold.\n     * @param _owners The address list of owners for the Safe.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _zapData The data struct for storing deployment results.\n     */\n    function _deploySafe(\n        address[] memory _owners,\n        bytes calldata _safeData,\n        ZapData memory _zapData\n    ) internal returns (ZapData memory) {\n        (uint256 _threshold, uint256 _saltNonce) = abi.decode(\n            _safeData,\n            (uint256, uint256)\n        );\n\n        bytes memory safeInitializer = abi.encodeWithSelector(\n            bytes4(\n                keccak256(\n                    \"setup(address[],uint256,address,bytes,address,address,uint256,address)\"\n                )\n            ),\n            _owners,\n            _threshold,\n            address(0), // to\n            bytes(\"0x\"), // data\n            fallbackHandler, // fallbackHandlerAddress\n            address(0), // paymentToken\n            0, // payment\n            address(0) // paymentReceiver\n        );\n\n        // Create the Safe proxy\n        _zapData.safe = safeFactory.createProxyWithNonce(\n            safeSingleton,\n            safeInitializer,\n            _saltNonce\n        );\n        if (_zapData.safe == address(0)) revert SafeNotCreated();\n\n        return _zapData;\n    }\n\n    /**\n     * @dev Internal function to create a new Split with the provided owners and percent allocations.\n     * @param _owners The address list of owners for the split.\n     * @param _percentAllocations The percent allocations for the split.\n     * @param _splitData The encoded data for split setup.\n     * @param _zapData The data struct for storing deployment results.\n     */\n    function _createSplit(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        bytes calldata _splitData,\n        ZapData memory _zapData\n    ) internal returns (ZapData memory) {\n        bool projectSplit = abi.decode(_splitData, (bool));\n        if (!projectSplit) return _zapData;\n\n        // Create the project team split\n        _zapData.projectTeamSplit = splitMain.createSplit(\n            _owners,\n            _percentAllocations,\n            distributorFee,\n            _zapData.safe\n        );\n\n        if (_zapData.projectTeamSplit == address(0))\n            revert ProjectTeamSplitNotCreated();\n\n        return _zapData;\n    }\n\n    /**\n     * @dev Internal function to handle escrow data.\n     * @param _escrowData The encoded data for escrow setup.\n     */\n    function _handleEscrowData(\n        bytes calldata _escrowData\n    ) internal pure returns (EscrowData memory) {\n        (\n            address client,\n            uint32 arbitration,\n            address resolver,\n            address token,\n            uint256 terminationTime,\n            uint256 _saltNonce,\n            bytes32 details\n        ) = abi.decode(\n                _escrowData,\n                (address, uint32, address, address, uint256, uint256, bytes32)\n            );\n\n        return\n            EscrowData({\n                client: client,\n                arbitration: uint8(arbitration),\n                resolver: resolver,\n                token: token,\n                terminationTime: terminationTime,\n                saltNonce: bytes32(_saltNonce),\n                details: details,\n                providerReceiver: address(0)\n            });\n    }\n\n    /**\n     * @dev Internal function to deploy a new Escrow with the provided details.\n     * @param _milestoneAmounts The milestone amounts for the escrow.\n     * @param _escrowData The encoded data for escrow setup.\n     * @param _escrowParams The parameters required for escrow deployment.\n     * @param _zapData The data struct for storing deployment results.\n     */\n    function _deployEscrow(\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _escrowData,\n        address[] memory _escrowParams,\n        ZapData memory _zapData\n    ) internal returns (ZapData memory) {\n        EscrowData memory escrowData = _handleEscrowData(_escrowData);\n\n        // Encode data for escrow setup\n        bytes memory escrowDetails = abi.encode(\n            escrowData.client,\n            escrowData.arbitration,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            false, // requireVerification\n            address(escrowFactory), // factory address\n            _escrowParams[1] // providerReceiver\n        );\n\n        // Deploy the escrow\n        _zapData.escrow = escrowFactory.createDeterministic(\n            _escrowParams[0], // provider\n            _milestoneAmounts, // milestoneAmounts\n            escrowDetails,\n            bytes32(\"updatable\"),\n            escrowData.saltNonce\n        );\n        if (_zapData.escrow == address(0)) revert EscrowNotCreated();\n\n        return _zapData;\n    }\n\n    /**\n     * @dev Internal function to handle escrow parameters.\n     * @param _zapData The data struct for storing deployment results.\n     */\n    function _handleEscrowParams(\n        ZapData memory _zapData\n    ) internal pure returns (address[] memory) {\n        address[] memory escrowParams = new address[](2);\n        escrowParams[0] = _zapData.safe;\n        escrowParams[1] = _zapData.projectTeamSplit != address(0)\n            ? _zapData.projectTeamSplit\n            : _zapData.safe;\n        return escrowParams;\n    }\n\n    /**\n     * @dev Internal function to create a new Safe, Split, and Escrow.\n     * @param _owners The list of owners for the Safe and Split.\n     * @param _percentAllocations The percent allocations for the Split.\n     * @param _milestoneAmounts The milestone amounts for the Escrow.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitData The encoded data for Split setup.\n     * @param _escrowData The encoded data for Escrow setup.\n     */\n    function _createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitData,\n        bytes calldata _escrowData\n    ) internal virtual {\n        ZapData memory zapData = ZapData({\n            safe: _safeAddress,\n            projectTeamSplit: address(0),\n            escrow: address(0)\n        });\n\n        if (zapData.safe == address(0)) {\n            zapData = _deploySafe(_owners, _safeData, zapData);\n        }\n\n        zapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitData,\n            zapData\n        );\n\n        address[] memory escrowParams = _handleEscrowParams(zapData);\n\n        zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            zapData\n        );\n\n        emit SafeSplitsEscrowCreated(\n            zapData.safe,\n            zapData.projectTeamSplit,\n            zapData.escrow\n        );\n    }\n\n    /**\n     * @notice Deploys a new Safe, Project Team Split, and Escrow with the provided details.\n     * @param _owners The Safe owners and project team participants.\n     * @param _percentAllocations The percent allocations for the project team split.\n     * @param _milestoneAmounts The milestone amounts for the escrow.\n     * @param _safeData The encoded data for deploying a Safe.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitData The encoded data for deploying a Split.\n     * @param _escrowData The encoded data for escrow deployment.\n     */\n    function createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitData,\n        bytes calldata _escrowData\n    ) public virtual {\n        if (_percentAllocations.length != _owners.length)\n            revert InvalidAllocationsOwnersData();\n\n        _createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitData,\n            _escrowData\n        );\n    }\n\n    /**\n     * @dev Internal function to update addresses used by the contract.\n     * @param _data The encoded data for updating addresses.\n     */\n    function _updateAddresses(bytes calldata _data) internal {\n        (\n            address _safeSingleton,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory\n        ) = abi.decode(_data, (address, address, address, address));\n\n        if (_safeSingleton != address(0)) safeSingleton = _safeSingleton;\n        if (_safeFactory != address(0))\n            safeFactory = ISafeProxyFactory(_safeFactory);\n        if (_splitMain != address(0)) splitMain = ISplitMain(_splitMain);\n        if (_escrowFactory != address(0))\n            escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n\n        emit UpdatedAddresses(\n            _safeSingleton,\n            _safeFactory,\n            _splitMain,\n            _escrowFactory\n        );\n    }\n\n    /**\n     * @notice Updates the addresses used by the contract.\n     * @param _data The encoded data for updating addresses.\n     */\n    function updateAddresses(bytes calldata _data) external {\n        if (!hasRole(ADMIN, _msgSender())) revert NotAuthorized();\n        _updateAddresses(_data);\n    }\n\n    /**\n     * @notice Updates the distributor fee.\n     * @param _distributorFee The new distributor fee.\n     */\n    function updateDistributorFee(uint32 _distributorFee) external {\n        if (!hasRole(ADMIN, _msgSender())) revert NotAuthorized();\n        distributorFee = _distributorFee;\n        emit UpdatedDistributorFee(_distributorFee);\n    }\n}");
insert Identifier(3373, 3372, "SafeSplitsEscrowZap");
insert InheritanceSpecifier(3374, 3372, "AccessControl");
insert UserDefinedType(3375, 3374, "AccessControl");
insert Identifier(3376, 3375, "AccessControl");
insert InheritanceSpecifier(3377, 3372, "Initializable");
insert UserDefinedType(3378, 3377, "Initializable");
insert Identifier(3379, 3378, "Initializable");
insert InheritanceSpecifier(3380, 3372, "ISafeSplitsEscrowZap");
insert UserDefinedType(3381, 3380, "ISafeSplitsEscrowZap");
insert Identifier(3382, 3381, "ISafeSplitsEscrowZap");
insert ContractBody(3383, 3372, "{\n    /// @notice The SafeL2 singleton address\n    address public safeSingleton;\n\n    /// @notice The fallback handler address\n    address public fallbackHandler;\n\n    /// @notice The Safe proxy factory address\n    ISafeProxyFactory public safeFactory;\n\n    /// @notice The SplitMain address\n    ISplitMain public splitMain;\n\n    /// @notice The SmartInvoiceFactory address\n    ISmartInvoiceFactory public escrowFactory;\n\n    /// @notice The wrapped native token (WETH) address\n    IWRAPPED public wrappedNativeToken;\n\n    /// @notice The distributor fee provided for processing 0xSplits\n    uint32 public distributorFee = 0;\n\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    struct ZapData {\n        address safe;\n        address projectTeamSplit;\n        address escrow;\n    }\n\n    struct EscrowData {\n        address client;\n        uint8 arbitration;\n        address resolver;\n        address token;\n        uint256 terminationTime;\n        bytes32 saltNonce;\n        bytes32 details;\n        address providerReceiver;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract with provided data.\n     * @param _data The initialization data.\n     */\n    function init(bytes calldata _data) external virtual initializer {\n        _handleData(_data);\n    }\n\n    /**\n     * @dev Internal function to handle initialization data.\n     * @param _data The initialization data.\n     */\n    function _handleData(bytes calldata _data) internal virtual {\n        (\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory,\n            address _wrappedNativeToken\n        ) = abi.decode(\n                _data,\n                (address, address, address, address, address, address)\n            );\n\n        safeSingleton = _safeSingleton;\n        fallbackHandler = _fallbackHandler;\n        safeFactory = ISafeProxyFactory(_safeFactory);\n        splitMain = ISplitMain(_splitMain);\n        escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n        wrappedNativeToken = IWRAPPED(_wrappedNativeToken);\n    }\n\n    /**\n     * @dev Internal function to deploy a new Safe with the provided owners and threshold.\n     * @param _owners The address list of owners for the Safe.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _zapData The data struct for storing deployment results.\n     */\n    function _deploySafe(\n        address[] memory _owners,\n        bytes calldata _safeData,\n        ZapData memory _zapData\n    ) internal returns (ZapData memory) {\n        (uint256 _threshold, uint256 _saltNonce) = abi.decode(\n            _safeData,\n            (uint256, uint256)\n        );\n\n        bytes memory safeInitializer = abi.encodeWithSelector(\n            bytes4(\n                keccak256(\n                    \"setup(address[],uint256,address,bytes,address,address,uint256,address)\"\n                )\n            ),\n            _owners,\n            _threshold,\n            address(0), // to\n            bytes(\"0x\"), // data\n            fallbackHandler, // fallbackHandlerAddress\n            address(0), // paymentToken\n            0, // payment\n            address(0) // paymentReceiver\n        );\n\n        // Create the Safe proxy\n        _zapData.safe = safeFactory.createProxyWithNonce(\n            safeSingleton,\n            safeInitializer,\n            _saltNonce\n        );\n        if (_zapData.safe == address(0)) revert SafeNotCreated();\n\n        return _zapData;\n    }\n\n    /**\n     * @dev Internal function to create a new Split with the provided owners and percent allocations.\n     * @param _owners The address list of owners for the split.\n     * @param _percentAllocations The percent allocations for the split.\n     * @param _splitData The encoded data for split setup.\n     * @param _zapData The data struct for storing deployment results.\n     */\n    function _createSplit(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        bytes calldata _splitData,\n        ZapData memory _zapData\n    ) internal returns (ZapData memory) {\n        bool projectSplit = abi.decode(_splitData, (bool));\n        if (!projectSplit) return _zapData;\n\n        // Create the project team split\n        _zapData.projectTeamSplit = splitMain.createSplit(\n            _owners,\n            _percentAllocations,\n            distributorFee,\n            _zapData.safe\n        );\n\n        if (_zapData.projectTeamSplit == address(0))\n            revert ProjectTeamSplitNotCreated();\n\n        return _zapData;\n    }\n\n    /**\n     * @dev Internal function to handle escrow data.\n     * @param _escrowData The encoded data for escrow setup.\n     */\n    function _handleEscrowData(\n        bytes calldata _escrowData\n    ) internal pure returns (EscrowData memory) {\n        (\n            address client,\n            uint32 arbitration,\n            address resolver,\n            address token,\n            uint256 terminationTime,\n            uint256 _saltNonce,\n            bytes32 details\n        ) = abi.decode(\n                _escrowData,\n                (address, uint32, address, address, uint256, uint256, bytes32)\n            );\n\n        return\n            EscrowData({\n                client: client,\n                arbitration: uint8(arbitration),\n                resolver: resolver,\n                token: token,\n                terminationTime: terminationTime,\n                saltNonce: bytes32(_saltNonce),\n                details: details,\n                providerReceiver: address(0)\n            });\n    }\n\n    /**\n     * @dev Internal function to deploy a new Escrow with the provided details.\n     * @param _milestoneAmounts The milestone amounts for the escrow.\n     * @param _escrowData The encoded data for escrow setup.\n     * @param _escrowParams The parameters required for escrow deployment.\n     * @param _zapData The data struct for storing deployment results.\n     */\n    function _deployEscrow(\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _escrowData,\n        address[] memory _escrowParams,\n        ZapData memory _zapData\n    ) internal returns (ZapData memory) {\n        EscrowData memory escrowData = _handleEscrowData(_escrowData);\n\n        // Encode data for escrow setup\n        bytes memory escrowDetails = abi.encode(\n            escrowData.client,\n            escrowData.arbitration,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            false, // requireVerification\n            address(escrowFactory), // factory address\n            _escrowParams[1] // providerReceiver\n        );\n\n        // Deploy the escrow\n        _zapData.escrow = escrowFactory.createDeterministic(\n            _escrowParams[0], // provider\n            _milestoneAmounts, // milestoneAmounts\n            escrowDetails,\n            bytes32(\"updatable\"),\n            escrowData.saltNonce\n        );\n        if (_zapData.escrow == address(0)) revert EscrowNotCreated();\n\n        return _zapData;\n    }\n\n    /**\n     * @dev Internal function to handle escrow parameters.\n     * @param _zapData The data struct for storing deployment results.\n     */\n    function _handleEscrowParams(\n        ZapData memory _zapData\n    ) internal pure returns (address[] memory) {\n        address[] memory escrowParams = new address[](2);\n        escrowParams[0] = _zapData.safe;\n        escrowParams[1] = _zapData.projectTeamSplit != address(0)\n            ? _zapData.projectTeamSplit\n            : _zapData.safe;\n        return escrowParams;\n    }\n\n    /**\n     * @dev Internal function to create a new Safe, Split, and Escrow.\n     * @param _owners The list of owners for the Safe and Split.\n     * @param _percentAllocations The percent allocations for the Split.\n     * @param _milestoneAmounts The milestone amounts for the Escrow.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitData The encoded data for Split setup.\n     * @param _escrowData The encoded data for Escrow setup.\n     */\n    function _createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitData,\n        bytes calldata _escrowData\n    ) internal virtual {\n        ZapData memory zapData = ZapData({\n            safe: _safeAddress,\n            projectTeamSplit: address(0),\n            escrow: address(0)\n        });\n\n        if (zapData.safe == address(0)) {\n            zapData = _deploySafe(_owners, _safeData, zapData);\n        }\n\n        zapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitData,\n            zapData\n        );\n\n        address[] memory escrowParams = _handleEscrowParams(zapData);\n\n        zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            zapData\n        );\n\n        emit SafeSplitsEscrowCreated(\n            zapData.safe,\n            zapData.projectTeamSplit,\n            zapData.escrow\n        );\n    }\n\n    /**\n     * @notice Deploys a new Safe, Project Team Split, and Escrow with the provided details.\n     * @param _owners The Safe owners and project team participants.\n     * @param _percentAllocations The percent allocations for the project team split.\n     * @param _milestoneAmounts The milestone amounts for the escrow.\n     * @param _safeData The encoded data for deploying a Safe.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitData The encoded data for deploying a Split.\n     * @param _escrowData The encoded data for escrow deployment.\n     */\n    function createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitData,\n        bytes calldata _escrowData\n    ) public virtual {\n        if (_percentAllocations.length != _owners.length)\n            revert InvalidAllocationsOwnersData();\n\n        _createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitData,\n            _escrowData\n        );\n    }\n\n    /**\n     * @dev Internal function to update addresses used by the contract.\n     * @param _data The encoded data for updating addresses.\n     */\n    function _updateAddresses(bytes calldata _data) internal {\n        (\n            address _safeSingleton,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory\n        ) = abi.decode(_data, (address, address, address, address));\n\n        if (_safeSingleton != address(0)) safeSingleton = _safeSingleton;\n        if (_safeFactory != address(0))\n            safeFactory = ISafeProxyFactory(_safeFactory);\n        if (_splitMain != address(0)) splitMain = ISplitMain(_splitMain);\n        if (_escrowFactory != address(0))\n            escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n\n        emit UpdatedAddresses(\n            _safeSingleton,\n            _safeFactory,\n            _splitMain,\n            _escrowFactory\n        );\n    }\n\n    /**\n     * @notice Updates the addresses used by the contract.\n     * @param _data The encoded data for updating addresses.\n     */\n    function updateAddresses(bytes calldata _data) external {\n        if (!hasRole(ADMIN, _msgSender())) revert NotAuthorized();\n        _updateAddresses(_data);\n    }\n\n    /**\n     * @notice Updates the distributor fee.\n     * @param _distributorFee The new distributor fee.\n     */\n    function updateDistributorFee(uint32 _distributorFee) external {\n        if (!hasRole(ADMIN, _msgSender())) revert NotAuthorized();\n        distributorFee = _distributorFee;\n        emit UpdatedDistributorFee(_distributorFee);\n    }\n}");
insert Comment(3384, 3383, "/// @notice The SafeL2 singleton address");
insert StateVariableDeclaration(3385, 3383, "address public safeSingleton;");
insert TypeName(3386, 3385, "address");
insert PrimitiveType(3387, 3386, "address");
insert Visibility(3388, 3385, "public");
insert Identifier(3389, 3385, "safeSingleton");
insert Comment(3390, 3383, "/// @notice The fallback handler address");
insert StateVariableDeclaration(3391, 3383, "address public fallbackHandler;");
insert TypeName(3392, 3391, "address");
insert PrimitiveType(3393, 3392, "address");
insert Visibility(3394, 3391, "public");
insert Identifier(3395, 3391, "fallbackHandler");
insert Comment(3396, 3383, "/// @notice The Safe proxy factory address");
insert StateVariableDeclaration(3397, 3383, "ISafeProxyFactory public safeFactory;");
insert TypeName(3398, 3397, "ISafeProxyFactory");
insert UserDefinedType(3399, 3398, "ISafeProxyFactory");
insert Identifier(3400, 3399, "ISafeProxyFactory");
insert Visibility(3401, 3397, "public");
insert Identifier(3402, 3397, "safeFactory");
insert Comment(3403, 3383, "/// @notice The SplitMain address");
insert StateVariableDeclaration(3404, 3383, "ISplitMain public splitMain;");
insert TypeName(3405, 3404, "ISplitMain");
insert UserDefinedType(3406, 3405, "ISplitMain");
insert Identifier(3407, 3406, "ISplitMain");
insert Visibility(3408, 3404, "public");
insert Identifier(3409, 3404, "splitMain");
insert Comment(3410, 3383, "/// @notice The SmartInvoiceFactory address");
insert StateVariableDeclaration(3411, 3383, "ISmartInvoiceFactory public escrowFactory;");
insert TypeName(3412, 3411, "ISmartInvoiceFactory");
insert UserDefinedType(3413, 3412, "ISmartInvoiceFactory");
insert Identifier(3414, 3413, "ISmartInvoiceFactory");
insert Visibility(3415, 3411, "public");
insert Identifier(3416, 3411, "escrowFactory");
insert Comment(3417, 3383, "/// @notice The wrapped native token (WETH) address");
insert StateVariableDeclaration(3418, 3383, "IWRAPPED public wrappedNativeToken;");
insert TypeName(3419, 3418, "IWRAPPED");
insert UserDefinedType(3420, 3419, "IWRAPPED");
insert Identifier(3421, 3420, "IWRAPPED");
insert Visibility(3422, 3418, "public");
insert Identifier(3423, 3418, "wrappedNativeToken");
insert Comment(3424, 3383, "/// @notice The distributor fee provided for processing 0xSplits");
insert StateVariableDeclaration(3425, 3383, "uint32 public distributorFee = 0;");
insert TypeName(3426, 3425, "uint32");
insert PrimitiveType(3427, 3426, "uint32");
insert Visibility(3428, 3425, "public");
insert Identifier(3429, 3425, "distributorFee");
insert Expression(3430, 3425, "0");
insert NumberLiteral(3431, 3430, "0");
insert StateVariableDeclaration(3432, 3383, "bytes32 public constant ADMIN = keccak256(\"ADMIN\");");
insert TypeName(3433, 3432, "bytes32");
insert PrimitiveType(3434, 3433, "bytes32");
insert Visibility(3435, 3432, "public");
insert Identifier(3436, 3432, "ADMIN");
insert Expression(3437, 3432, "keccak256(\"ADMIN\")");
insert CallExpression(3438, 3437, "keccak256(\"ADMIN\")");
insert Expression(3439, 3438, "keccak256");
insert Identifier(3440, 3439, "keccak256");
insert CallArgument(3441, 3438, "\"ADMIN\"");
insert Expression(3442, 3441, "\"ADMIN\"");
insert StringLiteral(3443, 3442, "\"ADMIN\"");
insert StructDeclaration(3444, 3383, "struct ZapData {\n        address safe;\n        address projectTeamSplit;\n        address escrow;\n    }");
insert Identifier(3445, 3444, "ZapData");
insert StructBody(3446, 3444, "{\n        address safe;\n        address projectTeamSplit;\n        address escrow;\n    }");
insert StructMember(3447, 3446, "address safe;");
insert TypeName(3448, 3447, "address");
insert PrimitiveType(3449, 3448, "address");
insert Identifier(3450, 3447, "safe");
insert StructMember(3451, 3446, "address projectTeamSplit;");
insert TypeName(3452, 3451, "address");
insert PrimitiveType(3453, 3452, "address");
insert Identifier(3454, 3451, "projectTeamSplit");
insert StructMember(3455, 3446, "address escrow;");
insert TypeName(3456, 3455, "address");
insert PrimitiveType(3457, 3456, "address");
insert Identifier(3458, 3455, "escrow");
insert StructDeclaration(3459, 3383, "struct EscrowData {\n        address client;\n        uint8 arbitration;\n        address resolver;\n        address token;\n        uint256 terminationTime;\n        bytes32 saltNonce;\n        bytes32 details;\n        address providerReceiver;\n    }");
insert Identifier(3460, 3459, "EscrowData");
insert StructBody(3461, 3459, "{\n        address client;\n        uint8 arbitration;\n        address resolver;\n        address token;\n        uint256 terminationTime;\n        bytes32 saltNonce;\n        bytes32 details;\n        address providerReceiver;\n    }");
insert StructMember(3462, 3461, "address client;");
insert TypeName(3463, 3462, "address");
insert PrimitiveType(3464, 3463, "address");
insert Identifier(3465, 3462, "client");
insert StructMember(3466, 3461, "uint8 arbitration;");
insert TypeName(3467, 3466, "uint8");
insert PrimitiveType(3468, 3467, "uint8");
insert Identifier(3469, 3466, "arbitration");
insert StructMember(3470, 3461, "address resolver;");
insert TypeName(3471, 3470, "address");
insert PrimitiveType(3472, 3471, "address");
insert Identifier(3473, 3470, "resolver");
insert StructMember(3474, 3461, "address token;");
insert TypeName(3475, 3474, "address");
insert PrimitiveType(3476, 3475, "address");
insert Identifier(3477, 3474, "token");
insert StructMember(3478, 3461, "uint256 terminationTime;");
insert TypeName(3479, 3478, "uint256");
insert PrimitiveType(3480, 3479, "uint256");
insert Identifier(3481, 3478, "terminationTime");
insert StructMember(3482, 3461, "bytes32 saltNonce;");
insert TypeName(3483, 3482, "bytes32");
insert PrimitiveType(3484, 3483, "bytes32");
insert Identifier(3485, 3482, "saltNonce");
insert StructMember(3486, 3461, "bytes32 details;");
insert TypeName(3487, 3486, "bytes32");
insert PrimitiveType(3488, 3487, "bytes32");
insert Identifier(3489, 3486, "details");
insert StructMember(3490, 3461, "address providerReceiver;");
insert TypeName(3491, 3490, "address");
insert PrimitiveType(3492, 3491, "address");
insert Identifier(3493, 3490, "providerReceiver");
insert ConstructorDefinition(3494, 3383, "constructor() {\n        _disableInitializers();\n    }");
insert FunctionBody(3495, 3494, "{\n        _disableInitializers();\n    }");
insert Statement(3496, 3495, "_disableInitializers();");
insert ExpressionStatement(3497, 3496, "_disableInitializers();");
insert Expression(3498, 3497, "_disableInitializers()");
insert CallExpression(3499, 3498, "_disableInitializers()");
insert Expression(3500, 3499, "_disableInitializers");
insert Identifier(3501, 3500, "_disableInitializers");
insert Comment(3502, 3383, "/**\n     * @notice Initializes the contract with provided data.\n     * @param _data The initialization data.\n     */");
insert FunctionDefinition(3503, 3383, "function init(bytes calldata _data) external virtual initializer {\n        _handleData(_data);\n    }");
insert Identifier(3504, 3503, "init");
insert Parameter(3505, 3503, "bytes calldata _data");
insert TypeName(3506, 3505, "bytes");
insert PrimitiveType(3507, 3506, "bytes");
insert Identifier(3508, 3505, "_data");
insert Visibility(3509, 3503, "external");
insert Virtual(3510, 3503, "virtual");
insert ModifierInvocation(3511, 3503, "initializer");
insert Identifier(3512, 3511, "initializer");
insert FunctionBody(3513, 3503, "{\n        _handleData(_data);\n    }");
insert Statement(3514, 3513, "_handleData(_data);");
insert ExpressionStatement(3515, 3514, "_handleData(_data);");
insert Expression(3516, 3515, "_handleData(_data)");
insert CallExpression(3517, 3516, "_handleData(_data)");
insert Expression(3518, 3517, "_handleData");
insert Identifier(3519, 3518, "_handleData");
insert CallArgument(3520, 3517, "_data");
insert Expression(3521, 3520, "_data");
insert Identifier(3522, 3521, "_data");
insert Comment(3523, 3383, "/**\n     * @dev Internal function to handle initialization data.\n     * @param _data The initialization data.\n     */");
insert FunctionDefinition(3524, 3383, "function _handleData(bytes calldata _data) internal virtual {\n        (\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory,\n            address _wrappedNativeToken\n        ) = abi.decode(\n                _data,\n                (address, address, address, address, address, address)\n            );\n\n        safeSingleton = _safeSingleton;\n        fallbackHandler = _fallbackHandler;\n        safeFactory = ISafeProxyFactory(_safeFactory);\n        splitMain = ISplitMain(_splitMain);\n        escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n        wrappedNativeToken = IWRAPPED(_wrappedNativeToken);\n    }");
insert Identifier(3525, 3524, "_handleData");
insert Parameter(3526, 3524, "bytes calldata _data");
insert TypeName(3527, 3526, "bytes");
insert PrimitiveType(3528, 3527, "bytes");
insert Identifier(3529, 3526, "_data");
insert Visibility(3530, 3524, "internal");
insert Virtual(3531, 3524, "virtual");
insert FunctionBody(3532, 3524, "{\n        (\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory,\n            address _wrappedNativeToken\n        ) = abi.decode(\n                _data,\n                (address, address, address, address, address, address)\n            );\n\n        safeSingleton = _safeSingleton;\n        fallbackHandler = _fallbackHandler;\n        safeFactory = ISafeProxyFactory(_safeFactory);\n        splitMain = ISplitMain(_splitMain);\n        escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n        wrappedNativeToken = IWRAPPED(_wrappedNativeToken);\n    }");
insert Statement(3533, 3532, "(\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory,\n            address _wrappedNativeToken\n        ) = abi.decode(\n                _data,\n                (address, address, address, address, address, address)\n            );");
insert VariableDeclarationStatement(3534, 3533, "(\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory,\n            address _wrappedNativeToken\n        ) = abi.decode(\n                _data,\n                (address, address, address, address, address, address)\n            );");
insert VariableDeclarationTuple(3535, 3534, "(\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory,\n            address _wrappedNativeToken\n        )");
insert VariableDeclaration(3536, 3535, "address _safeSingleton");
insert TypeName(3537, 3536, "address");
insert PrimitiveType(3538, 3537, "address");
insert Identifier(3539, 3536, "_safeSingleton");
insert VariableDeclaration(3540, 3535, "address _fallbackHandler");
insert TypeName(3541, 3540, "address");
insert PrimitiveType(3542, 3541, "address");
insert Identifier(3543, 3540, "_fallbackHandler");
insert VariableDeclaration(3544, 3535, "address _safeFactory");
insert TypeName(3545, 3544, "address");
insert PrimitiveType(3546, 3545, "address");
insert Identifier(3547, 3544, "_safeFactory");
insert VariableDeclaration(3548, 3535, "address _splitMain");
insert TypeName(3549, 3548, "address");
insert PrimitiveType(3550, 3549, "address");
insert Identifier(3551, 3548, "_splitMain");
insert VariableDeclaration(3552, 3535, "address _escrowFactory");
insert TypeName(3553, 3552, "address");
insert PrimitiveType(3554, 3553, "address");
insert Identifier(3555, 3552, "_escrowFactory");
insert VariableDeclaration(3556, 3535, "address _wrappedNativeToken");
insert TypeName(3557, 3556, "address");
insert PrimitiveType(3558, 3557, "address");
insert Identifier(3559, 3556, "_wrappedNativeToken");
insert Expression(3560, 3534, "abi.decode(\n                _data,\n                (address, address, address, address, address, address)\n            )");
insert CallExpression(3561, 3560, "abi.decode(\n                _data,\n                (address, address, address, address, address, address)\n            )");
insert Expression(3562, 3561, "abi.decode");
insert MemberExpression(3563, 3562, "abi.decode");
insert Identifier(3564, 3563, "abi");
insert Identifier(3565, 3563, "decode");
insert CallArgument(3566, 3561, "_data");
insert Expression(3567, 3566, "_data");
insert Identifier(3568, 3567, "_data");
insert CallArgument(3569, 3561, "(address, address, address, address, address, address)");
insert Expression(3570, 3569, "(address, address, address, address, address, address)");
insert TupleExpression(3571, 3570, "(address, address, address, address, address, address)");
insert Expression(3572, 3571, "address");
insert PrimitiveType(3573, 3572, "address");
insert Expression(3574, 3571, "address");
insert PrimitiveType(3575, 3574, "address");
insert Expression(3576, 3571, "address");
insert PrimitiveType(3577, 3576, "address");
insert Expression(3578, 3571, "address");
insert PrimitiveType(3579, 3578, "address");
insert Expression(3580, 3571, "address");
insert PrimitiveType(3581, 3580, "address");
insert Expression(3582, 3571, "address");
insert PrimitiveType(3583, 3582, "address");
insert Statement(3584, 3532, "safeSingleton = _safeSingleton;");
insert ExpressionStatement(3585, 3584, "safeSingleton = _safeSingleton;");
insert Expression(3586, 3585, "safeSingleton = _safeSingleton");
insert AssignmentExpression(3587, 3586, "safeSingleton = _safeSingleton");
insert Expression(3588, 3587, "safeSingleton");
insert Identifier(3589, 3588, "safeSingleton");
insert Expression(3590, 3587, "_safeSingleton");
insert Identifier(3591, 3590, "_safeSingleton");
insert Statement(3592, 3532, "fallbackHandler = _fallbackHandler;");
insert ExpressionStatement(3593, 3592, "fallbackHandler = _fallbackHandler;");
insert Expression(3594, 3593, "fallbackHandler = _fallbackHandler");
insert AssignmentExpression(3595, 3594, "fallbackHandler = _fallbackHandler");
insert Expression(3596, 3595, "fallbackHandler");
insert Identifier(3597, 3596, "fallbackHandler");
insert Expression(3598, 3595, "_fallbackHandler");
insert Identifier(3599, 3598, "_fallbackHandler");
insert Statement(3600, 3532, "safeFactory = ISafeProxyFactory(_safeFactory);");
insert ExpressionStatement(3601, 3600, "safeFactory = ISafeProxyFactory(_safeFactory);");
insert Expression(3602, 3601, "safeFactory = ISafeProxyFactory(_safeFactory)");
insert AssignmentExpression(3603, 3602, "safeFactory = ISafeProxyFactory(_safeFactory)");
insert Expression(3604, 3603, "safeFactory");
insert Identifier(3605, 3604, "safeFactory");
insert Expression(3606, 3603, "ISafeProxyFactory(_safeFactory)");
insert CallExpression(3607, 3606, "ISafeProxyFactory(_safeFactory)");
insert Expression(3608, 3607, "ISafeProxyFactory");
insert Identifier(3609, 3608, "ISafeProxyFactory");
insert CallArgument(3610, 3607, "_safeFactory");
insert Expression(3611, 3610, "_safeFactory");
insert Identifier(3612, 3611, "_safeFactory");
insert Statement(3613, 3532, "splitMain = ISplitMain(_splitMain);");
insert ExpressionStatement(3614, 3613, "splitMain = ISplitMain(_splitMain);");
insert Expression(3615, 3614, "splitMain = ISplitMain(_splitMain)");
insert AssignmentExpression(3616, 3615, "splitMain = ISplitMain(_splitMain)");
insert Expression(3617, 3616, "splitMain");
insert Identifier(3618, 3617, "splitMain");
insert Expression(3619, 3616, "ISplitMain(_splitMain)");
insert CallExpression(3620, 3619, "ISplitMain(_splitMain)");
insert Expression(3621, 3620, "ISplitMain");
insert Identifier(3622, 3621, "ISplitMain");
insert CallArgument(3623, 3620, "_splitMain");
insert Expression(3624, 3623, "_splitMain");
insert Identifier(3625, 3624, "_splitMain");
insert Statement(3626, 3532, "escrowFactory = ISmartInvoiceFactory(_escrowFactory);");
insert ExpressionStatement(3627, 3626, "escrowFactory = ISmartInvoiceFactory(_escrowFactory);");
insert Expression(3628, 3627, "escrowFactory = ISmartInvoiceFactory(_escrowFactory)");
insert AssignmentExpression(3629, 3628, "escrowFactory = ISmartInvoiceFactory(_escrowFactory)");
insert Expression(3630, 3629, "escrowFactory");
insert Identifier(3631, 3630, "escrowFactory");
insert Expression(3632, 3629, "ISmartInvoiceFactory(_escrowFactory)");
insert CallExpression(3633, 3632, "ISmartInvoiceFactory(_escrowFactory)");
insert Expression(3634, 3633, "ISmartInvoiceFactory");
insert Identifier(3635, 3634, "ISmartInvoiceFactory");
insert CallArgument(3636, 3633, "_escrowFactory");
insert Expression(3637, 3636, "_escrowFactory");
insert Identifier(3638, 3637, "_escrowFactory");
insert Statement(3639, 3532, "wrappedNativeToken = IWRAPPED(_wrappedNativeToken);");
insert ExpressionStatement(3640, 3639, "wrappedNativeToken = IWRAPPED(_wrappedNativeToken);");
insert Expression(3641, 3640, "wrappedNativeToken = IWRAPPED(_wrappedNativeToken)");
insert AssignmentExpression(3642, 3641, "wrappedNativeToken = IWRAPPED(_wrappedNativeToken)");
insert Expression(3643, 3642, "wrappedNativeToken");
insert Identifier(3644, 3643, "wrappedNativeToken");
insert Expression(3645, 3642, "IWRAPPED(_wrappedNativeToken)");
insert CallExpression(3646, 3645, "IWRAPPED(_wrappedNativeToken)");
insert Expression(3647, 3646, "IWRAPPED");
insert Identifier(3648, 3647, "IWRAPPED");
insert CallArgument(3649, 3646, "_wrappedNativeToken");
insert Expression(3650, 3649, "_wrappedNativeToken");
insert Identifier(3651, 3650, "_wrappedNativeToken");
insert Comment(3652, 3383, "/**\n     * @dev Internal function to deploy a new Safe with the provided owners and threshold.\n     * @param _owners The address list of owners for the Safe.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _zapData The data struct for storing deployment results.\n     */");
insert FunctionDefinition(3653, 3383, "function _deploySafe(\n        address[] memory _owners,\n        bytes calldata _safeData,\n        ZapData memory _zapData\n    ) internal returns (ZapData memory) {\n        (uint256 _threshold, uint256 _saltNonce) = abi.decode(\n            _safeData,\n            (uint256, uint256)\n        );\n\n        bytes memory safeInitializer = abi.encodeWithSelector(\n            bytes4(\n                keccak256(\n                    \"setup(address[],uint256,address,bytes,address,address,uint256,address)\"\n                )\n            ),\n            _owners,\n            _threshold,\n            address(0), // to\n            bytes(\"0x\"), // data\n            fallbackHandler, // fallbackHandlerAddress\n            address(0), // paymentToken\n            0, // payment\n            address(0) // paymentReceiver\n        );\n\n        // Create the Safe proxy\n        _zapData.safe = safeFactory.createProxyWithNonce(\n            safeSingleton,\n            safeInitializer,\n            _saltNonce\n        );\n        if (_zapData.safe == address(0)) revert SafeNotCreated();\n\n        return _zapData;\n    }");
insert Identifier(3654, 3653, "_deploySafe");
insert Parameter(3655, 3653, "address[] memory _owners");
insert TypeName(3656, 3655, "address[]");
insert TypeName(3657, 3656, "address");
insert PrimitiveType(3658, 3657, "address");
insert Identifier(3659, 3655, "_owners");
insert Parameter(3660, 3653, "bytes calldata _safeData");
insert TypeName(3661, 3660, "bytes");
insert PrimitiveType(3662, 3661, "bytes");
insert Identifier(3663, 3660, "_safeData");
insert Parameter(3664, 3653, "ZapData memory _zapData");
insert TypeName(3665, 3664, "ZapData");
insert UserDefinedType(3666, 3665, "ZapData");
insert Identifier(3667, 3666, "ZapData");
insert Identifier(3668, 3664, "_zapData");
insert Visibility(3669, 3653, "internal");
insert ReturnTypeDefinition(3670, 3653, "returns (ZapData memory)");
insert Parameter(3671, 3670, "ZapData memory");
insert TypeName(3672, 3671, "ZapData");
insert UserDefinedType(3673, 3672, "ZapData");
insert Identifier(3674, 3673, "ZapData");
insert FunctionBody(3675, 3653, "{\n        (uint256 _threshold, uint256 _saltNonce) = abi.decode(\n            _safeData,\n            (uint256, uint256)\n        );\n\n        bytes memory safeInitializer = abi.encodeWithSelector(\n            bytes4(\n                keccak256(\n                    \"setup(address[],uint256,address,bytes,address,address,uint256,address)\"\n                )\n            ),\n            _owners,\n            _threshold,\n            address(0), // to\n            bytes(\"0x\"), // data\n            fallbackHandler, // fallbackHandlerAddress\n            address(0), // paymentToken\n            0, // payment\n            address(0) // paymentReceiver\n        );\n\n        // Create the Safe proxy\n        _zapData.safe = safeFactory.createProxyWithNonce(\n            safeSingleton,\n            safeInitializer,\n            _saltNonce\n        );\n        if (_zapData.safe == address(0)) revert SafeNotCreated();\n\n        return _zapData;\n    }");
insert Statement(3676, 3675, "(uint256 _threshold, uint256 _saltNonce) = abi.decode(\n            _safeData,\n            (uint256, uint256)\n        );");
insert VariableDeclarationStatement(3677, 3676, "(uint256 _threshold, uint256 _saltNonce) = abi.decode(\n            _safeData,\n            (uint256, uint256)\n        );");
insert VariableDeclarationTuple(3678, 3677, "(uint256 _threshold, uint256 _saltNonce)");
insert VariableDeclaration(3679, 3678, "uint256 _threshold");
insert TypeName(3680, 3679, "uint256");
insert PrimitiveType(3681, 3680, "uint256");
insert Identifier(3682, 3679, "_threshold");
insert VariableDeclaration(3683, 3678, "uint256 _saltNonce");
insert TypeName(3684, 3683, "uint256");
insert PrimitiveType(3685, 3684, "uint256");
insert Identifier(3686, 3683, "_saltNonce");
insert Expression(3687, 3677, "abi.decode(\n            _safeData,\n            (uint256, uint256)\n        )");
insert CallExpression(3688, 3687, "abi.decode(\n            _safeData,\n            (uint256, uint256)\n        )");
insert Expression(3689, 3688, "abi.decode");
insert MemberExpression(3690, 3689, "abi.decode");
insert Identifier(3691, 3690, "abi");
insert Identifier(3692, 3690, "decode");
insert CallArgument(3693, 3688, "_safeData");
insert Expression(3694, 3693, "_safeData");
insert Identifier(3695, 3694, "_safeData");
insert CallArgument(3696, 3688, "(uint256, uint256)");
insert Expression(3697, 3696, "(uint256, uint256)");
insert TupleExpression(3698, 3697, "(uint256, uint256)");
insert Expression(3699, 3698, "uint256");
insert PrimitiveType(3700, 3699, "uint256");
insert Expression(3701, 3698, "uint256");
insert PrimitiveType(3702, 3701, "uint256");
insert Statement(3703, 3675, "bytes memory safeInitializer = abi.encodeWithSelector(\n            bytes4(\n                keccak256(\n                    \"setup(address[],uint256,address,bytes,address,address,uint256,address)\"\n                )\n            ),\n            _owners,\n            _threshold,\n            address(0), // to\n            bytes(\"0x\"), // data\n            fallbackHandler, // fallbackHandlerAddress\n            address(0), // paymentToken\n            0, // payment\n            address(0) // paymentReceiver\n        );");
insert VariableDeclarationStatement(3704, 3703, "bytes memory safeInitializer = abi.encodeWithSelector(\n            bytes4(\n                keccak256(\n                    \"setup(address[],uint256,address,bytes,address,address,uint256,address)\"\n                )\n            ),\n            _owners,\n            _threshold,\n            address(0), // to\n            bytes(\"0x\"), // data\n            fallbackHandler, // fallbackHandlerAddress\n            address(0), // paymentToken\n            0, // payment\n            address(0) // paymentReceiver\n        );");
insert VariableDeclaration(3705, 3704, "bytes memory safeInitializer");
insert TypeName(3706, 3705, "bytes");
insert PrimitiveType(3707, 3706, "bytes");
insert Identifier(3708, 3705, "safeInitializer");
insert Expression(3709, 3704, "abi.encodeWithSelector(\n            bytes4(\n                keccak256(\n                    \"setup(address[],uint256,address,bytes,address,address,uint256,address)\"\n                )\n            ),\n            _owners,\n            _threshold,\n            address(0), // to\n            bytes(\"0x\"), // data\n            fallbackHandler, // fallbackHandlerAddress\n            address(0), // paymentToken\n            0, // payment\n            address(0) // paymentReceiver\n        )");
insert CallExpression(3710, 3709, "abi.encodeWithSelector(\n            bytes4(\n                keccak256(\n                    \"setup(address[],uint256,address,bytes,address,address,uint256,address)\"\n                )\n            ),\n            _owners,\n            _threshold,\n            address(0), // to\n            bytes(\"0x\"), // data\n            fallbackHandler, // fallbackHandlerAddress\n            address(0), // paymentToken\n            0, // payment\n            address(0) // paymentReceiver\n        )");
insert Expression(3711, 3710, "abi.encodeWithSelector");
insert MemberExpression(3712, 3711, "abi.encodeWithSelector");
insert Identifier(3713, 3712, "abi");
insert Identifier(3714, 3712, "encodeWithSelector");
insert CallArgument(3715, 3710, "bytes4(\n                keccak256(\n                    \"setup(address[],uint256,address,bytes,address,address,uint256,address)\"\n                )\n            )");
insert Expression(3716, 3715, "bytes4(\n                keccak256(\n                    \"setup(address[],uint256,address,bytes,address,address,uint256,address)\"\n                )\n            )");
insert TypeCastExpression(3717, 3716, "bytes4(\n                keccak256(\n                    \"setup(address[],uint256,address,bytes,address,address,uint256,address)\"\n                )\n            )");
insert PrimitiveType(3718, 3717, "bytes4");
insert CallArgument(3719, 3717, "keccak256(\n                    \"setup(address[],uint256,address,bytes,address,address,uint256,address)\"\n                )");
insert Expression(3720, 3719, "keccak256(\n                    \"setup(address[],uint256,address,bytes,address,address,uint256,address)\"\n                )");
insert CallExpression(3721, 3720, "keccak256(\n                    \"setup(address[],uint256,address,bytes,address,address,uint256,address)\"\n                )");
insert Expression(3722, 3721, "keccak256");
insert Identifier(3723, 3722, "keccak256");
insert CallArgument(3724, 3721, "\"setup(address[],uint256,address,bytes,address,address,uint256,address)\"");
insert Expression(3725, 3724, "\"setup(address[],uint256,address,bytes,address,address,uint256,address)\"");
insert StringLiteral(3726, 3725, "\"setup(address[],uint256,address,bytes,address,address,uint256,address)\"");
insert CallArgument(3727, 3710, "_owners");
insert Expression(3728, 3727, "_owners");
insert Identifier(3729, 3728, "_owners");
insert CallArgument(3730, 3710, "_threshold");
insert Expression(3731, 3730, "_threshold");
insert Identifier(3732, 3731, "_threshold");
insert CallArgument(3733, 3710, "address(0)");
insert Expression(3734, 3733, "address(0)");
insert TypeCastExpression(3735, 3734, "address(0)");
insert PrimitiveType(3736, 3735, "address");
insert CallArgument(3737, 3735, "0");
insert Expression(3738, 3737, "0");
insert NumberLiteral(3739, 3738, "0");
insert Comment(3740, 3710, "// to");
insert CallArgument(3741, 3710, "bytes(\"0x\")");
insert Expression(3742, 3741, "bytes(\"0x\")");
insert TypeCastExpression(3743, 3742, "bytes(\"0x\")");
insert PrimitiveType(3744, 3743, "bytes");
insert CallArgument(3745, 3743, "\"0x\"");
insert Expression(3746, 3745, "\"0x\"");
insert StringLiteral(3747, 3746, "\"0x\"");
insert Comment(3748, 3710, "// data");
insert CallArgument(3749, 3710, "fallbackHandler");
insert Expression(3750, 3749, "fallbackHandler");
insert Identifier(3751, 3750, "fallbackHandler");
insert Comment(3752, 3710, "// fallbackHandlerAddress");
insert CallArgument(3753, 3710, "address(0)");
insert Expression(3754, 3753, "address(0)");
insert TypeCastExpression(3755, 3754, "address(0)");
insert PrimitiveType(3756, 3755, "address");
insert CallArgument(3757, 3755, "0");
insert Expression(3758, 3757, "0");
insert NumberLiteral(3759, 3758, "0");
insert Comment(3760, 3710, "// paymentToken");
insert CallArgument(3761, 3710, "0");
insert Expression(3762, 3761, "0");
insert NumberLiteral(3763, 3762, "0");
insert Comment(3764, 3710, "// payment");
insert CallArgument(3765, 3710, "address(0)");
insert Expression(3766, 3765, "address(0)");
insert TypeCastExpression(3767, 3766, "address(0)");
insert PrimitiveType(3768, 3767, "address");
insert CallArgument(3769, 3767, "0");
insert Expression(3770, 3769, "0");
insert NumberLiteral(3771, 3770, "0");
insert Comment(3772, 3710, "// paymentReceiver");
insert Comment(3773, 3675, "// Create the Safe proxy");
insert Statement(3774, 3675, "_zapData.safe = safeFactory.createProxyWithNonce(\n            safeSingleton,\n            safeInitializer,\n            _saltNonce\n        );");
insert ExpressionStatement(3775, 3774, "_zapData.safe = safeFactory.createProxyWithNonce(\n            safeSingleton,\n            safeInitializer,\n            _saltNonce\n        );");
insert Expression(3776, 3775, "_zapData.safe = safeFactory.createProxyWithNonce(\n            safeSingleton,\n            safeInitializer,\n            _saltNonce\n        )");
insert AssignmentExpression(3777, 3776, "_zapData.safe = safeFactory.createProxyWithNonce(\n            safeSingleton,\n            safeInitializer,\n            _saltNonce\n        )");
insert Expression(3778, 3777, "_zapData.safe");
insert MemberExpression(3779, 3778, "_zapData.safe");
insert Identifier(3780, 3779, "_zapData");
insert Identifier(3781, 3779, "safe");
insert Expression(3782, 3777, "safeFactory.createProxyWithNonce(\n            safeSingleton,\n            safeInitializer,\n            _saltNonce\n        )");
insert CallExpression(3783, 3782, "safeFactory.createProxyWithNonce(\n            safeSingleton,\n            safeInitializer,\n            _saltNonce\n        )");
insert Expression(3784, 3783, "safeFactory.createProxyWithNonce");
insert MemberExpression(3785, 3784, "safeFactory.createProxyWithNonce");
insert Identifier(3786, 3785, "safeFactory");
insert Identifier(3787, 3785, "createProxyWithNonce");
insert CallArgument(3788, 3783, "safeSingleton");
insert Expression(3789, 3788, "safeSingleton");
insert Identifier(3790, 3789, "safeSingleton");
insert CallArgument(3791, 3783, "safeInitializer");
insert Expression(3792, 3791, "safeInitializer");
insert Identifier(3793, 3792, "safeInitializer");
insert CallArgument(3794, 3783, "_saltNonce");
insert Expression(3795, 3794, "_saltNonce");
insert Identifier(3796, 3795, "_saltNonce");
insert Statement(3797, 3675, "if (_zapData.safe == address(0)) revert SafeNotCreated();");
insert IfStatement(3798, 3797, "if (_zapData.safe == address(0)) revert SafeNotCreated();");
insert Expression(3799, 3798, "_zapData.safe == address(0)");
insert BinaryExpression(3800, 3799, "_zapData.safe == address(0)");
insert Expression(3801, 3800, "_zapData.safe");
insert MemberExpression(3802, 3801, "_zapData.safe");
insert Identifier(3803, 3802, "_zapData");
insert Identifier(3804, 3802, "safe");
insert Expression(3805, 3800, "address(0)");
insert TypeCastExpression(3806, 3805, "address(0)");
insert PrimitiveType(3807, 3806, "address");
insert CallArgument(3808, 3806, "0");
insert Expression(3809, 3808, "0");
insert NumberLiteral(3810, 3809, "0");
insert Statement(3811, 3798, "revert SafeNotCreated();");
insert RevertStatement(3812, 3811, "revert SafeNotCreated();");
insert Expression(3813, 3812, "SafeNotCreated");
insert Identifier(3814, 3813, "SafeNotCreated");
insert RevertArguments(3815, 3812, "()");
insert Statement(3816, 3675, "return _zapData;");
insert ReturnStatement(3817, 3816, "return _zapData;");
insert Expression(3818, 3817, "_zapData");
insert Identifier(3819, 3818, "_zapData");
insert Comment(3820, 3383, "/**\n     * @dev Internal function to create a new Split with the provided owners and percent allocations.\n     * @param _owners The address list of owners for the split.\n     * @param _percentAllocations The percent allocations for the split.\n     * @param _splitData The encoded data for split setup.\n     * @param _zapData The data struct for storing deployment results.\n     */");
insert FunctionDefinition(3821, 3383, "function _createSplit(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        bytes calldata _splitData,\n        ZapData memory _zapData\n    ) internal returns (ZapData memory) {\n        bool projectSplit = abi.decode(_splitData, (bool));\n        if (!projectSplit) return _zapData;\n\n        // Create the project team split\n        _zapData.projectTeamSplit = splitMain.createSplit(\n            _owners,\n            _percentAllocations,\n            distributorFee,\n            _zapData.safe\n        );\n\n        if (_zapData.projectTeamSplit == address(0))\n            revert ProjectTeamSplitNotCreated();\n\n        return _zapData;\n    }");
insert Identifier(3822, 3821, "_createSplit");
insert Parameter(3823, 3821, "address[] memory _owners");
insert TypeName(3824, 3823, "address[]");
insert TypeName(3825, 3824, "address");
insert PrimitiveType(3826, 3825, "address");
insert Identifier(3827, 3823, "_owners");
insert Parameter(3828, 3821, "uint32[] memory _percentAllocations");
insert TypeName(3829, 3828, "uint32[]");
insert TypeName(3830, 3829, "uint32");
insert PrimitiveType(3831, 3830, "uint32");
insert Identifier(3832, 3828, "_percentAllocations");
insert Parameter(3833, 3821, "bytes calldata _splitData");
insert TypeName(3834, 3833, "bytes");
insert PrimitiveType(3835, 3834, "bytes");
insert Identifier(3836, 3833, "_splitData");
insert Parameter(3837, 3821, "ZapData memory _zapData");
insert TypeName(3838, 3837, "ZapData");
insert UserDefinedType(3839, 3838, "ZapData");
insert Identifier(3840, 3839, "ZapData");
insert Identifier(3841, 3837, "_zapData");
insert Visibility(3842, 3821, "internal");
insert ReturnTypeDefinition(3843, 3821, "returns (ZapData memory)");
insert Parameter(3844, 3843, "ZapData memory");
insert TypeName(3845, 3844, "ZapData");
insert UserDefinedType(3846, 3845, "ZapData");
insert Identifier(3847, 3846, "ZapData");
insert FunctionBody(3848, 3821, "{\n        bool projectSplit = abi.decode(_splitData, (bool));\n        if (!projectSplit) return _zapData;\n\n        // Create the project team split\n        _zapData.projectTeamSplit = splitMain.createSplit(\n            _owners,\n            _percentAllocations,\n            distributorFee,\n            _zapData.safe\n        );\n\n        if (_zapData.projectTeamSplit == address(0))\n            revert ProjectTeamSplitNotCreated();\n\n        return _zapData;\n    }");
insert Statement(3849, 3848, "bool projectSplit = abi.decode(_splitData, (bool));");
insert VariableDeclarationStatement(3850, 3849, "bool projectSplit = abi.decode(_splitData, (bool));");
insert VariableDeclaration(3851, 3850, "bool projectSplit");
insert TypeName(3852, 3851, "bool");
insert PrimitiveType(3853, 3852, "bool");
insert Identifier(3854, 3851, "projectSplit");
insert Expression(3855, 3850, "abi.decode(_splitData, (bool))");
insert CallExpression(3856, 3855, "abi.decode(_splitData, (bool))");
insert Expression(3857, 3856, "abi.decode");
insert MemberExpression(3858, 3857, "abi.decode");
insert Identifier(3859, 3858, "abi");
insert Identifier(3860, 3858, "decode");
insert CallArgument(3861, 3856, "_splitData");
insert Expression(3862, 3861, "_splitData");
insert Identifier(3863, 3862, "_splitData");
insert CallArgument(3864, 3856, "(bool)");
insert Expression(3865, 3864, "(bool)");
insert ParenthesizedExpression(3866, 3865, "(bool)");
insert Expression(3867, 3866, "bool");
insert PrimitiveType(3868, 3867, "bool");
insert Statement(3869, 3848, "if (!projectSplit) return _zapData;");
insert IfStatement(3870, 3869, "if (!projectSplit) return _zapData;");
insert Expression(3871, 3870, "!projectSplit");
insert UnaryExpression(3872, 3871, "!projectSplit");
insert Expression(3873, 3872, "projectSplit");
insert Identifier(3874, 3873, "projectSplit");
insert Statement(3875, 3870, "return _zapData;");
insert ReturnStatement(3876, 3875, "return _zapData;");
insert Expression(3877, 3876, "_zapData");
insert Identifier(3878, 3877, "_zapData");
insert Comment(3879, 3848, "// Create the project team split");
insert Statement(3880, 3848, "_zapData.projectTeamSplit = splitMain.createSplit(\n            _owners,\n            _percentAllocations,\n            distributorFee,\n            _zapData.safe\n        );");
insert ExpressionStatement(3881, 3880, "_zapData.projectTeamSplit = splitMain.createSplit(\n            _owners,\n            _percentAllocations,\n            distributorFee,\n            _zapData.safe\n        );");
insert Expression(3882, 3881, "_zapData.projectTeamSplit = splitMain.createSplit(\n            _owners,\n            _percentAllocations,\n            distributorFee,\n            _zapData.safe\n        )");
insert AssignmentExpression(3883, 3882, "_zapData.projectTeamSplit = splitMain.createSplit(\n            _owners,\n            _percentAllocations,\n            distributorFee,\n            _zapData.safe\n        )");
insert Expression(3884, 3883, "_zapData.projectTeamSplit");
insert MemberExpression(3885, 3884, "_zapData.projectTeamSplit");
insert Identifier(3886, 3885, "_zapData");
insert Identifier(3887, 3885, "projectTeamSplit");
insert Expression(3888, 3883, "splitMain.createSplit(\n            _owners,\n            _percentAllocations,\n            distributorFee,\n            _zapData.safe\n        )");
insert CallExpression(3889, 3888, "splitMain.createSplit(\n            _owners,\n            _percentAllocations,\n            distributorFee,\n            _zapData.safe\n        )");
insert Expression(3890, 3889, "splitMain.createSplit");
insert MemberExpression(3891, 3890, "splitMain.createSplit");
insert Identifier(3892, 3891, "splitMain");
insert Identifier(3893, 3891, "createSplit");
insert CallArgument(3894, 3889, "_owners");
insert Expression(3895, 3894, "_owners");
insert Identifier(3896, 3895, "_owners");
insert CallArgument(3897, 3889, "_percentAllocations");
insert Expression(3898, 3897, "_percentAllocations");
insert Identifier(3899, 3898, "_percentAllocations");
insert CallArgument(3900, 3889, "distributorFee");
insert Expression(3901, 3900, "distributorFee");
insert Identifier(3902, 3901, "distributorFee");
insert CallArgument(3903, 3889, "_zapData.safe");
insert Expression(3904, 3903, "_zapData.safe");
insert MemberExpression(3905, 3904, "_zapData.safe");
insert Identifier(3906, 3905, "_zapData");
insert Identifier(3907, 3905, "safe");
insert Statement(3908, 3848, "if (_zapData.projectTeamSplit == address(0))\n            revert ProjectTeamSplitNotCreated();");
insert IfStatement(3909, 3908, "if (_zapData.projectTeamSplit == address(0))\n            revert ProjectTeamSplitNotCreated();");
insert Expression(3910, 3909, "_zapData.projectTeamSplit == address(0)");
insert BinaryExpression(3911, 3910, "_zapData.projectTeamSplit == address(0)");
insert Expression(3912, 3911, "_zapData.projectTeamSplit");
insert MemberExpression(3913, 3912, "_zapData.projectTeamSplit");
insert Identifier(3914, 3913, "_zapData");
insert Identifier(3915, 3913, "projectTeamSplit");
insert Expression(3916, 3911, "address(0)");
insert TypeCastExpression(3917, 3916, "address(0)");
insert PrimitiveType(3918, 3917, "address");
insert CallArgument(3919, 3917, "0");
insert Expression(3920, 3919, "0");
insert NumberLiteral(3921, 3920, "0");
insert Statement(3922, 3909, "revert ProjectTeamSplitNotCreated();");
insert RevertStatement(3923, 3922, "revert ProjectTeamSplitNotCreated();");
insert Expression(3924, 3923, "ProjectTeamSplitNotCreated");
insert Identifier(3925, 3924, "ProjectTeamSplitNotCreated");
insert RevertArguments(3926, 3923, "()");
insert Statement(3927, 3848, "return _zapData;");
insert ReturnStatement(3928, 3927, "return _zapData;");
insert Expression(3929, 3928, "_zapData");
insert Identifier(3930, 3929, "_zapData");
insert Comment(3931, 3383, "/**\n     * @dev Internal function to handle escrow data.\n     * @param _escrowData The encoded data for escrow setup.\n     */");
insert FunctionDefinition(3932, 3383, "function _handleEscrowData(\n        bytes calldata _escrowData\n    ) internal pure returns (EscrowData memory) {\n        (\n            address client,\n            uint32 arbitration,\n            address resolver,\n            address token,\n            uint256 terminationTime,\n            uint256 _saltNonce,\n            bytes32 details\n        ) = abi.decode(\n                _escrowData,\n                (address, uint32, address, address, uint256, uint256, bytes32)\n            );\n\n        return\n            EscrowData({\n                client: client,\n                arbitration: uint8(arbitration),\n                resolver: resolver,\n                token: token,\n                terminationTime: terminationTime,\n                saltNonce: bytes32(_saltNonce),\n                details: details,\n                providerReceiver: address(0)\n            });\n    }");
insert Identifier(3933, 3932, "_handleEscrowData");
insert Parameter(3934, 3932, "bytes calldata _escrowData");
insert TypeName(3935, 3934, "bytes");
insert PrimitiveType(3936, 3935, "bytes");
insert Identifier(3937, 3934, "_escrowData");
insert Visibility(3938, 3932, "internal");
insert StateMutability(3939, 3932, "pure");
insert ReturnTypeDefinition(3940, 3932, "returns (EscrowData memory)");
insert Parameter(3941, 3940, "EscrowData memory");
insert TypeName(3942, 3941, "EscrowData");
insert UserDefinedType(3943, 3942, "EscrowData");
insert Identifier(3944, 3943, "EscrowData");
insert FunctionBody(3945, 3932, "{\n        (\n            address client,\n            uint32 arbitration,\n            address resolver,\n            address token,\n            uint256 terminationTime,\n            uint256 _saltNonce,\n            bytes32 details\n        ) = abi.decode(\n                _escrowData,\n                (address, uint32, address, address, uint256, uint256, bytes32)\n            );\n\n        return\n            EscrowData({\n                client: client,\n                arbitration: uint8(arbitration),\n                resolver: resolver,\n                token: token,\n                terminationTime: terminationTime,\n                saltNonce: bytes32(_saltNonce),\n                details: details,\n                providerReceiver: address(0)\n            });\n    }");
insert Statement(3946, 3945, "(\n            address client,\n            uint32 arbitration,\n            address resolver,\n            address token,\n            uint256 terminationTime,\n            uint256 _saltNonce,\n            bytes32 details\n        ) = abi.decode(\n                _escrowData,\n                (address, uint32, address, address, uint256, uint256, bytes32)\n            );");
insert VariableDeclarationStatement(3947, 3946, "(\n            address client,\n            uint32 arbitration,\n            address resolver,\n            address token,\n            uint256 terminationTime,\n            uint256 _saltNonce,\n            bytes32 details\n        ) = abi.decode(\n                _escrowData,\n                (address, uint32, address, address, uint256, uint256, bytes32)\n            );");
insert VariableDeclarationTuple(3948, 3947, "(\n            address client,\n            uint32 arbitration,\n            address resolver,\n            address token,\n            uint256 terminationTime,\n            uint256 _saltNonce,\n            bytes32 details\n        )");
insert VariableDeclaration(3949, 3948, "address client");
insert TypeName(3950, 3949, "address");
insert PrimitiveType(3951, 3950, "address");
insert Identifier(3952, 3949, "client");
insert VariableDeclaration(3953, 3948, "uint32 arbitration");
insert TypeName(3954, 3953, "uint32");
insert PrimitiveType(3955, 3954, "uint32");
insert Identifier(3956, 3953, "arbitration");
insert VariableDeclaration(3957, 3948, "address resolver");
insert TypeName(3958, 3957, "address");
insert PrimitiveType(3959, 3958, "address");
insert Identifier(3960, 3957, "resolver");
insert VariableDeclaration(3961, 3948, "address token");
insert TypeName(3962, 3961, "address");
insert PrimitiveType(3963, 3962, "address");
insert Identifier(3964, 3961, "token");
insert VariableDeclaration(3965, 3948, "uint256 terminationTime");
insert TypeName(3966, 3965, "uint256");
insert PrimitiveType(3967, 3966, "uint256");
insert Identifier(3968, 3965, "terminationTime");
insert VariableDeclaration(3969, 3948, "uint256 _saltNonce");
insert TypeName(3970, 3969, "uint256");
insert PrimitiveType(3971, 3970, "uint256");
insert Identifier(3972, 3969, "_saltNonce");
insert VariableDeclaration(3973, 3948, "bytes32 details");
insert TypeName(3974, 3973, "bytes32");
insert PrimitiveType(3975, 3974, "bytes32");
insert Identifier(3976, 3973, "details");
insert Expression(3977, 3947, "abi.decode(\n                _escrowData,\n                (address, uint32, address, address, uint256, uint256, bytes32)\n            )");
insert CallExpression(3978, 3977, "abi.decode(\n                _escrowData,\n                (address, uint32, address, address, uint256, uint256, bytes32)\n            )");
insert Expression(3979, 3978, "abi.decode");
insert MemberExpression(3980, 3979, "abi.decode");
insert Identifier(3981, 3980, "abi");
insert Identifier(3982, 3980, "decode");
insert CallArgument(3983, 3978, "_escrowData");
insert Expression(3984, 3983, "_escrowData");
insert Identifier(3985, 3984, "_escrowData");
insert CallArgument(3986, 3978, "(address, uint32, address, address, uint256, uint256, bytes32)");
insert Expression(3987, 3986, "(address, uint32, address, address, uint256, uint256, bytes32)");
insert TupleExpression(3988, 3987, "(address, uint32, address, address, uint256, uint256, bytes32)");
insert Expression(3989, 3988, "address");
insert PrimitiveType(3990, 3989, "address");
insert Expression(3991, 3988, "uint32");
insert PrimitiveType(3992, 3991, "uint32");
insert Expression(3993, 3988, "address");
insert PrimitiveType(3994, 3993, "address");
insert Expression(3995, 3988, "address");
insert PrimitiveType(3996, 3995, "address");
insert Expression(3997, 3988, "uint256");
insert PrimitiveType(3998, 3997, "uint256");
insert Expression(3999, 3988, "uint256");
insert PrimitiveType(4000, 3999, "uint256");
insert Expression(4001, 3988, "bytes32");
insert PrimitiveType(4002, 4001, "bytes32");
insert Statement(4003, 3945, "return\n            EscrowData({\n                client: client,\n                arbitration: uint8(arbitration),\n                resolver: resolver,\n                token: token,\n                terminationTime: terminationTime,\n                saltNonce: bytes32(_saltNonce),\n                details: details,\n                providerReceiver: address(0)\n            });");
insert ReturnStatement(4004, 4003, "return\n            EscrowData({\n                client: client,\n                arbitration: uint8(arbitration),\n                resolver: resolver,\n                token: token,\n                terminationTime: terminationTime,\n                saltNonce: bytes32(_saltNonce),\n                details: details,\n                providerReceiver: address(0)\n            });");
insert Expression(4005, 4004, "EscrowData({\n                client: client,\n                arbitration: uint8(arbitration),\n                resolver: resolver,\n                token: token,\n                terminationTime: terminationTime,\n                saltNonce: bytes32(_saltNonce),\n                details: details,\n                providerReceiver: address(0)\n            })");
insert CallExpression(4006, 4005, "EscrowData({\n                client: client,\n                arbitration: uint8(arbitration),\n                resolver: resolver,\n                token: token,\n                terminationTime: terminationTime,\n                saltNonce: bytes32(_saltNonce),\n                details: details,\n                providerReceiver: address(0)\n            })");
insert Expression(4007, 4006, "EscrowData");
insert Identifier(4008, 4007, "EscrowData");
insert CallArgument(4009, 4006, "{\n                client: client,\n                arbitration: uint8(arbitration),\n                resolver: resolver,\n                token: token,\n                terminationTime: terminationTime,\n                saltNonce: bytes32(_saltNonce),\n                details: details,\n                providerReceiver: address(0)\n            }");
insert CallStructArgument(4010, 4009, "client: client");
insert Identifier(4011, 4010, "client");
insert Expression(4012, 4010, "client");
insert Identifier(4013, 4012, "client");
insert CallStructArgument(4014, 4009, "arbitration: uint8(arbitration)");
insert Identifier(4015, 4014, "arbitration");
insert Expression(4016, 4014, "uint8(arbitration)");
insert TypeCastExpression(4017, 4016, "uint8(arbitration)");
insert PrimitiveType(4018, 4017, "uint8");
insert CallArgument(4019, 4017, "arbitration");
insert Expression(4020, 4019, "arbitration");
insert Identifier(4021, 4020, "arbitration");
insert CallStructArgument(4022, 4009, "resolver: resolver");
insert Identifier(4023, 4022, "resolver");
insert Expression(4024, 4022, "resolver");
insert Identifier(4025, 4024, "resolver");
insert CallStructArgument(4026, 4009, "token: token");
insert Identifier(4027, 4026, "token");
insert Expression(4028, 4026, "token");
insert Identifier(4029, 4028, "token");
insert CallStructArgument(4030, 4009, "terminationTime: terminationTime");
insert Identifier(4031, 4030, "terminationTime");
insert Expression(4032, 4030, "terminationTime");
insert Identifier(4033, 4032, "terminationTime");
insert CallStructArgument(4034, 4009, "saltNonce: bytes32(_saltNonce)");
insert Identifier(4035, 4034, "saltNonce");
insert Expression(4036, 4034, "bytes32(_saltNonce)");
insert TypeCastExpression(4037, 4036, "bytes32(_saltNonce)");
insert PrimitiveType(4038, 4037, "bytes32");
insert CallArgument(4039, 4037, "_saltNonce");
insert Expression(4040, 4039, "_saltNonce");
insert Identifier(4041, 4040, "_saltNonce");
insert CallStructArgument(4042, 4009, "details: details");
insert Identifier(4043, 4042, "details");
insert Expression(4044, 4042, "details");
insert Identifier(4045, 4044, "details");
insert CallStructArgument(4046, 4009, "providerReceiver: address(0)");
insert Identifier(4047, 4046, "providerReceiver");
insert Expression(4048, 4046, "address(0)");
insert TypeCastExpression(4049, 4048, "address(0)");
insert PrimitiveType(4050, 4049, "address");
insert CallArgument(4051, 4049, "0");
insert Expression(4052, 4051, "0");
insert NumberLiteral(4053, 4052, "0");
insert Comment(4054, 3383, "/**\n     * @dev Internal function to deploy a new Escrow with the provided details.\n     * @param _milestoneAmounts The milestone amounts for the escrow.\n     * @param _escrowData The encoded data for escrow setup.\n     * @param _escrowParams The parameters required for escrow deployment.\n     * @param _zapData The data struct for storing deployment results.\n     */");
insert FunctionDefinition(4055, 3383, "function _deployEscrow(\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _escrowData,\n        address[] memory _escrowParams,\n        ZapData memory _zapData\n    ) internal returns (ZapData memory) {\n        EscrowData memory escrowData = _handleEscrowData(_escrowData);\n\n        // Encode data for escrow setup\n        bytes memory escrowDetails = abi.encode(\n            escrowData.client,\n            escrowData.arbitration,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            false, // requireVerification\n            address(escrowFactory), // factory address\n            _escrowParams[1] // providerReceiver\n        );\n\n        // Deploy the escrow\n        _zapData.escrow = escrowFactory.createDeterministic(\n            _escrowParams[0], // provider\n            _milestoneAmounts, // milestoneAmounts\n            escrowDetails,\n            bytes32(\"updatable\"),\n            escrowData.saltNonce\n        );\n        if (_zapData.escrow == address(0)) revert EscrowNotCreated();\n\n        return _zapData;\n    }");
insert Identifier(4056, 4055, "_deployEscrow");
insert Parameter(4057, 4055, "uint256[] memory _milestoneAmounts");
insert TypeName(4058, 4057, "uint256[]");
insert TypeName(4059, 4058, "uint256");
insert PrimitiveType(4060, 4059, "uint256");
insert Identifier(4061, 4057, "_milestoneAmounts");
insert Parameter(4062, 4055, "bytes calldata _escrowData");
insert TypeName(4063, 4062, "bytes");
insert PrimitiveType(4064, 4063, "bytes");
insert Identifier(4065, 4062, "_escrowData");
insert Parameter(4066, 4055, "address[] memory _escrowParams");
insert TypeName(4067, 4066, "address[]");
insert TypeName(4068, 4067, "address");
insert PrimitiveType(4069, 4068, "address");
insert Identifier(4070, 4066, "_escrowParams");
insert Parameter(4071, 4055, "ZapData memory _zapData");
insert TypeName(4072, 4071, "ZapData");
insert UserDefinedType(4073, 4072, "ZapData");
insert Identifier(4074, 4073, "ZapData");
insert Identifier(4075, 4071, "_zapData");
insert Visibility(4076, 4055, "internal");
insert ReturnTypeDefinition(4077, 4055, "returns (ZapData memory)");
insert Parameter(4078, 4077, "ZapData memory");
insert TypeName(4079, 4078, "ZapData");
insert UserDefinedType(4080, 4079, "ZapData");
insert Identifier(4081, 4080, "ZapData");
insert FunctionBody(4082, 4055, "{\n        EscrowData memory escrowData = _handleEscrowData(_escrowData);\n\n        // Encode data for escrow setup\n        bytes memory escrowDetails = abi.encode(\n            escrowData.client,\n            escrowData.arbitration,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            false, // requireVerification\n            address(escrowFactory), // factory address\n            _escrowParams[1] // providerReceiver\n        );\n\n        // Deploy the escrow\n        _zapData.escrow = escrowFactory.createDeterministic(\n            _escrowParams[0], // provider\n            _milestoneAmounts, // milestoneAmounts\n            escrowDetails,\n            bytes32(\"updatable\"),\n            escrowData.saltNonce\n        );\n        if (_zapData.escrow == address(0)) revert EscrowNotCreated();\n\n        return _zapData;\n    }");
insert Statement(4083, 4082, "EscrowData memory escrowData = _handleEscrowData(_escrowData);");
insert VariableDeclarationStatement(4084, 4083, "EscrowData memory escrowData = _handleEscrowData(_escrowData);");
insert VariableDeclaration(4085, 4084, "EscrowData memory escrowData");
insert TypeName(4086, 4085, "EscrowData");
insert UserDefinedType(4087, 4086, "EscrowData");
insert Identifier(4088, 4087, "EscrowData");
insert Identifier(4089, 4085, "escrowData");
insert Expression(4090, 4084, "_handleEscrowData(_escrowData)");
insert CallExpression(4091, 4090, "_handleEscrowData(_escrowData)");
insert Expression(4092, 4091, "_handleEscrowData");
insert Identifier(4093, 4092, "_handleEscrowData");
insert CallArgument(4094, 4091, "_escrowData");
insert Expression(4095, 4094, "_escrowData");
insert Identifier(4096, 4095, "_escrowData");
insert Comment(4097, 4082, "// Encode data for escrow setup");
insert Statement(4098, 4082, "bytes memory escrowDetails = abi.encode(\n            escrowData.client,\n            escrowData.arbitration,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            false, // requireVerification\n            address(escrowFactory), // factory address\n            _escrowParams[1] // providerReceiver\n        );");
insert VariableDeclarationStatement(4099, 4098, "bytes memory escrowDetails = abi.encode(\n            escrowData.client,\n            escrowData.arbitration,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            false, // requireVerification\n            address(escrowFactory), // factory address\n            _escrowParams[1] // providerReceiver\n        );");
insert VariableDeclaration(4100, 4099, "bytes memory escrowDetails");
insert TypeName(4101, 4100, "bytes");
insert PrimitiveType(4102, 4101, "bytes");
insert Identifier(4103, 4100, "escrowDetails");
insert Expression(4104, 4099, "abi.encode(\n            escrowData.client,\n            escrowData.arbitration,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            false, // requireVerification\n            address(escrowFactory), // factory address\n            _escrowParams[1] // providerReceiver\n        )");
insert CallExpression(4105, 4104, "abi.encode(\n            escrowData.client,\n            escrowData.arbitration,\n            escrowData.resolver,\n            escrowData.token,\n            escrowData.terminationTime,\n            escrowData.details,\n            wrappedNativeToken,\n            false, // requireVerification\n            address(escrowFactory), // factory address\n            _escrowParams[1] // providerReceiver\n        )");
insert Expression(4106, 4105, "abi.encode");
insert MemberExpression(4107, 4106, "abi.encode");
insert Identifier(4108, 4107, "abi");
insert Identifier(4109, 4107, "encode");
insert CallArgument(4110, 4105, "escrowData.client");
insert Expression(4111, 4110, "escrowData.client");
insert MemberExpression(4112, 4111, "escrowData.client");
insert Identifier(4113, 4112, "escrowData");
insert Identifier(4114, 4112, "client");
insert CallArgument(4115, 4105, "escrowData.arbitration");
insert Expression(4116, 4115, "escrowData.arbitration");
insert MemberExpression(4117, 4116, "escrowData.arbitration");
insert Identifier(4118, 4117, "escrowData");
insert Identifier(4119, 4117, "arbitration");
insert CallArgument(4120, 4105, "escrowData.resolver");
insert Expression(4121, 4120, "escrowData.resolver");
insert MemberExpression(4122, 4121, "escrowData.resolver");
insert Identifier(4123, 4122, "escrowData");
insert Identifier(4124, 4122, "resolver");
insert CallArgument(4125, 4105, "escrowData.token");
insert Expression(4126, 4125, "escrowData.token");
insert MemberExpression(4127, 4126, "escrowData.token");
insert Identifier(4128, 4127, "escrowData");
insert Identifier(4129, 4127, "token");
insert CallArgument(4130, 4105, "escrowData.terminationTime");
insert Expression(4131, 4130, "escrowData.terminationTime");
insert MemberExpression(4132, 4131, "escrowData.terminationTime");
insert Identifier(4133, 4132, "escrowData");
insert Identifier(4134, 4132, "terminationTime");
insert CallArgument(4135, 4105, "escrowData.details");
insert Expression(4136, 4135, "escrowData.details");
insert MemberExpression(4137, 4136, "escrowData.details");
insert Identifier(4138, 4137, "escrowData");
insert Identifier(4139, 4137, "details");
insert CallArgument(4140, 4105, "wrappedNativeToken");
insert Expression(4141, 4140, "wrappedNativeToken");
insert Identifier(4142, 4141, "wrappedNativeToken");
insert CallArgument(4143, 4105, "false");
insert Expression(4144, 4143, "false");
insert BooleanLiteral(4145, 4144, "false");
insert False(4146, 4145, "false");
insert Comment(4147, 4105, "// requireVerification");
insert CallArgument(4148, 4105, "address(escrowFactory)");
insert Expression(4149, 4148, "address(escrowFactory)");
insert TypeCastExpression(4150, 4149, "address(escrowFactory)");
insert PrimitiveType(4151, 4150, "address");
insert CallArgument(4152, 4150, "escrowFactory");
insert Expression(4153, 4152, "escrowFactory");
insert Identifier(4154, 4153, "escrowFactory");
insert Comment(4155, 4105, "// factory address");
insert CallArgument(4156, 4105, "_escrowParams[1]");
insert Expression(4157, 4156, "_escrowParams[1]");
insert ArrayAccess(4158, 4157, "_escrowParams[1]");
insert Expression(4159, 4158, "_escrowParams");
insert Identifier(4160, 4159, "_escrowParams");
insert Expression(4161, 4158, "1");
insert NumberLiteral(4162, 4161, "1");
insert Comment(4163, 4105, "// providerReceiver");
insert Comment(4164, 4082, "// Deploy the escrow");
insert Statement(4165, 4082, "_zapData.escrow = escrowFactory.createDeterministic(\n            _escrowParams[0], // provider\n            _milestoneAmounts, // milestoneAmounts\n            escrowDetails,\n            bytes32(\"updatable\"),\n            escrowData.saltNonce\n        );");
insert ExpressionStatement(4166, 4165, "_zapData.escrow = escrowFactory.createDeterministic(\n            _escrowParams[0], // provider\n            _milestoneAmounts, // milestoneAmounts\n            escrowDetails,\n            bytes32(\"updatable\"),\n            escrowData.saltNonce\n        );");
insert Expression(4167, 4166, "_zapData.escrow = escrowFactory.createDeterministic(\n            _escrowParams[0], // provider\n            _milestoneAmounts, // milestoneAmounts\n            escrowDetails,\n            bytes32(\"updatable\"),\n            escrowData.saltNonce\n        )");
insert AssignmentExpression(4168, 4167, "_zapData.escrow = escrowFactory.createDeterministic(\n            _escrowParams[0], // provider\n            _milestoneAmounts, // milestoneAmounts\n            escrowDetails,\n            bytes32(\"updatable\"),\n            escrowData.saltNonce\n        )");
insert Expression(4169, 4168, "_zapData.escrow");
insert MemberExpression(4170, 4169, "_zapData.escrow");
insert Identifier(4171, 4170, "_zapData");
insert Identifier(4172, 4170, "escrow");
insert Expression(4173, 4168, "escrowFactory.createDeterministic(\n            _escrowParams[0], // provider\n            _milestoneAmounts, // milestoneAmounts\n            escrowDetails,\n            bytes32(\"updatable\"),\n            escrowData.saltNonce\n        )");
insert CallExpression(4174, 4173, "escrowFactory.createDeterministic(\n            _escrowParams[0], // provider\n            _milestoneAmounts, // milestoneAmounts\n            escrowDetails,\n            bytes32(\"updatable\"),\n            escrowData.saltNonce\n        )");
insert Expression(4175, 4174, "escrowFactory.createDeterministic");
insert MemberExpression(4176, 4175, "escrowFactory.createDeterministic");
insert Identifier(4177, 4176, "escrowFactory");
insert Identifier(4178, 4176, "createDeterministic");
insert CallArgument(4179, 4174, "_escrowParams[0]");
insert Expression(4180, 4179, "_escrowParams[0]");
insert ArrayAccess(4181, 4180, "_escrowParams[0]");
insert Expression(4182, 4181, "_escrowParams");
insert Identifier(4183, 4182, "_escrowParams");
insert Expression(4184, 4181, "0");
insert NumberLiteral(4185, 4184, "0");
insert Comment(4186, 4174, "// provider");
insert CallArgument(4187, 4174, "_milestoneAmounts");
insert Expression(4188, 4187, "_milestoneAmounts");
insert Identifier(4189, 4188, "_milestoneAmounts");
insert Comment(4190, 4174, "// milestoneAmounts");
insert CallArgument(4191, 4174, "escrowDetails");
insert Expression(4192, 4191, "escrowDetails");
insert Identifier(4193, 4192, "escrowDetails");
insert CallArgument(4194, 4174, "bytes32(\"updatable\")");
insert Expression(4195, 4194, "bytes32(\"updatable\")");
insert TypeCastExpression(4196, 4195, "bytes32(\"updatable\")");
insert PrimitiveType(4197, 4196, "bytes32");
insert CallArgument(4198, 4196, "\"updatable\"");
insert Expression(4199, 4198, "\"updatable\"");
insert StringLiteral(4200, 4199, "\"updatable\"");
insert CallArgument(4201, 4174, "escrowData.saltNonce");
insert Expression(4202, 4201, "escrowData.saltNonce");
insert MemberExpression(4203, 4202, "escrowData.saltNonce");
insert Identifier(4204, 4203, "escrowData");
insert Identifier(4205, 4203, "saltNonce");
insert Statement(4206, 4082, "if (_zapData.escrow == address(0)) revert EscrowNotCreated();");
insert IfStatement(4207, 4206, "if (_zapData.escrow == address(0)) revert EscrowNotCreated();");
insert Expression(4208, 4207, "_zapData.escrow == address(0)");
insert BinaryExpression(4209, 4208, "_zapData.escrow == address(0)");
insert Expression(4210, 4209, "_zapData.escrow");
insert MemberExpression(4211, 4210, "_zapData.escrow");
insert Identifier(4212, 4211, "_zapData");
insert Identifier(4213, 4211, "escrow");
insert Expression(4214, 4209, "address(0)");
insert TypeCastExpression(4215, 4214, "address(0)");
insert PrimitiveType(4216, 4215, "address");
insert CallArgument(4217, 4215, "0");
insert Expression(4218, 4217, "0");
insert NumberLiteral(4219, 4218, "0");
insert Statement(4220, 4207, "revert EscrowNotCreated();");
insert RevertStatement(4221, 4220, "revert EscrowNotCreated();");
insert Expression(4222, 4221, "EscrowNotCreated");
insert Identifier(4223, 4222, "EscrowNotCreated");
insert RevertArguments(4224, 4221, "()");
insert Statement(4225, 4082, "return _zapData;");
insert ReturnStatement(4226, 4225, "return _zapData;");
insert Expression(4227, 4226, "_zapData");
insert Identifier(4228, 4227, "_zapData");
insert Comment(4229, 3383, "/**\n     * @dev Internal function to handle escrow parameters.\n     * @param _zapData The data struct for storing deployment results.\n     */");
insert FunctionDefinition(4230, 3383, "function _handleEscrowParams(\n        ZapData memory _zapData\n    ) internal pure returns (address[] memory) {\n        address[] memory escrowParams = new address[](2);\n        escrowParams[0] = _zapData.safe;\n        escrowParams[1] = _zapData.projectTeamSplit != address(0)\n            ? _zapData.projectTeamSplit\n            : _zapData.safe;\n        return escrowParams;\n    }");
insert Identifier(4231, 4230, "_handleEscrowParams");
insert Parameter(4232, 4230, "ZapData memory _zapData");
insert TypeName(4233, 4232, "ZapData");
insert UserDefinedType(4234, 4233, "ZapData");
insert Identifier(4235, 4234, "ZapData");
insert Identifier(4236, 4232, "_zapData");
insert Visibility(4237, 4230, "internal");
insert StateMutability(4238, 4230, "pure");
insert ReturnTypeDefinition(4239, 4230, "returns (address[] memory)");
insert Parameter(4240, 4239, "address[] memory");
insert TypeName(4241, 4240, "address[]");
insert TypeName(4242, 4241, "address");
insert PrimitiveType(4243, 4242, "address");
insert FunctionBody(4244, 4230, "{\n        address[] memory escrowParams = new address[](2);\n        escrowParams[0] = _zapData.safe;\n        escrowParams[1] = _zapData.projectTeamSplit != address(0)\n            ? _zapData.projectTeamSplit\n            : _zapData.safe;\n        return escrowParams;\n    }");
insert Statement(4245, 4244, "address[] memory escrowParams = new address[](2);");
insert VariableDeclarationStatement(4246, 4245, "address[] memory escrowParams = new address[](2);");
insert VariableDeclaration(4247, 4246, "address[] memory escrowParams");
insert TypeName(4248, 4247, "address[]");
insert TypeName(4249, 4248, "address");
insert PrimitiveType(4250, 4249, "address");
insert Identifier(4251, 4247, "escrowParams");
insert Expression(4252, 4246, "new address[](2)");
insert CallExpression(4253, 4252, "new address[](2)");
insert Expression(4254, 4253, "new address[]");
insert NewExpression(4255, 4254, "new address[]");
insert TypeName(4256, 4255, "address[]");
insert TypeName(4257, 4256, "address");
insert PrimitiveType(4258, 4257, "address");
insert CallArgument(4259, 4253, "2");
insert Expression(4260, 4259, "2");
insert NumberLiteral(4261, 4260, "2");
insert Statement(4262, 4244, "escrowParams[0] = _zapData.safe;");
insert ExpressionStatement(4263, 4262, "escrowParams[0] = _zapData.safe;");
insert Expression(4264, 4263, "escrowParams[0] = _zapData.safe");
insert AssignmentExpression(4265, 4264, "escrowParams[0] = _zapData.safe");
insert Expression(4266, 4265, "escrowParams[0]");
insert ArrayAccess(4267, 4266, "escrowParams[0]");
insert Expression(4268, 4267, "escrowParams");
insert Identifier(4269, 4268, "escrowParams");
insert Expression(4270, 4267, "0");
insert NumberLiteral(4271, 4270, "0");
insert Expression(4272, 4265, "_zapData.safe");
insert MemberExpression(4273, 4272, "_zapData.safe");
insert Identifier(4274, 4273, "_zapData");
insert Identifier(4275, 4273, "safe");
insert Statement(4276, 4244, "escrowParams[1] = _zapData.projectTeamSplit != address(0)\n            ? _zapData.projectTeamSplit\n            : _zapData.safe;");
insert ExpressionStatement(4277, 4276, "escrowParams[1] = _zapData.projectTeamSplit != address(0)\n            ? _zapData.projectTeamSplit\n            : _zapData.safe;");
insert Expression(4278, 4277, "escrowParams[1] = _zapData.projectTeamSplit != address(0)\n            ? _zapData.projectTeamSplit\n            : _zapData.safe");
insert AssignmentExpression(4279, 4278, "escrowParams[1] = _zapData.projectTeamSplit != address(0)\n            ? _zapData.projectTeamSplit\n            : _zapData.safe");
insert Expression(4280, 4279, "escrowParams[1]");
insert ArrayAccess(4281, 4280, "escrowParams[1]");
insert Expression(4282, 4281, "escrowParams");
insert Identifier(4283, 4282, "escrowParams");
insert Expression(4284, 4281, "1");
insert NumberLiteral(4285, 4284, "1");
insert Expression(4286, 4279, "_zapData.projectTeamSplit != address(0)\n            ? _zapData.projectTeamSplit\n            : _zapData.safe");
insert TernaryExpression(4287, 4286, "_zapData.projectTeamSplit != address(0)\n            ? _zapData.projectTeamSplit\n            : _zapData.safe");
insert Expression(4288, 4287, "_zapData.projectTeamSplit != address(0)");
insert BinaryExpression(4289, 4288, "_zapData.projectTeamSplit != address(0)");
insert Expression(4290, 4289, "_zapData.projectTeamSplit");
insert MemberExpression(4291, 4290, "_zapData.projectTeamSplit");
insert Identifier(4292, 4291, "_zapData");
insert Identifier(4293, 4291, "projectTeamSplit");
insert Expression(4294, 4289, "address(0)");
insert TypeCastExpression(4295, 4294, "address(0)");
insert PrimitiveType(4296, 4295, "address");
insert CallArgument(4297, 4295, "0");
insert Expression(4298, 4297, "0");
insert NumberLiteral(4299, 4298, "0");
insert Expression(4300, 4287, "_zapData.projectTeamSplit");
insert MemberExpression(4301, 4300, "_zapData.projectTeamSplit");
insert Identifier(4302, 4301, "_zapData");
insert Identifier(4303, 4301, "projectTeamSplit");
insert Expression(4304, 4287, "_zapData.safe");
insert MemberExpression(4305, 4304, "_zapData.safe");
insert Identifier(4306, 4305, "_zapData");
insert Identifier(4307, 4305, "safe");
insert Statement(4308, 4244, "return escrowParams;");
insert ReturnStatement(4309, 4308, "return escrowParams;");
insert Expression(4310, 4309, "escrowParams");
insert Identifier(4311, 4310, "escrowParams");
insert Comment(4312, 3383, "/**\n     * @dev Internal function to create a new Safe, Split, and Escrow.\n     * @param _owners The list of owners for the Safe and Split.\n     * @param _percentAllocations The percent allocations for the Split.\n     * @param _milestoneAmounts The milestone amounts for the Escrow.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitData The encoded data for Split setup.\n     * @param _escrowData The encoded data for Escrow setup.\n     */");
insert FunctionDefinition(4313, 3383, "function _createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitData,\n        bytes calldata _escrowData\n    ) internal virtual {\n        ZapData memory zapData = ZapData({\n            safe: _safeAddress,\n            projectTeamSplit: address(0),\n            escrow: address(0)\n        });\n\n        if (zapData.safe == address(0)) {\n            zapData = _deploySafe(_owners, _safeData, zapData);\n        }\n\n        zapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitData,\n            zapData\n        );\n\n        address[] memory escrowParams = _handleEscrowParams(zapData);\n\n        zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            zapData\n        );\n\n        emit SafeSplitsEscrowCreated(\n            zapData.safe,\n            zapData.projectTeamSplit,\n            zapData.escrow\n        );\n    }");
insert Identifier(4314, 4313, "_createSafeSplitEscrow");
insert Parameter(4315, 4313, "address[] memory _owners");
insert TypeName(4316, 4315, "address[]");
insert TypeName(4317, 4316, "address");
insert PrimitiveType(4318, 4317, "address");
insert Identifier(4319, 4315, "_owners");
insert Parameter(4320, 4313, "uint32[] memory _percentAllocations");
insert TypeName(4321, 4320, "uint32[]");
insert TypeName(4322, 4321, "uint32");
insert PrimitiveType(4323, 4322, "uint32");
insert Identifier(4324, 4320, "_percentAllocations");
insert Parameter(4325, 4313, "uint256[] memory _milestoneAmounts");
insert TypeName(4326, 4325, "uint256[]");
insert TypeName(4327, 4326, "uint256");
insert PrimitiveType(4328, 4327, "uint256");
insert Identifier(4329, 4325, "_milestoneAmounts");
insert Parameter(4330, 4313, "bytes calldata _safeData");
insert TypeName(4331, 4330, "bytes");
insert PrimitiveType(4332, 4331, "bytes");
insert Identifier(4333, 4330, "_safeData");
insert Parameter(4334, 4313, "address _safeAddress");
insert TypeName(4335, 4334, "address");
insert PrimitiveType(4336, 4335, "address");
insert Identifier(4337, 4334, "_safeAddress");
insert Parameter(4338, 4313, "bytes calldata _splitData");
insert TypeName(4339, 4338, "bytes");
insert PrimitiveType(4340, 4339, "bytes");
insert Identifier(4341, 4338, "_splitData");
insert Parameter(4342, 4313, "bytes calldata _escrowData");
insert TypeName(4343, 4342, "bytes");
insert PrimitiveType(4344, 4343, "bytes");
insert Identifier(4345, 4342, "_escrowData");
insert Visibility(4346, 4313, "internal");
insert Virtual(4347, 4313, "virtual");
insert FunctionBody(4348, 4313, "{\n        ZapData memory zapData = ZapData({\n            safe: _safeAddress,\n            projectTeamSplit: address(0),\n            escrow: address(0)\n        });\n\n        if (zapData.safe == address(0)) {\n            zapData = _deploySafe(_owners, _safeData, zapData);\n        }\n\n        zapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitData,\n            zapData\n        );\n\n        address[] memory escrowParams = _handleEscrowParams(zapData);\n\n        zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            zapData\n        );\n\n        emit SafeSplitsEscrowCreated(\n            zapData.safe,\n            zapData.projectTeamSplit,\n            zapData.escrow\n        );\n    }");
insert Statement(4349, 4348, "ZapData memory zapData = ZapData({\n            safe: _safeAddress,\n            projectTeamSplit: address(0),\n            escrow: address(0)\n        });");
insert VariableDeclarationStatement(4350, 4349, "ZapData memory zapData = ZapData({\n            safe: _safeAddress,\n            projectTeamSplit: address(0),\n            escrow: address(0)\n        });");
insert VariableDeclaration(4351, 4350, "ZapData memory zapData");
insert TypeName(4352, 4351, "ZapData");
insert UserDefinedType(4353, 4352, "ZapData");
insert Identifier(4354, 4353, "ZapData");
insert Identifier(4355, 4351, "zapData");
insert Expression(4356, 4350, "ZapData({\n            safe: _safeAddress,\n            projectTeamSplit: address(0),\n            escrow: address(0)\n        })");
insert CallExpression(4357, 4356, "ZapData({\n            safe: _safeAddress,\n            projectTeamSplit: address(0),\n            escrow: address(0)\n        })");
insert Expression(4358, 4357, "ZapData");
insert Identifier(4359, 4358, "ZapData");
insert CallArgument(4360, 4357, "{\n            safe: _safeAddress,\n            projectTeamSplit: address(0),\n            escrow: address(0)\n        }");
insert CallStructArgument(4361, 4360, "safe: _safeAddress");
insert Identifier(4362, 4361, "safe");
insert Expression(4363, 4361, "_safeAddress");
insert Identifier(4364, 4363, "_safeAddress");
insert CallStructArgument(4365, 4360, "projectTeamSplit: address(0)");
insert Identifier(4366, 4365, "projectTeamSplit");
insert Expression(4367, 4365, "address(0)");
insert TypeCastExpression(4368, 4367, "address(0)");
insert PrimitiveType(4369, 4368, "address");
insert CallArgument(4370, 4368, "0");
insert Expression(4371, 4370, "0");
insert NumberLiteral(4372, 4371, "0");
insert CallStructArgument(4373, 4360, "escrow: address(0)");
insert Identifier(4374, 4373, "escrow");
insert Expression(4375, 4373, "address(0)");
insert TypeCastExpression(4376, 4375, "address(0)");
insert PrimitiveType(4377, 4376, "address");
insert CallArgument(4378, 4376, "0");
insert Expression(4379, 4378, "0");
insert NumberLiteral(4380, 4379, "0");
insert Statement(4381, 4348, "if (zapData.safe == address(0)) {\n            zapData = _deploySafe(_owners, _safeData, zapData);\n        }");
insert IfStatement(4382, 4381, "if (zapData.safe == address(0)) {\n            zapData = _deploySafe(_owners, _safeData, zapData);\n        }");
insert Expression(4383, 4382, "zapData.safe == address(0)");
insert BinaryExpression(4384, 4383, "zapData.safe == address(0)");
insert Expression(4385, 4384, "zapData.safe");
insert MemberExpression(4386, 4385, "zapData.safe");
insert Identifier(4387, 4386, "zapData");
insert Identifier(4388, 4386, "safe");
insert Expression(4389, 4384, "address(0)");
insert TypeCastExpression(4390, 4389, "address(0)");
insert PrimitiveType(4391, 4390, "address");
insert CallArgument(4392, 4390, "0");
insert Expression(4393, 4392, "0");
insert NumberLiteral(4394, 4393, "0");
insert Statement(4395, 4382, "{\n            zapData = _deploySafe(_owners, _safeData, zapData);\n        }");
insert BlockStatement(4396, 4395, "{\n            zapData = _deploySafe(_owners, _safeData, zapData);\n        }");
insert Statement(4397, 4396, "zapData = _deploySafe(_owners, _safeData, zapData);");
insert ExpressionStatement(4398, 4397, "zapData = _deploySafe(_owners, _safeData, zapData);");
insert Expression(4399, 4398, "zapData = _deploySafe(_owners, _safeData, zapData)");
insert AssignmentExpression(4400, 4399, "zapData = _deploySafe(_owners, _safeData, zapData)");
insert Expression(4401, 4400, "zapData");
insert Identifier(4402, 4401, "zapData");
insert Expression(4403, 4400, "_deploySafe(_owners, _safeData, zapData)");
insert CallExpression(4404, 4403, "_deploySafe(_owners, _safeData, zapData)");
insert Expression(4405, 4404, "_deploySafe");
insert Identifier(4406, 4405, "_deploySafe");
insert CallArgument(4407, 4404, "_owners");
insert Expression(4408, 4407, "_owners");
insert Identifier(4409, 4408, "_owners");
insert CallArgument(4410, 4404, "_safeData");
insert Expression(4411, 4410, "_safeData");
insert Identifier(4412, 4411, "_safeData");
insert CallArgument(4413, 4404, "zapData");
insert Expression(4414, 4413, "zapData");
insert Identifier(4415, 4414, "zapData");
insert Statement(4416, 4348, "zapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitData,\n            zapData\n        );");
insert ExpressionStatement(4417, 4416, "zapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitData,\n            zapData\n        );");
insert Expression(4418, 4417, "zapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitData,\n            zapData\n        )");
insert AssignmentExpression(4419, 4418, "zapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitData,\n            zapData\n        )");
insert Expression(4420, 4419, "zapData");
insert Identifier(4421, 4420, "zapData");
insert Expression(4422, 4419, "_createSplit(\n            _owners,\n            _percentAllocations,\n            _splitData,\n            zapData\n        )");
insert CallExpression(4423, 4422, "_createSplit(\n            _owners,\n            _percentAllocations,\n            _splitData,\n            zapData\n        )");
insert Expression(4424, 4423, "_createSplit");
insert Identifier(4425, 4424, "_createSplit");
insert CallArgument(4426, 4423, "_owners");
insert Expression(4427, 4426, "_owners");
insert Identifier(4428, 4427, "_owners");
insert CallArgument(4429, 4423, "_percentAllocations");
insert Expression(4430, 4429, "_percentAllocations");
insert Identifier(4431, 4430, "_percentAllocations");
insert CallArgument(4432, 4423, "_splitData");
insert Expression(4433, 4432, "_splitData");
insert Identifier(4434, 4433, "_splitData");
insert CallArgument(4435, 4423, "zapData");
insert Expression(4436, 4435, "zapData");
insert Identifier(4437, 4436, "zapData");
insert Statement(4438, 4348, "address[] memory escrowParams = _handleEscrowParams(zapData);");
insert VariableDeclarationStatement(4439, 4438, "address[] memory escrowParams = _handleEscrowParams(zapData);");
insert VariableDeclaration(4440, 4439, "address[] memory escrowParams");
insert TypeName(4441, 4440, "address[]");
insert TypeName(4442, 4441, "address");
insert PrimitiveType(4443, 4442, "address");
insert Identifier(4444, 4440, "escrowParams");
insert Expression(4445, 4439, "_handleEscrowParams(zapData)");
insert CallExpression(4446, 4445, "_handleEscrowParams(zapData)");
insert Expression(4447, 4446, "_handleEscrowParams");
insert Identifier(4448, 4447, "_handleEscrowParams");
insert CallArgument(4449, 4446, "zapData");
insert Expression(4450, 4449, "zapData");
insert Identifier(4451, 4450, "zapData");
insert Statement(4452, 4348, "zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            zapData\n        );");
insert ExpressionStatement(4453, 4452, "zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            zapData\n        );");
insert Expression(4454, 4453, "zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            zapData\n        )");
insert AssignmentExpression(4455, 4454, "zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            zapData\n        )");
insert Expression(4456, 4455, "zapData");
insert Identifier(4457, 4456, "zapData");
insert Expression(4458, 4455, "_deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            zapData\n        )");
insert CallExpression(4459, 4458, "_deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            zapData\n        )");
insert Expression(4460, 4459, "_deployEscrow");
insert Identifier(4461, 4460, "_deployEscrow");
insert CallArgument(4462, 4459, "_milestoneAmounts");
insert Expression(4463, 4462, "_milestoneAmounts");
insert Identifier(4464, 4463, "_milestoneAmounts");
insert CallArgument(4465, 4459, "_escrowData");
insert Expression(4466, 4465, "_escrowData");
insert Identifier(4467, 4466, "_escrowData");
insert CallArgument(4468, 4459, "escrowParams");
insert Expression(4469, 4468, "escrowParams");
insert Identifier(4470, 4469, "escrowParams");
insert CallArgument(4471, 4459, "zapData");
insert Expression(4472, 4471, "zapData");
insert Identifier(4473, 4472, "zapData");
insert Statement(4474, 4348, "emit SafeSplitsEscrowCreated(\n            zapData.safe,\n            zapData.projectTeamSplit,\n            zapData.escrow\n        );");
insert EmitStatement(4475, 4474, "emit SafeSplitsEscrowCreated(\n            zapData.safe,\n            zapData.projectTeamSplit,\n            zapData.escrow\n        );");
insert Expression(4476, 4475, "SafeSplitsEscrowCreated");
insert Identifier(4477, 4476, "SafeSplitsEscrowCreated");
insert CallArgument(4478, 4475, "zapData.safe");
insert Expression(4479, 4478, "zapData.safe");
insert MemberExpression(4480, 4479, "zapData.safe");
insert Identifier(4481, 4480, "zapData");
insert Identifier(4482, 4480, "safe");
insert CallArgument(4483, 4475, "zapData.projectTeamSplit");
insert Expression(4484, 4483, "zapData.projectTeamSplit");
insert MemberExpression(4485, 4484, "zapData.projectTeamSplit");
insert Identifier(4486, 4485, "zapData");
insert Identifier(4487, 4485, "projectTeamSplit");
insert CallArgument(4488, 4475, "zapData.escrow");
insert Expression(4489, 4488, "zapData.escrow");
insert MemberExpression(4490, 4489, "zapData.escrow");
insert Identifier(4491, 4490, "zapData");
insert Identifier(4492, 4490, "escrow");
insert Comment(4493, 3383, "/**\n     * @notice Deploys a new Safe, Project Team Split, and Escrow with the provided details.\n     * @param _owners The Safe owners and project team participants.\n     * @param _percentAllocations The percent allocations for the project team split.\n     * @param _milestoneAmounts The milestone amounts for the escrow.\n     * @param _safeData The encoded data for deploying a Safe.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitData The encoded data for deploying a Split.\n     * @param _escrowData The encoded data for escrow deployment.\n     */");
insert FunctionDefinition(4494, 3383, "function createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitData,\n        bytes calldata _escrowData\n    ) public virtual {\n        if (_percentAllocations.length != _owners.length)\n            revert InvalidAllocationsOwnersData();\n\n        _createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitData,\n            _escrowData\n        );\n    }");
insert Identifier(4495, 4494, "createSafeSplitEscrow");
insert Parameter(4496, 4494, "address[] memory _owners");
insert TypeName(4497, 4496, "address[]");
insert TypeName(4498, 4497, "address");
insert PrimitiveType(4499, 4498, "address");
insert Identifier(4500, 4496, "_owners");
insert Parameter(4501, 4494, "uint32[] memory _percentAllocations");
insert TypeName(4502, 4501, "uint32[]");
insert TypeName(4503, 4502, "uint32");
insert PrimitiveType(4504, 4503, "uint32");
insert Identifier(4505, 4501, "_percentAllocations");
insert Parameter(4506, 4494, "uint256[] memory _milestoneAmounts");
insert TypeName(4507, 4506, "uint256[]");
insert TypeName(4508, 4507, "uint256");
insert PrimitiveType(4509, 4508, "uint256");
insert Identifier(4510, 4506, "_milestoneAmounts");
insert Parameter(4511, 4494, "bytes calldata _safeData");
insert TypeName(4512, 4511, "bytes");
insert PrimitiveType(4513, 4512, "bytes");
insert Identifier(4514, 4511, "_safeData");
insert Parameter(4515, 4494, "address _safeAddress");
insert TypeName(4516, 4515, "address");
insert PrimitiveType(4517, 4516, "address");
insert Identifier(4518, 4515, "_safeAddress");
insert Parameter(4519, 4494, "bytes calldata _splitData");
insert TypeName(4520, 4519, "bytes");
insert PrimitiveType(4521, 4520, "bytes");
insert Identifier(4522, 4519, "_splitData");
insert Parameter(4523, 4494, "bytes calldata _escrowData");
insert TypeName(4524, 4523, "bytes");
insert PrimitiveType(4525, 4524, "bytes");
insert Identifier(4526, 4523, "_escrowData");
insert Visibility(4527, 4494, "public");
insert Virtual(4528, 4494, "virtual");
insert FunctionBody(4529, 4494, "{\n        if (_percentAllocations.length != _owners.length)\n            revert InvalidAllocationsOwnersData();\n\n        _createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitData,\n            _escrowData\n        );\n    }");
insert Statement(4530, 4529, "if (_percentAllocations.length != _owners.length)\n            revert InvalidAllocationsOwnersData();");
insert IfStatement(4531, 4530, "if (_percentAllocations.length != _owners.length)\n            revert InvalidAllocationsOwnersData();");
insert Expression(4532, 4531, "_percentAllocations.length != _owners.length");
insert BinaryExpression(4533, 4532, "_percentAllocations.length != _owners.length");
insert Expression(4534, 4533, "_percentAllocations.length");
insert MemberExpression(4535, 4534, "_percentAllocations.length");
insert Identifier(4536, 4535, "_percentAllocations");
insert Identifier(4537, 4535, "length");
insert Expression(4538, 4533, "_owners.length");
insert MemberExpression(4539, 4538, "_owners.length");
insert Identifier(4540, 4539, "_owners");
insert Identifier(4541, 4539, "length");
insert Statement(4542, 4531, "revert InvalidAllocationsOwnersData();");
insert RevertStatement(4543, 4542, "revert InvalidAllocationsOwnersData();");
insert Expression(4544, 4543, "InvalidAllocationsOwnersData");
insert Identifier(4545, 4544, "InvalidAllocationsOwnersData");
insert RevertArguments(4546, 4543, "()");
insert Statement(4547, 4529, "_createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitData,\n            _escrowData\n        );");
insert ExpressionStatement(4548, 4547, "_createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitData,\n            _escrowData\n        );");
insert Expression(4549, 4548, "_createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitData,\n            _escrowData\n        )");
insert CallExpression(4550, 4549, "_createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitData,\n            _escrowData\n        )");
insert Expression(4551, 4550, "_createSafeSplitEscrow");
insert Identifier(4552, 4551, "_createSafeSplitEscrow");
insert CallArgument(4553, 4550, "_owners");
insert Expression(4554, 4553, "_owners");
insert Identifier(4555, 4554, "_owners");
insert CallArgument(4556, 4550, "_percentAllocations");
insert Expression(4557, 4556, "_percentAllocations");
insert Identifier(4558, 4557, "_percentAllocations");
insert CallArgument(4559, 4550, "_milestoneAmounts");
insert Expression(4560, 4559, "_milestoneAmounts");
insert Identifier(4561, 4560, "_milestoneAmounts");
insert CallArgument(4562, 4550, "_safeData");
insert Expression(4563, 4562, "_safeData");
insert Identifier(4564, 4563, "_safeData");
insert CallArgument(4565, 4550, "_safeAddress");
insert Expression(4566, 4565, "_safeAddress");
insert Identifier(4567, 4566, "_safeAddress");
insert CallArgument(4568, 4550, "_splitData");
insert Expression(4569, 4568, "_splitData");
insert Identifier(4570, 4569, "_splitData");
insert CallArgument(4571, 4550, "_escrowData");
insert Expression(4572, 4571, "_escrowData");
insert Identifier(4573, 4572, "_escrowData");
insert Comment(4574, 3383, "/**\n     * @dev Internal function to update addresses used by the contract.\n     * @param _data The encoded data for updating addresses.\n     */");
insert FunctionDefinition(4575, 3383, "function _updateAddresses(bytes calldata _data) internal {\n        (\n            address _safeSingleton,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory\n        ) = abi.decode(_data, (address, address, address, address));\n\n        if (_safeSingleton != address(0)) safeSingleton = _safeSingleton;\n        if (_safeFactory != address(0))\n            safeFactory = ISafeProxyFactory(_safeFactory);\n        if (_splitMain != address(0)) splitMain = ISplitMain(_splitMain);\n        if (_escrowFactory != address(0))\n            escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n\n        emit UpdatedAddresses(\n            _safeSingleton,\n            _safeFactory,\n            _splitMain,\n            _escrowFactory\n        );\n    }");
insert Identifier(4576, 4575, "_updateAddresses");
insert Parameter(4577, 4575, "bytes calldata _data");
insert TypeName(4578, 4577, "bytes");
insert PrimitiveType(4579, 4578, "bytes");
insert Identifier(4580, 4577, "_data");
insert Visibility(4581, 4575, "internal");
insert FunctionBody(4582, 4575, "{\n        (\n            address _safeSingleton,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory\n        ) = abi.decode(_data, (address, address, address, address));\n\n        if (_safeSingleton != address(0)) safeSingleton = _safeSingleton;\n        if (_safeFactory != address(0))\n            safeFactory = ISafeProxyFactory(_safeFactory);\n        if (_splitMain != address(0)) splitMain = ISplitMain(_splitMain);\n        if (_escrowFactory != address(0))\n            escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n\n        emit UpdatedAddresses(\n            _safeSingleton,\n            _safeFactory,\n            _splitMain,\n            _escrowFactory\n        );\n    }");
insert Statement(4583, 4582, "(\n            address _safeSingleton,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory\n        ) = abi.decode(_data, (address, address, address, address));");
insert VariableDeclarationStatement(4584, 4583, "(\n            address _safeSingleton,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory\n        ) = abi.decode(_data, (address, address, address, address));");
insert VariableDeclarationTuple(4585, 4584, "(\n            address _safeSingleton,\n            address _safeFactory,\n            address _splitMain,\n            address _escrowFactory\n        )");
insert VariableDeclaration(4586, 4585, "address _safeSingleton");
insert TypeName(4587, 4586, "address");
insert PrimitiveType(4588, 4587, "address");
insert Identifier(4589, 4586, "_safeSingleton");
insert VariableDeclaration(4590, 4585, "address _safeFactory");
insert TypeName(4591, 4590, "address");
insert PrimitiveType(4592, 4591, "address");
insert Identifier(4593, 4590, "_safeFactory");
insert VariableDeclaration(4594, 4585, "address _splitMain");
insert TypeName(4595, 4594, "address");
insert PrimitiveType(4596, 4595, "address");
insert Identifier(4597, 4594, "_splitMain");
insert VariableDeclaration(4598, 4585, "address _escrowFactory");
insert TypeName(4599, 4598, "address");
insert PrimitiveType(4600, 4599, "address");
insert Identifier(4601, 4598, "_escrowFactory");
insert Expression(4602, 4584, "abi.decode(_data, (address, address, address, address))");
insert CallExpression(4603, 4602, "abi.decode(_data, (address, address, address, address))");
insert Expression(4604, 4603, "abi.decode");
insert MemberExpression(4605, 4604, "abi.decode");
insert Identifier(4606, 4605, "abi");
insert Identifier(4607, 4605, "decode");
insert CallArgument(4608, 4603, "_data");
insert Expression(4609, 4608, "_data");
insert Identifier(4610, 4609, "_data");
insert CallArgument(4611, 4603, "(address, address, address, address)");
insert Expression(4612, 4611, "(address, address, address, address)");
insert TupleExpression(4613, 4612, "(address, address, address, address)");
insert Expression(4614, 4613, "address");
insert PrimitiveType(4615, 4614, "address");
insert Expression(4616, 4613, "address");
insert PrimitiveType(4617, 4616, "address");
insert Expression(4618, 4613, "address");
insert PrimitiveType(4619, 4618, "address");
insert Expression(4620, 4613, "address");
insert PrimitiveType(4621, 4620, "address");
insert Statement(4622, 4582, "if (_safeSingleton != address(0)) safeSingleton = _safeSingleton;");
insert IfStatement(4623, 4622, "if (_safeSingleton != address(0)) safeSingleton = _safeSingleton;");
insert Expression(4624, 4623, "_safeSingleton != address(0)");
insert BinaryExpression(4625, 4624, "_safeSingleton != address(0)");
insert Expression(4626, 4625, "_safeSingleton");
insert Identifier(4627, 4626, "_safeSingleton");
insert Expression(4628, 4625, "address(0)");
insert TypeCastExpression(4629, 4628, "address(0)");
insert PrimitiveType(4630, 4629, "address");
insert CallArgument(4631, 4629, "0");
insert Expression(4632, 4631, "0");
insert NumberLiteral(4633, 4632, "0");
insert Statement(4634, 4623, "safeSingleton = _safeSingleton;");
insert ExpressionStatement(4635, 4634, "safeSingleton = _safeSingleton;");
insert Expression(4636, 4635, "safeSingleton = _safeSingleton");
insert AssignmentExpression(4637, 4636, "safeSingleton = _safeSingleton");
insert Expression(4638, 4637, "safeSingleton");
insert Identifier(4639, 4638, "safeSingleton");
insert Expression(4640, 4637, "_safeSingleton");
insert Identifier(4641, 4640, "_safeSingleton");
insert Statement(4642, 4582, "if (_safeFactory != address(0))\n            safeFactory = ISafeProxyFactory(_safeFactory);");
insert IfStatement(4643, 4642, "if (_safeFactory != address(0))\n            safeFactory = ISafeProxyFactory(_safeFactory);");
insert Expression(4644, 4643, "_safeFactory != address(0)");
insert BinaryExpression(4645, 4644, "_safeFactory != address(0)");
insert Expression(4646, 4645, "_safeFactory");
insert Identifier(4647, 4646, "_safeFactory");
insert Expression(4648, 4645, "address(0)");
insert TypeCastExpression(4649, 4648, "address(0)");
insert PrimitiveType(4650, 4649, "address");
insert CallArgument(4651, 4649, "0");
insert Expression(4652, 4651, "0");
insert NumberLiteral(4653, 4652, "0");
insert Statement(4654, 4643, "safeFactory = ISafeProxyFactory(_safeFactory);");
insert ExpressionStatement(4655, 4654, "safeFactory = ISafeProxyFactory(_safeFactory);");
insert Expression(4656, 4655, "safeFactory = ISafeProxyFactory(_safeFactory)");
insert AssignmentExpression(4657, 4656, "safeFactory = ISafeProxyFactory(_safeFactory)");
insert Expression(4658, 4657, "safeFactory");
insert Identifier(4659, 4658, "safeFactory");
insert Expression(4660, 4657, "ISafeProxyFactory(_safeFactory)");
insert CallExpression(4661, 4660, "ISafeProxyFactory(_safeFactory)");
insert Expression(4662, 4661, "ISafeProxyFactory");
insert Identifier(4663, 4662, "ISafeProxyFactory");
insert CallArgument(4664, 4661, "_safeFactory");
insert Expression(4665, 4664, "_safeFactory");
insert Identifier(4666, 4665, "_safeFactory");
insert Statement(4667, 4582, "if (_splitMain != address(0)) splitMain = ISplitMain(_splitMain);");
insert IfStatement(4668, 4667, "if (_splitMain != address(0)) splitMain = ISplitMain(_splitMain);");
insert Expression(4669, 4668, "_splitMain != address(0)");
insert BinaryExpression(4670, 4669, "_splitMain != address(0)");
insert Expression(4671, 4670, "_splitMain");
insert Identifier(4672, 4671, "_splitMain");
insert Expression(4673, 4670, "address(0)");
insert TypeCastExpression(4674, 4673, "address(0)");
insert PrimitiveType(4675, 4674, "address");
insert CallArgument(4676, 4674, "0");
insert Expression(4677, 4676, "0");
insert NumberLiteral(4678, 4677, "0");
insert Statement(4679, 4668, "splitMain = ISplitMain(_splitMain);");
insert ExpressionStatement(4680, 4679, "splitMain = ISplitMain(_splitMain);");
insert Expression(4681, 4680, "splitMain = ISplitMain(_splitMain)");
insert AssignmentExpression(4682, 4681, "splitMain = ISplitMain(_splitMain)");
insert Expression(4683, 4682, "splitMain");
insert Identifier(4684, 4683, "splitMain");
insert Expression(4685, 4682, "ISplitMain(_splitMain)");
insert CallExpression(4686, 4685, "ISplitMain(_splitMain)");
insert Expression(4687, 4686, "ISplitMain");
insert Identifier(4688, 4687, "ISplitMain");
insert CallArgument(4689, 4686, "_splitMain");
insert Expression(4690, 4689, "_splitMain");
insert Identifier(4691, 4690, "_splitMain");
insert Statement(4692, 4582, "if (_escrowFactory != address(0))\n            escrowFactory = ISmartInvoiceFactory(_escrowFactory);");
insert IfStatement(4693, 4692, "if (_escrowFactory != address(0))\n            escrowFactory = ISmartInvoiceFactory(_escrowFactory);");
insert Expression(4694, 4693, "_escrowFactory != address(0)");
insert BinaryExpression(4695, 4694, "_escrowFactory != address(0)");
insert Expression(4696, 4695, "_escrowFactory");
insert Identifier(4697, 4696, "_escrowFactory");
insert Expression(4698, 4695, "address(0)");
insert TypeCastExpression(4699, 4698, "address(0)");
insert PrimitiveType(4700, 4699, "address");
insert CallArgument(4701, 4699, "0");
insert Expression(4702, 4701, "0");
insert NumberLiteral(4703, 4702, "0");
insert Statement(4704, 4693, "escrowFactory = ISmartInvoiceFactory(_escrowFactory);");
insert ExpressionStatement(4705, 4704, "escrowFactory = ISmartInvoiceFactory(_escrowFactory);");
insert Expression(4706, 4705, "escrowFactory = ISmartInvoiceFactory(_escrowFactory)");
insert AssignmentExpression(4707, 4706, "escrowFactory = ISmartInvoiceFactory(_escrowFactory)");
insert Expression(4708, 4707, "escrowFactory");
insert Identifier(4709, 4708, "escrowFactory");
insert Expression(4710, 4707, "ISmartInvoiceFactory(_escrowFactory)");
insert CallExpression(4711, 4710, "ISmartInvoiceFactory(_escrowFactory)");
insert Expression(4712, 4711, "ISmartInvoiceFactory");
insert Identifier(4713, 4712, "ISmartInvoiceFactory");
insert CallArgument(4714, 4711, "_escrowFactory");
insert Expression(4715, 4714, "_escrowFactory");
insert Identifier(4716, 4715, "_escrowFactory");
insert Statement(4717, 4582, "emit UpdatedAddresses(\n            _safeSingleton,\n            _safeFactory,\n            _splitMain,\n            _escrowFactory\n        );");
insert EmitStatement(4718, 4717, "emit UpdatedAddresses(\n            _safeSingleton,\n            _safeFactory,\n            _splitMain,\n            _escrowFactory\n        );");
insert Expression(4719, 4718, "UpdatedAddresses");
insert Identifier(4720, 4719, "UpdatedAddresses");
insert CallArgument(4721, 4718, "_safeSingleton");
insert Expression(4722, 4721, "_safeSingleton");
insert Identifier(4723, 4722, "_safeSingleton");
insert CallArgument(4724, 4718, "_safeFactory");
insert Expression(4725, 4724, "_safeFactory");
insert Identifier(4726, 4725, "_safeFactory");
insert CallArgument(4727, 4718, "_splitMain");
insert Expression(4728, 4727, "_splitMain");
insert Identifier(4729, 4728, "_splitMain");
insert CallArgument(4730, 4718, "_escrowFactory");
insert Expression(4731, 4730, "_escrowFactory");
insert Identifier(4732, 4731, "_escrowFactory");
insert Comment(4733, 3383, "/**\n     * @notice Updates the addresses used by the contract.\n     * @param _data The encoded data for updating addresses.\n     */");
insert FunctionDefinition(4734, 3383, "function updateAddresses(bytes calldata _data) external {\n        if (!hasRole(ADMIN, _msgSender())) revert NotAuthorized();\n        _updateAddresses(_data);\n    }");
insert Identifier(4735, 4734, "updateAddresses");
insert Parameter(4736, 4734, "bytes calldata _data");
insert TypeName(4737, 4736, "bytes");
insert PrimitiveType(4738, 4737, "bytes");
insert Identifier(4739, 4736, "_data");
insert Visibility(4740, 4734, "external");
insert FunctionBody(4741, 4734, "{\n        if (!hasRole(ADMIN, _msgSender())) revert NotAuthorized();\n        _updateAddresses(_data);\n    }");
insert Statement(4742, 4741, "if (!hasRole(ADMIN, _msgSender())) revert NotAuthorized();");
insert IfStatement(4743, 4742, "if (!hasRole(ADMIN, _msgSender())) revert NotAuthorized();");
insert Expression(4744, 4743, "!hasRole(ADMIN, _msgSender())");
insert UnaryExpression(4745, 4744, "!hasRole(ADMIN, _msgSender())");
insert Expression(4746, 4745, "hasRole(ADMIN, _msgSender())");
insert CallExpression(4747, 4746, "hasRole(ADMIN, _msgSender())");
insert Expression(4748, 4747, "hasRole");
insert Identifier(4749, 4748, "hasRole");
insert CallArgument(4750, 4747, "ADMIN");
insert Expression(4751, 4750, "ADMIN");
insert Identifier(4752, 4751, "ADMIN");
insert CallArgument(4753, 4747, "_msgSender()");
insert Expression(4754, 4753, "_msgSender()");
insert CallExpression(4755, 4754, "_msgSender()");
insert Expression(4756, 4755, "_msgSender");
insert Identifier(4757, 4756, "_msgSender");
insert Statement(4758, 4743, "revert NotAuthorized();");
insert RevertStatement(4759, 4758, "revert NotAuthorized();");
insert Expression(4760, 4759, "NotAuthorized");
insert Identifier(4761, 4760, "NotAuthorized");
insert RevertArguments(4762, 4759, "()");
insert Statement(4763, 4741, "_updateAddresses(_data);");
insert ExpressionStatement(4764, 4763, "_updateAddresses(_data);");
insert Expression(4765, 4764, "_updateAddresses(_data)");
insert CallExpression(4766, 4765, "_updateAddresses(_data)");
insert Expression(4767, 4766, "_updateAddresses");
insert Identifier(4768, 4767, "_updateAddresses");
insert CallArgument(4769, 4766, "_data");
insert Expression(4770, 4769, "_data");
insert Identifier(4771, 4770, "_data");
insert Comment(4772, 3383, "/**\n     * @notice Updates the distributor fee.\n     * @param _distributorFee The new distributor fee.\n     */");
insert FunctionDefinition(4773, 3383, "function updateDistributorFee(uint32 _distributorFee) external {\n        if (!hasRole(ADMIN, _msgSender())) revert NotAuthorized();\n        distributorFee = _distributorFee;\n        emit UpdatedDistributorFee(_distributorFee);\n    }");
insert Identifier(4774, 4773, "updateDistributorFee");
insert Parameter(4775, 4773, "uint32 _distributorFee");
insert TypeName(4776, 4775, "uint32");
insert PrimitiveType(4777, 4776, "uint32");
insert Identifier(4778, 4775, "_distributorFee");
insert Visibility(4779, 4773, "external");
insert FunctionBody(4780, 4773, "{\n        if (!hasRole(ADMIN, _msgSender())) revert NotAuthorized();\n        distributorFee = _distributorFee;\n        emit UpdatedDistributorFee(_distributorFee);\n    }");
insert Statement(4781, 4780, "if (!hasRole(ADMIN, _msgSender())) revert NotAuthorized();");
insert IfStatement(4782, 4781, "if (!hasRole(ADMIN, _msgSender())) revert NotAuthorized();");
insert Expression(4783, 4782, "!hasRole(ADMIN, _msgSender())");
insert UnaryExpression(4784, 4783, "!hasRole(ADMIN, _msgSender())");
insert Expression(4785, 4784, "hasRole(ADMIN, _msgSender())");
insert CallExpression(4786, 4785, "hasRole(ADMIN, _msgSender())");
insert Expression(4787, 4786, "hasRole");
insert Identifier(4788, 4787, "hasRole");
insert CallArgument(4789, 4786, "ADMIN");
insert Expression(4790, 4789, "ADMIN");
insert Identifier(4791, 4790, "ADMIN");
insert CallArgument(4792, 4786, "_msgSender()");
insert Expression(4793, 4792, "_msgSender()");
insert CallExpression(4794, 4793, "_msgSender()");
insert Expression(4795, 4794, "_msgSender");
insert Identifier(4796, 4795, "_msgSender");
insert Statement(4797, 4782, "revert NotAuthorized();");
insert RevertStatement(4798, 4797, "revert NotAuthorized();");
insert Expression(4799, 4798, "NotAuthorized");
insert Identifier(4800, 4799, "NotAuthorized");
insert RevertArguments(4801, 4798, "()");
insert Statement(4802, 4780, "distributorFee = _distributorFee;");
insert ExpressionStatement(4803, 4802, "distributorFee = _distributorFee;");
insert Expression(4804, 4803, "distributorFee = _distributorFee");
insert AssignmentExpression(4805, 4804, "distributorFee = _distributorFee");
insert Expression(4806, 4805, "distributorFee");
insert Identifier(4807, 4806, "distributorFee");
insert Expression(4808, 4805, "_distributorFee");
insert Identifier(4809, 4808, "_distributorFee");
insert Statement(4810, 4780, "emit UpdatedDistributorFee(_distributorFee);");
insert EmitStatement(4811, 4810, "emit UpdatedDistributorFee(_distributorFee);");
insert Expression(4812, 4811, "UpdatedDistributorFee");
insert Identifier(4813, 4812, "UpdatedDistributorFee");
insert CallArgument(4814, 4811, "_distributorFee");
insert Expression(4815, 4814, "_distributorFee");
insert Identifier(4816, 4815, "_distributorFee");
insert SourceFile(4817, 0, "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";\nimport {SmartInvoiceEscrow} from \"./SmartInvoiceEscrow.sol\";\n\n/// @title SmartInvoiceUpdatable\n/// @notice An updatable smart invoice escrow contract with embedded arbitration tailored for guild work.\ncontract SmartInvoiceUpdatable is SmartInvoiceEscrow {\n    using SafeERC20 for IERC20;\n\n    /// @notice The receiving address for the provider.\n    address public providerReceiver;\n\n    /// @dev Custom errors for more efficient gas usage.\n    error InvalidProviderReceiver();\n\n    /// @notice Emitted when the client address is updated.\n    /// @param client The updated client address.\n    event UpdatedClient(address indexed client);\n\n    /// @notice Emitted when the provider address is updated.\n    /// @param provider The updated provider address.\n    event UpdatedProvider(address indexed provider);\n\n    /// @notice Emitted when the provider's receiver address is updated.\n    /// @param providerReceiver The updated provider receiver address.\n    event UpdatedProviderReceiver(address indexed providerReceiver);\n\n    /// @dev Modifier for functions that can only be called by the provider.\n    modifier onlyProvider() {\n        if (msg.sender != provider) revert NotProvider();\n        _;\n    }\n\n    /// @dev Modifier for functions that can only be called by the client.\n    modifier onlyClient() {\n        if (msg.sender != client) revert NotClient();\n        _;\n    }\n\n    /**\n     * @notice Internal function for updating the client address.\n     * @param _client The updated client address.\n     */\n    function _updateClient(address _client) internal {\n        client = _client;\n        emit UpdatedClient(_client);\n    }\n\n    /**\n     * @notice Updates the client address.\n     * @param _client The updated client address.\n     */\n    function updateClient(address _client) external onlyClient {\n        if (_client == address(0)) revert InvalidClient();\n        _updateClient(_client);\n    }\n\n    /**\n     * @notice Internal function for updating the provider's receiver address.\n     * @param _providerReceiver The updated provider receiver address.\n     */\n    function _updateProviderReceiver(address _providerReceiver) internal {\n        providerReceiver = _providerReceiver;\n        emit UpdatedProviderReceiver(_providerReceiver);\n    }\n\n    /**\n     * @notice Updates the provider's receiver address.\n     * @param _providerReceiver The updated provider receiver address.\n     */\n    function updateProviderReceiver(\n        address _providerReceiver\n    ) external onlyProvider {\n        if (_providerReceiver == address(0)) revert InvalidProviderReceiver();\n        _updateProviderReceiver(_providerReceiver);\n    }\n\n    /**\n     * @notice Internal function for updating the provider address.\n     * @param _provider The updated provider address.\n     */\n    function _updateProvider(address _provider) internal {\n        provider = _provider;\n        emit UpdatedProvider(_provider);\n    }\n\n    /**\n     * @notice Updates the provider address.\n     * @param _provider The updated provider address.\n     */\n    function updateProvider(address _provider) external onlyProvider {\n        if (_provider == address(0)) revert InvalidProvider();\n        _updateProvider(_provider);\n    }\n\n    /**\n     * @notice Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded.\n     */\n    function _handleData(bytes calldata _data) internal virtual override {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address\n                )\n            );\n\n        if (_providerReceiver == address(0)) revert InvalidProviderReceiver();\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        providerReceiver = _providerReceiver;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }\n\n    /**\n     * @dev Internal function to transfer payment to the provider's receiver.\n     * @param _token The address of the token to transfer.\n     * @param _amount The amount of tokens to transfer.\n     */\n    function _transferPayment(\n        address _token,\n        uint256 _amount\n    ) internal virtual override {\n        IERC20(_token).safeTransfer(providerReceiver, _amount);\n    }\n}\n");
insert Comment(4818, 4817, "// SPDX-License-Identifier: MIT");
insert PragmaDirective(4819, 4817, "pragma solidity ^0.8.20;");
insert SolidityPragmaToken(4820, 4819, "solidity ^0.8.20");
insert SolidityVersionComparisonOperator(4821, 4820, " ^");
insert SolidityVersion(4822, 4820, "0.8.20");
insert ImportDirective(4823, 4817, "import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";");
insert Identifier(4824, 4823, "IERC20");
insert ImportDirective(4825, 4817, "import {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";");
insert Identifier(4826, 4825, "SafeERC20");
insert ImportDirective(4827, 4817, "import {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";");
insert Identifier(4828, 4827, "ISmartInvoiceFactory");
insert ImportDirective(4829, 4817, "import {SmartInvoiceEscrow} from \"./SmartInvoiceEscrow.sol\";");
insert Identifier(4830, 4829, "SmartInvoiceEscrow");
insert Comment(4831, 4817, "/// @title SmartInvoiceUpdatable");
insert Comment(4832, 4817, "/// @notice An updatable smart invoice escrow contract with embedded arbitration tailored for guild work.");
insert ContractDeclaration(4833, 4817, "contract SmartInvoiceUpdatable is SmartInvoiceEscrow {\n    using SafeERC20 for IERC20;\n\n    /// @notice The receiving address for the provider.\n    address public providerReceiver;\n\n    /// @dev Custom errors for more efficient gas usage.\n    error InvalidProviderReceiver();\n\n    /// @notice Emitted when the client address is updated.\n    /// @param client The updated client address.\n    event UpdatedClient(address indexed client);\n\n    /// @notice Emitted when the provider address is updated.\n    /// @param provider The updated provider address.\n    event UpdatedProvider(address indexed provider);\n\n    /// @notice Emitted when the provider's receiver address is updated.\n    /// @param providerReceiver The updated provider receiver address.\n    event UpdatedProviderReceiver(address indexed providerReceiver);\n\n    /// @dev Modifier for functions that can only be called by the provider.\n    modifier onlyProvider() {\n        if (msg.sender != provider) revert NotProvider();\n        _;\n    }\n\n    /// @dev Modifier for functions that can only be called by the client.\n    modifier onlyClient() {\n        if (msg.sender != client) revert NotClient();\n        _;\n    }\n\n    /**\n     * @notice Internal function for updating the client address.\n     * @param _client The updated client address.\n     */\n    function _updateClient(address _client) internal {\n        client = _client;\n        emit UpdatedClient(_client);\n    }\n\n    /**\n     * @notice Updates the client address.\n     * @param _client The updated client address.\n     */\n    function updateClient(address _client) external onlyClient {\n        if (_client == address(0)) revert InvalidClient();\n        _updateClient(_client);\n    }\n\n    /**\n     * @notice Internal function for updating the provider's receiver address.\n     * @param _providerReceiver The updated provider receiver address.\n     */\n    function _updateProviderReceiver(address _providerReceiver) internal {\n        providerReceiver = _providerReceiver;\n        emit UpdatedProviderReceiver(_providerReceiver);\n    }\n\n    /**\n     * @notice Updates the provider's receiver address.\n     * @param _providerReceiver The updated provider receiver address.\n     */\n    function updateProviderReceiver(\n        address _providerReceiver\n    ) external onlyProvider {\n        if (_providerReceiver == address(0)) revert InvalidProviderReceiver();\n        _updateProviderReceiver(_providerReceiver);\n    }\n\n    /**\n     * @notice Internal function for updating the provider address.\n     * @param _provider The updated provider address.\n     */\n    function _updateProvider(address _provider) internal {\n        provider = _provider;\n        emit UpdatedProvider(_provider);\n    }\n\n    /**\n     * @notice Updates the provider address.\n     * @param _provider The updated provider address.\n     */\n    function updateProvider(address _provider) external onlyProvider {\n        if (_provider == address(0)) revert InvalidProvider();\n        _updateProvider(_provider);\n    }\n\n    /**\n     * @notice Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded.\n     */\n    function _handleData(bytes calldata _data) internal virtual override {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address\n                )\n            );\n\n        if (_providerReceiver == address(0)) revert InvalidProviderReceiver();\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        providerReceiver = _providerReceiver;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }\n\n    /**\n     * @dev Internal function to transfer payment to the provider's receiver.\n     * @param _token The address of the token to transfer.\n     * @param _amount The amount of tokens to transfer.\n     */\n    function _transferPayment(\n        address _token,\n        uint256 _amount\n    ) internal virtual override {\n        IERC20(_token).safeTransfer(providerReceiver, _amount);\n    }\n}");
insert Identifier(4834, 4833, "SmartInvoiceUpdatable");
insert InheritanceSpecifier(4835, 4833, "SmartInvoiceEscrow");
insert UserDefinedType(4836, 4835, "SmartInvoiceEscrow");
insert Identifier(4837, 4836, "SmartInvoiceEscrow");
insert ContractBody(4838, 4833, "{\n    using SafeERC20 for IERC20;\n\n    /// @notice The receiving address for the provider.\n    address public providerReceiver;\n\n    /// @dev Custom errors for more efficient gas usage.\n    error InvalidProviderReceiver();\n\n    /// @notice Emitted when the client address is updated.\n    /// @param client The updated client address.\n    event UpdatedClient(address indexed client);\n\n    /// @notice Emitted when the provider address is updated.\n    /// @param provider The updated provider address.\n    event UpdatedProvider(address indexed provider);\n\n    /// @notice Emitted when the provider's receiver address is updated.\n    /// @param providerReceiver The updated provider receiver address.\n    event UpdatedProviderReceiver(address indexed providerReceiver);\n\n    /// @dev Modifier for functions that can only be called by the provider.\n    modifier onlyProvider() {\n        if (msg.sender != provider) revert NotProvider();\n        _;\n    }\n\n    /// @dev Modifier for functions that can only be called by the client.\n    modifier onlyClient() {\n        if (msg.sender != client) revert NotClient();\n        _;\n    }\n\n    /**\n     * @notice Internal function for updating the client address.\n     * @param _client The updated client address.\n     */\n    function _updateClient(address _client) internal {\n        client = _client;\n        emit UpdatedClient(_client);\n    }\n\n    /**\n     * @notice Updates the client address.\n     * @param _client The updated client address.\n     */\n    function updateClient(address _client) external onlyClient {\n        if (_client == address(0)) revert InvalidClient();\n        _updateClient(_client);\n    }\n\n    /**\n     * @notice Internal function for updating the provider's receiver address.\n     * @param _providerReceiver The updated provider receiver address.\n     */\n    function _updateProviderReceiver(address _providerReceiver) internal {\n        providerReceiver = _providerReceiver;\n        emit UpdatedProviderReceiver(_providerReceiver);\n    }\n\n    /**\n     * @notice Updates the provider's receiver address.\n     * @param _providerReceiver The updated provider receiver address.\n     */\n    function updateProviderReceiver(\n        address _providerReceiver\n    ) external onlyProvider {\n        if (_providerReceiver == address(0)) revert InvalidProviderReceiver();\n        _updateProviderReceiver(_providerReceiver);\n    }\n\n    /**\n     * @notice Internal function for updating the provider address.\n     * @param _provider The updated provider address.\n     */\n    function _updateProvider(address _provider) internal {\n        provider = _provider;\n        emit UpdatedProvider(_provider);\n    }\n\n    /**\n     * @notice Updates the provider address.\n     * @param _provider The updated provider address.\n     */\n    function updateProvider(address _provider) external onlyProvider {\n        if (_provider == address(0)) revert InvalidProvider();\n        _updateProvider(_provider);\n    }\n\n    /**\n     * @notice Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded.\n     */\n    function _handleData(bytes calldata _data) internal virtual override {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address\n                )\n            );\n\n        if (_providerReceiver == address(0)) revert InvalidProviderReceiver();\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        providerReceiver = _providerReceiver;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }\n\n    /**\n     * @dev Internal function to transfer payment to the provider's receiver.\n     * @param _token The address of the token to transfer.\n     * @param _amount The amount of tokens to transfer.\n     */\n    function _transferPayment(\n        address _token,\n        uint256 _amount\n    ) internal virtual override {\n        IERC20(_token).safeTransfer(providerReceiver, _amount);\n    }\n}");
insert UsingDirective(4839, 4838, "using SafeERC20 for IERC20;");
insert TypeAlias(4840, 4839, "SafeERC20");
insert Identifier(4841, 4840, "SafeERC20");
insert TypeName(4842, 4839, "IERC20");
insert UserDefinedType(4843, 4842, "IERC20");
insert Identifier(4844, 4843, "IERC20");
insert Comment(4845, 4838, "/// @notice The receiving address for the provider.");
insert StateVariableDeclaration(4846, 4838, "address public providerReceiver;");
insert TypeName(4847, 4846, "address");
insert PrimitiveType(4848, 4847, "address");
insert Visibility(4849, 4846, "public");
insert Identifier(4850, 4846, "providerReceiver");
insert Comment(4851, 4838, "/// @dev Custom errors for more efficient gas usage.");
insert ErrorDeclaration(4852, 4838, "error InvalidProviderReceiver();");
insert Identifier(4853, 4852, "InvalidProviderReceiver");
insert Comment(4854, 4838, "/// @notice Emitted when the client address is updated.");
insert Comment(4855, 4838, "/// @param client The updated client address.");
insert EventDefinition(4856, 4838, "event UpdatedClient(address indexed client);");
insert Identifier(4857, 4856, "UpdatedClient");
insert EventParameter(4858, 4856, "address indexed client");
insert TypeName(4859, 4858, "address");
insert PrimitiveType(4860, 4859, "address");
insert Identifier(4861, 4858, "client");
insert Comment(4862, 4838, "/// @notice Emitted when the provider address is updated.");
insert Comment(4863, 4838, "/// @param provider The updated provider address.");
insert EventDefinition(4864, 4838, "event UpdatedProvider(address indexed provider);");
insert Identifier(4865, 4864, "UpdatedProvider");
insert EventParameter(4866, 4864, "address indexed provider");
insert TypeName(4867, 4866, "address");
insert PrimitiveType(4868, 4867, "address");
insert Identifier(4869, 4866, "provider");
insert Comment(4870, 4838, "/// @notice Emitted when the provider's receiver address is updated.");
insert Comment(4871, 4838, "/// @param providerReceiver The updated provider receiver address.");
insert EventDefinition(4872, 4838, "event UpdatedProviderReceiver(address indexed providerReceiver);");
insert Identifier(4873, 4872, "UpdatedProviderReceiver");
insert EventParameter(4874, 4872, "address indexed providerReceiver");
insert TypeName(4875, 4874, "address");
insert PrimitiveType(4876, 4875, "address");
insert Identifier(4877, 4874, "providerReceiver");
insert Comment(4878, 4838, "/// @dev Modifier for functions that can only be called by the provider.");
insert ModifierDefinition(4879, 4838, "modifier onlyProvider() {\n        if (msg.sender != provider) revert NotProvider();\n        _;\n    }");
insert Identifier(4880, 4879, "onlyProvider");
insert FunctionBody(4881, 4879, "{\n        if (msg.sender != provider) revert NotProvider();\n        _;\n    }");
insert Statement(4882, 4881, "if (msg.sender != provider) revert NotProvider();");
insert IfStatement(4883, 4882, "if (msg.sender != provider) revert NotProvider();");
insert Expression(4884, 4883, "msg.sender != provider");
insert BinaryExpression(4885, 4884, "msg.sender != provider");
insert Expression(4886, 4885, "msg.sender");
insert MemberExpression(4887, 4886, "msg.sender");
insert Identifier(4888, 4887, "msg");
insert Identifier(4889, 4887, "sender");
insert Expression(4890, 4885, "provider");
insert Identifier(4891, 4890, "provider");
insert Statement(4892, 4883, "revert NotProvider();");
insert RevertStatement(4893, 4892, "revert NotProvider();");
insert Expression(4894, 4893, "NotProvider");
insert Identifier(4895, 4894, "NotProvider");
insert RevertArguments(4896, 4893, "()");
insert Statement(4897, 4881, "_;");
insert ExpressionStatement(4898, 4897, "_;");
insert Expression(4899, 4898, "_");
insert Identifier(4900, 4899, "_");
insert Comment(4901, 4838, "/// @dev Modifier for functions that can only be called by the client.");
insert ModifierDefinition(4902, 4838, "modifier onlyClient() {\n        if (msg.sender != client) revert NotClient();\n        _;\n    }");
insert Identifier(4903, 4902, "onlyClient");
insert FunctionBody(4904, 4902, "{\n        if (msg.sender != client) revert NotClient();\n        _;\n    }");
insert Statement(4905, 4904, "if (msg.sender != client) revert NotClient();");
insert IfStatement(4906, 4905, "if (msg.sender != client) revert NotClient();");
insert Expression(4907, 4906, "msg.sender != client");
insert BinaryExpression(4908, 4907, "msg.sender != client");
insert Expression(4909, 4908, "msg.sender");
insert MemberExpression(4910, 4909, "msg.sender");
insert Identifier(4911, 4910, "msg");
insert Identifier(4912, 4910, "sender");
insert Expression(4913, 4908, "client");
insert Identifier(4914, 4913, "client");
insert Statement(4915, 4906, "revert NotClient();");
insert RevertStatement(4916, 4915, "revert NotClient();");
insert Expression(4917, 4916, "NotClient");
insert Identifier(4918, 4917, "NotClient");
insert RevertArguments(4919, 4916, "()");
insert Statement(4920, 4904, "_;");
insert ExpressionStatement(4921, 4920, "_;");
insert Expression(4922, 4921, "_");
insert Identifier(4923, 4922, "_");
insert Comment(4924, 4838, "/**\n     * @notice Internal function for updating the client address.\n     * @param _client The updated client address.\n     */");
insert FunctionDefinition(4925, 4838, "function _updateClient(address _client) internal {\n        client = _client;\n        emit UpdatedClient(_client);\n    }");
insert Identifier(4926, 4925, "_updateClient");
insert Parameter(4927, 4925, "address _client");
insert TypeName(4928, 4927, "address");
insert PrimitiveType(4929, 4928, "address");
insert Identifier(4930, 4927, "_client");
insert Visibility(4931, 4925, "internal");
insert FunctionBody(4932, 4925, "{\n        client = _client;\n        emit UpdatedClient(_client);\n    }");
insert Statement(4933, 4932, "client = _client;");
insert ExpressionStatement(4934, 4933, "client = _client;");
insert Expression(4935, 4934, "client = _client");
insert AssignmentExpression(4936, 4935, "client = _client");
insert Expression(4937, 4936, "client");
insert Identifier(4938, 4937, "client");
insert Expression(4939, 4936, "_client");
insert Identifier(4940, 4939, "_client");
insert Statement(4941, 4932, "emit UpdatedClient(_client);");
insert EmitStatement(4942, 4941, "emit UpdatedClient(_client);");
insert Expression(4943, 4942, "UpdatedClient");
insert Identifier(4944, 4943, "UpdatedClient");
insert CallArgument(4945, 4942, "_client");
insert Expression(4946, 4945, "_client");
insert Identifier(4947, 4946, "_client");
insert Comment(4948, 4838, "/**\n     * @notice Updates the client address.\n     * @param _client The updated client address.\n     */");
insert FunctionDefinition(4949, 4838, "function updateClient(address _client) external onlyClient {\n        if (_client == address(0)) revert InvalidClient();\n        _updateClient(_client);\n    }");
insert Identifier(4950, 4949, "updateClient");
insert Parameter(4951, 4949, "address _client");
insert TypeName(4952, 4951, "address");
insert PrimitiveType(4953, 4952, "address");
insert Identifier(4954, 4951, "_client");
insert Visibility(4955, 4949, "external");
insert ModifierInvocation(4956, 4949, "onlyClient");
insert Identifier(4957, 4956, "onlyClient");
insert FunctionBody(4958, 4949, "{\n        if (_client == address(0)) revert InvalidClient();\n        _updateClient(_client);\n    }");
insert Statement(4959, 4958, "if (_client == address(0)) revert InvalidClient();");
insert IfStatement(4960, 4959, "if (_client == address(0)) revert InvalidClient();");
insert Expression(4961, 4960, "_client == address(0)");
insert BinaryExpression(4962, 4961, "_client == address(0)");
insert Expression(4963, 4962, "_client");
insert Identifier(4964, 4963, "_client");
insert Expression(4965, 4962, "address(0)");
insert TypeCastExpression(4966, 4965, "address(0)");
insert PrimitiveType(4967, 4966, "address");
insert CallArgument(4968, 4966, "0");
insert Expression(4969, 4968, "0");
insert NumberLiteral(4970, 4969, "0");
insert Statement(4971, 4960, "revert InvalidClient();");
insert RevertStatement(4972, 4971, "revert InvalidClient();");
insert Expression(4973, 4972, "InvalidClient");
insert Identifier(4974, 4973, "InvalidClient");
insert RevertArguments(4975, 4972, "()");
insert Statement(4976, 4958, "_updateClient(_client);");
insert ExpressionStatement(4977, 4976, "_updateClient(_client);");
insert Expression(4978, 4977, "_updateClient(_client)");
insert CallExpression(4979, 4978, "_updateClient(_client)");
insert Expression(4980, 4979, "_updateClient");
insert Identifier(4981, 4980, "_updateClient");
insert CallArgument(4982, 4979, "_client");
insert Expression(4983, 4982, "_client");
insert Identifier(4984, 4983, "_client");
insert Comment(4985, 4838, "/**\n     * @notice Internal function for updating the provider's receiver address.\n     * @param _providerReceiver The updated provider receiver address.\n     */");
insert FunctionDefinition(4986, 4838, "function _updateProviderReceiver(address _providerReceiver) internal {\n        providerReceiver = _providerReceiver;\n        emit UpdatedProviderReceiver(_providerReceiver);\n    }");
insert Identifier(4987, 4986, "_updateProviderReceiver");
insert Parameter(4988, 4986, "address _providerReceiver");
insert TypeName(4989, 4988, "address");
insert PrimitiveType(4990, 4989, "address");
insert Identifier(4991, 4988, "_providerReceiver");
insert Visibility(4992, 4986, "internal");
insert FunctionBody(4993, 4986, "{\n        providerReceiver = _providerReceiver;\n        emit UpdatedProviderReceiver(_providerReceiver);\n    }");
insert Statement(4994, 4993, "providerReceiver = _providerReceiver;");
insert ExpressionStatement(4995, 4994, "providerReceiver = _providerReceiver;");
insert Expression(4996, 4995, "providerReceiver = _providerReceiver");
insert AssignmentExpression(4997, 4996, "providerReceiver = _providerReceiver");
insert Expression(4998, 4997, "providerReceiver");
insert Identifier(4999, 4998, "providerReceiver");
insert Expression(5000, 4997, "_providerReceiver");
insert Identifier(5001, 5000, "_providerReceiver");
insert Statement(5002, 4993, "emit UpdatedProviderReceiver(_providerReceiver);");
insert EmitStatement(5003, 5002, "emit UpdatedProviderReceiver(_providerReceiver);");
insert Expression(5004, 5003, "UpdatedProviderReceiver");
insert Identifier(5005, 5004, "UpdatedProviderReceiver");
insert CallArgument(5006, 5003, "_providerReceiver");
insert Expression(5007, 5006, "_providerReceiver");
insert Identifier(5008, 5007, "_providerReceiver");
insert Comment(5009, 4838, "/**\n     * @notice Updates the provider's receiver address.\n     * @param _providerReceiver The updated provider receiver address.\n     */");
insert FunctionDefinition(5010, 4838, "function updateProviderReceiver(\n        address _providerReceiver\n    ) external onlyProvider {\n        if (_providerReceiver == address(0)) revert InvalidProviderReceiver();\n        _updateProviderReceiver(_providerReceiver);\n    }");
insert Identifier(5011, 5010, "updateProviderReceiver");
insert Parameter(5012, 5010, "address _providerReceiver");
insert TypeName(5013, 5012, "address");
insert PrimitiveType(5014, 5013, "address");
insert Identifier(5015, 5012, "_providerReceiver");
insert Visibility(5016, 5010, "external");
insert ModifierInvocation(5017, 5010, "onlyProvider");
insert Identifier(5018, 5017, "onlyProvider");
insert FunctionBody(5019, 5010, "{\n        if (_providerReceiver == address(0)) revert InvalidProviderReceiver();\n        _updateProviderReceiver(_providerReceiver);\n    }");
insert Statement(5020, 5019, "if (_providerReceiver == address(0)) revert InvalidProviderReceiver();");
insert IfStatement(5021, 5020, "if (_providerReceiver == address(0)) revert InvalidProviderReceiver();");
insert Expression(5022, 5021, "_providerReceiver == address(0)");
insert BinaryExpression(5023, 5022, "_providerReceiver == address(0)");
insert Expression(5024, 5023, "_providerReceiver");
insert Identifier(5025, 5024, "_providerReceiver");
insert Expression(5026, 5023, "address(0)");
insert TypeCastExpression(5027, 5026, "address(0)");
insert PrimitiveType(5028, 5027, "address");
insert CallArgument(5029, 5027, "0");
insert Expression(5030, 5029, "0");
insert NumberLiteral(5031, 5030, "0");
insert Statement(5032, 5021, "revert InvalidProviderReceiver();");
insert RevertStatement(5033, 5032, "revert InvalidProviderReceiver();");
insert Expression(5034, 5033, "InvalidProviderReceiver");
insert Identifier(5035, 5034, "InvalidProviderReceiver");
insert RevertArguments(5036, 5033, "()");
insert Statement(5037, 5019, "_updateProviderReceiver(_providerReceiver);");
insert ExpressionStatement(5038, 5037, "_updateProviderReceiver(_providerReceiver);");
insert Expression(5039, 5038, "_updateProviderReceiver(_providerReceiver)");
insert CallExpression(5040, 5039, "_updateProviderReceiver(_providerReceiver)");
insert Expression(5041, 5040, "_updateProviderReceiver");
insert Identifier(5042, 5041, "_updateProviderReceiver");
insert CallArgument(5043, 5040, "_providerReceiver");
insert Expression(5044, 5043, "_providerReceiver");
insert Identifier(5045, 5044, "_providerReceiver");
insert Comment(5046, 4838, "/**\n     * @notice Internal function for updating the provider address.\n     * @param _provider The updated provider address.\n     */");
insert FunctionDefinition(5047, 4838, "function _updateProvider(address _provider) internal {\n        provider = _provider;\n        emit UpdatedProvider(_provider);\n    }");
insert Identifier(5048, 5047, "_updateProvider");
insert Parameter(5049, 5047, "address _provider");
insert TypeName(5050, 5049, "address");
insert PrimitiveType(5051, 5050, "address");
insert Identifier(5052, 5049, "_provider");
insert Visibility(5053, 5047, "internal");
insert FunctionBody(5054, 5047, "{\n        provider = _provider;\n        emit UpdatedProvider(_provider);\n    }");
insert Statement(5055, 5054, "provider = _provider;");
insert ExpressionStatement(5056, 5055, "provider = _provider;");
insert Expression(5057, 5056, "provider = _provider");
insert AssignmentExpression(5058, 5057, "provider = _provider");
insert Expression(5059, 5058, "provider");
insert Identifier(5060, 5059, "provider");
insert Expression(5061, 5058, "_provider");
insert Identifier(5062, 5061, "_provider");
insert Statement(5063, 5054, "emit UpdatedProvider(_provider);");
insert EmitStatement(5064, 5063, "emit UpdatedProvider(_provider);");
insert Expression(5065, 5064, "UpdatedProvider");
insert Identifier(5066, 5065, "UpdatedProvider");
insert CallArgument(5067, 5064, "_provider");
insert Expression(5068, 5067, "_provider");
insert Identifier(5069, 5068, "_provider");
insert Comment(5070, 4838, "/**\n     * @notice Updates the provider address.\n     * @param _provider The updated provider address.\n     */");
insert FunctionDefinition(5071, 4838, "function updateProvider(address _provider) external onlyProvider {\n        if (_provider == address(0)) revert InvalidProvider();\n        _updateProvider(_provider);\n    }");
insert Identifier(5072, 5071, "updateProvider");
insert Parameter(5073, 5071, "address _provider");
insert TypeName(5074, 5073, "address");
insert PrimitiveType(5075, 5074, "address");
insert Identifier(5076, 5073, "_provider");
insert Visibility(5077, 5071, "external");
insert ModifierInvocation(5078, 5071, "onlyProvider");
insert Identifier(5079, 5078, "onlyProvider");
insert FunctionBody(5080, 5071, "{\n        if (_provider == address(0)) revert InvalidProvider();\n        _updateProvider(_provider);\n    }");
insert Statement(5081, 5080, "if (_provider == address(0)) revert InvalidProvider();");
insert IfStatement(5082, 5081, "if (_provider == address(0)) revert InvalidProvider();");
insert Expression(5083, 5082, "_provider == address(0)");
insert BinaryExpression(5084, 5083, "_provider == address(0)");
insert Expression(5085, 5084, "_provider");
insert Identifier(5086, 5085, "_provider");
insert Expression(5087, 5084, "address(0)");
insert TypeCastExpression(5088, 5087, "address(0)");
insert PrimitiveType(5089, 5088, "address");
insert CallArgument(5090, 5088, "0");
insert Expression(5091, 5090, "0");
insert NumberLiteral(5092, 5091, "0");
insert Statement(5093, 5082, "revert InvalidProvider();");
insert RevertStatement(5094, 5093, "revert InvalidProvider();");
insert Expression(5095, 5094, "InvalidProvider");
insert Identifier(5096, 5095, "InvalidProvider");
insert RevertArguments(5097, 5094, "()");
insert Statement(5098, 5080, "_updateProvider(_provider);");
insert ExpressionStatement(5099, 5098, "_updateProvider(_provider);");
insert Expression(5100, 5099, "_updateProvider(_provider)");
insert CallExpression(5101, 5100, "_updateProvider(_provider)");
insert Expression(5102, 5101, "_updateProvider");
insert Identifier(5103, 5102, "_updateProvider");
insert CallArgument(5104, 5101, "_provider");
insert Expression(5105, 5104, "_provider");
insert Identifier(5106, 5105, "_provider");
insert Comment(5107, 4838, "/**\n     * @notice Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded.\n     */");
insert FunctionDefinition(5108, 4838, "function _handleData(bytes calldata _data) internal virtual override {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address\n                )\n            );\n\n        if (_providerReceiver == address(0)) revert InvalidProviderReceiver();\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        providerReceiver = _providerReceiver;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }");
insert Identifier(5109, 5108, "_handleData");
insert Parameter(5110, 5108, "bytes calldata _data");
insert TypeName(5111, 5110, "bytes");
insert PrimitiveType(5112, 5111, "bytes");
insert Identifier(5113, 5110, "_data");
insert Visibility(5114, 5108, "internal");
insert Virtual(5115, 5108, "virtual");
insert OverrideSpecifier(5116, 5108, "override");
insert FunctionBody(5117, 5108, "{\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address\n                )\n            );\n\n        if (_providerReceiver == address(0)) revert InvalidProviderReceiver();\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        providerReceiver = _providerReceiver;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }");
insert Statement(5118, 5117, "(\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address\n                )\n            );");
insert VariableDeclarationStatement(5119, 5118, "(\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address\n                )\n            );");
insert VariableDeclarationTuple(5120, 5119, "(\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver\n        )");
insert VariableDeclaration(5121, 5120, "address _client");
insert TypeName(5122, 5121, "address");
insert PrimitiveType(5123, 5122, "address");
insert Identifier(5124, 5121, "_client");
insert VariableDeclaration(5125, 5120, "uint8 _resolverType");
insert TypeName(5126, 5125, "uint8");
insert PrimitiveType(5127, 5126, "uint8");
insert Identifier(5128, 5125, "_resolverType");
insert VariableDeclaration(5129, 5120, "address _resolver");
insert TypeName(5130, 5129, "address");
insert PrimitiveType(5131, 5130, "address");
insert Identifier(5132, 5129, "_resolver");
insert VariableDeclaration(5133, 5120, "address _token");
insert TypeName(5134, 5133, "address");
insert PrimitiveType(5135, 5134, "address");
insert Identifier(5136, 5133, "_token");
insert VariableDeclaration(5137, 5120, "uint256 _terminationTime");
insert TypeName(5138, 5137, "uint256");
insert PrimitiveType(5139, 5138, "uint256");
insert Identifier(5140, 5137, "_terminationTime");
insert Comment(5141, 5120, "// exact termination date in seconds since epoch");
insert VariableDeclaration(5142, 5120, "bytes32 _details");
insert TypeName(5143, 5142, "bytes32");
insert PrimitiveType(5144, 5143, "bytes32");
insert Identifier(5145, 5142, "_details");
insert VariableDeclaration(5146, 5120, "address _wrappedNativeToken");
insert TypeName(5147, 5146, "address");
insert PrimitiveType(5148, 5147, "address");
insert Identifier(5149, 5146, "_wrappedNativeToken");
insert VariableDeclaration(5150, 5120, "bool _requireVerification");
insert TypeName(5151, 5150, "bool");
insert PrimitiveType(5152, 5151, "bool");
insert Identifier(5153, 5150, "_requireVerification");
insert VariableDeclaration(5154, 5120, "address _factory");
insert TypeName(5155, 5154, "address");
insert PrimitiveType(5156, 5155, "address");
insert Identifier(5157, 5154, "_factory");
insert VariableDeclaration(5158, 5120, "address _providerReceiver");
insert TypeName(5159, 5158, "address");
insert PrimitiveType(5160, 5159, "address");
insert Identifier(5161, 5158, "_providerReceiver");
insert Expression(5162, 5119, "abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address\n                )\n            )");
insert CallExpression(5163, 5162, "abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address\n                )\n            )");
insert Expression(5164, 5163, "abi.decode");
insert MemberExpression(5165, 5164, "abi.decode");
insert Identifier(5166, 5165, "abi");
insert Identifier(5167, 5165, "decode");
insert CallArgument(5168, 5163, "_data");
insert Expression(5169, 5168, "_data");
insert Identifier(5170, 5169, "_data");
insert CallArgument(5171, 5163, "(\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address\n                )");
insert Expression(5172, 5171, "(\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address\n                )");
insert TupleExpression(5173, 5172, "(\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address\n                )");
insert Expression(5174, 5173, "address");
insert PrimitiveType(5175, 5174, "address");
insert Expression(5176, 5173, "uint8");
insert PrimitiveType(5177, 5176, "uint8");
insert Expression(5178, 5173, "address");
insert PrimitiveType(5179, 5178, "address");
insert Expression(5180, 5173, "address");
insert PrimitiveType(5181, 5180, "address");
insert Expression(5182, 5173, "uint256");
insert PrimitiveType(5183, 5182, "uint256");
insert Expression(5184, 5173, "bytes32");
insert PrimitiveType(5185, 5184, "bytes32");
insert Expression(5186, 5173, "address");
insert PrimitiveType(5187, 5186, "address");
insert Expression(5188, 5173, "bool");
insert PrimitiveType(5189, 5188, "bool");
insert Expression(5190, 5173, "address");
insert PrimitiveType(5191, 5190, "address");
insert Expression(5192, 5173, "address");
insert PrimitiveType(5193, 5192, "address");
insert Statement(5194, 5117, "if (_providerReceiver == address(0)) revert InvalidProviderReceiver();");
insert IfStatement(5195, 5194, "if (_providerReceiver == address(0)) revert InvalidProviderReceiver();");
insert Expression(5196, 5195, "_providerReceiver == address(0)");
insert BinaryExpression(5197, 5196, "_providerReceiver == address(0)");
insert Expression(5198, 5197, "_providerReceiver");
insert Identifier(5199, 5198, "_providerReceiver");
insert Expression(5200, 5197, "address(0)");
insert TypeCastExpression(5201, 5200, "address(0)");
insert PrimitiveType(5202, 5201, "address");
insert CallArgument(5203, 5201, "0");
insert Expression(5204, 5203, "0");
insert NumberLiteral(5205, 5204, "0");
insert Statement(5206, 5195, "revert InvalidProviderReceiver();");
insert RevertStatement(5207, 5206, "revert InvalidProviderReceiver();");
insert Expression(5208, 5207, "InvalidProviderReceiver");
insert Identifier(5209, 5208, "InvalidProviderReceiver");
insert RevertArguments(5210, 5207, "()");
insert Statement(5211, 5117, "if (_client == address(0)) revert InvalidClient();");
insert IfStatement(5212, 5211, "if (_client == address(0)) revert InvalidClient();");
insert Expression(5213, 5212, "_client == address(0)");
insert BinaryExpression(5214, 5213, "_client == address(0)");
insert Expression(5215, 5214, "_client");
insert Identifier(5216, 5215, "_client");
insert Expression(5217, 5214, "address(0)");
insert TypeCastExpression(5218, 5217, "address(0)");
insert PrimitiveType(5219, 5218, "address");
insert CallArgument(5220, 5218, "0");
insert Expression(5221, 5220, "0");
insert NumberLiteral(5222, 5221, "0");
insert Statement(5223, 5212, "revert InvalidClient();");
insert RevertStatement(5224, 5223, "revert InvalidClient();");
insert Expression(5225, 5224, "InvalidClient");
insert Identifier(5226, 5225, "InvalidClient");
insert RevertArguments(5227, 5224, "()");
insert Statement(5228, 5117, "if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();");
insert IfStatement(5229, 5228, "if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();");
insert Expression(5230, 5229, "_resolverType > uint8(ADR.ARBITRATOR)");
insert BinaryExpression(5231, 5230, "_resolverType > uint8(ADR.ARBITRATOR)");
insert Expression(5232, 5231, "_resolverType");
insert Identifier(5233, 5232, "_resolverType");
insert Expression(5234, 5231, "uint8(ADR.ARBITRATOR)");
insert TypeCastExpression(5235, 5234, "uint8(ADR.ARBITRATOR)");
insert PrimitiveType(5236, 5235, "uint8");
insert CallArgument(5237, 5235, "ADR.ARBITRATOR");
insert Expression(5238, 5237, "ADR.ARBITRATOR");
insert MemberExpression(5239, 5238, "ADR.ARBITRATOR");
insert Identifier(5240, 5239, "ADR");
insert Identifier(5241, 5239, "ARBITRATOR");
insert Statement(5242, 5229, "revert InvalidResolverType();");
insert RevertStatement(5243, 5242, "revert InvalidResolverType();");
insert Expression(5244, 5243, "InvalidResolverType");
insert Identifier(5245, 5244, "InvalidResolverType");
insert RevertArguments(5246, 5243, "()");
insert Statement(5247, 5117, "if (_resolver == address(0)) revert InvalidResolver();");
insert IfStatement(5248, 5247, "if (_resolver == address(0)) revert InvalidResolver();");
insert Expression(5249, 5248, "_resolver == address(0)");
insert BinaryExpression(5250, 5249, "_resolver == address(0)");
insert Expression(5251, 5250, "_resolver");
insert Identifier(5252, 5251, "_resolver");
insert Expression(5253, 5250, "address(0)");
insert TypeCastExpression(5254, 5253, "address(0)");
insert PrimitiveType(5255, 5254, "address");
insert CallArgument(5256, 5254, "0");
insert Expression(5257, 5256, "0");
insert NumberLiteral(5258, 5257, "0");
insert Statement(5259, 5248, "revert InvalidResolver();");
insert RevertStatement(5260, 5259, "revert InvalidResolver();");
insert Expression(5261, 5260, "InvalidResolver");
insert Identifier(5262, 5261, "InvalidResolver");
insert RevertArguments(5263, 5260, "()");
insert Statement(5264, 5117, "if (_token == address(0)) revert InvalidToken();");
insert IfStatement(5265, 5264, "if (_token == address(0)) revert InvalidToken();");
insert Expression(5266, 5265, "_token == address(0)");
insert BinaryExpression(5267, 5266, "_token == address(0)");
insert Expression(5268, 5267, "_token");
insert Identifier(5269, 5268, "_token");
insert Expression(5270, 5267, "address(0)");
insert TypeCastExpression(5271, 5270, "address(0)");
insert PrimitiveType(5272, 5271, "address");
insert CallArgument(5273, 5271, "0");
insert Expression(5274, 5273, "0");
insert NumberLiteral(5275, 5274, "0");
insert Statement(5276, 5265, "revert InvalidToken();");
insert RevertStatement(5277, 5276, "revert InvalidToken();");
insert Expression(5278, 5277, "InvalidToken");
insert Identifier(5279, 5278, "InvalidToken");
insert RevertArguments(5280, 5277, "()");
insert Statement(5281, 5117, "if (_terminationTime <= block.timestamp) revert DurationEnded();");
insert IfStatement(5282, 5281, "if (_terminationTime <= block.timestamp) revert DurationEnded();");
insert Expression(5283, 5282, "_terminationTime <= block.timestamp");
insert BinaryExpression(5284, 5283, "_terminationTime <= block.timestamp");
insert Expression(5285, 5284, "_terminationTime");
insert Identifier(5286, 5285, "_terminationTime");
insert Expression(5287, 5284, "block.timestamp");
insert MemberExpression(5288, 5287, "block.timestamp");
insert Identifier(5289, 5288, "block");
insert Identifier(5290, 5288, "timestamp");
insert Statement(5291, 5282, "revert DurationEnded();");
insert RevertStatement(5292, 5291, "revert DurationEnded();");
insert Expression(5293, 5292, "DurationEnded");
insert Identifier(5294, 5293, "DurationEnded");
insert RevertArguments(5295, 5292, "()");
insert Statement(5296, 5117, "if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();");
insert IfStatement(5297, 5296, "if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();");
insert Expression(5298, 5297, "_terminationTime > block.timestamp + MAX_TERMINATION_TIME");
insert BinaryExpression(5299, 5298, "_terminationTime > block.timestamp + MAX_TERMINATION_TIME");
insert Expression(5300, 5299, "_terminationTime > block.timestamp");
insert MemberExpression(5301, 5300, "_terminationTime > block.timestamp");
insert Expression(5302, 5301, "_terminationTime > block");
insert BinaryExpression(5303, 5302, "_terminationTime > block");
insert Expression(5304, 5303, "_terminationTime");
insert Identifier(5305, 5304, "_terminationTime");
insert Expression(5306, 5303, "block");
insert Identifier(5307, 5306, "block");
insert Identifier(5308, 5301, "timestamp");
insert Expression(5309, 5299, "MAX_TERMINATION_TIME");
insert Identifier(5310, 5309, "MAX_TERMINATION_TIME");
insert Statement(5311, 5297, "revert DurationTooLong();");
insert RevertStatement(5312, 5311, "revert DurationTooLong();");
insert Expression(5313, 5312, "DurationTooLong");
insert Identifier(5314, 5313, "DurationTooLong");
insert RevertArguments(5315, 5312, "()");
insert Statement(5316, 5117, "if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();");
insert IfStatement(5317, 5316, "if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();");
insert Expression(5318, 5317, "_wrappedNativeToken == address(0)");
insert BinaryExpression(5319, 5318, "_wrappedNativeToken == address(0)");
insert Expression(5320, 5319, "_wrappedNativeToken");
insert Identifier(5321, 5320, "_wrappedNativeToken");
insert Expression(5322, 5319, "address(0)");
insert TypeCastExpression(5323, 5322, "address(0)");
insert PrimitiveType(5324, 5323, "address");
insert CallArgument(5325, 5323, "0");
insert Expression(5326, 5325, "0");
insert NumberLiteral(5327, 5326, "0");
insert Statement(5328, 5317, "revert InvalidWrappedNativeToken();");
insert RevertStatement(5329, 5328, "revert InvalidWrappedNativeToken();");
insert Expression(5330, 5329, "InvalidWrappedNativeToken");
insert Identifier(5331, 5330, "InvalidWrappedNativeToken");
insert RevertArguments(5332, 5329, "()");
insert Statement(5333, 5117, "uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);");
insert VariableDeclarationStatement(5334, 5333, "uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);");
insert VariableDeclaration(5335, 5334, "uint256 _resolutionRate");
insert TypeName(5336, 5335, "uint256");
insert PrimitiveType(5337, 5336, "uint256");
insert Identifier(5338, 5335, "_resolutionRate");
insert Expression(5339, 5334, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver)");
insert CallExpression(5340, 5339, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver)");
insert Expression(5341, 5340, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf");
insert MemberExpression(5342, 5341, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf");
insert Expression(5343, 5342, "ISmartInvoiceFactory(_factory)");
insert CallExpression(5344, 5343, "ISmartInvoiceFactory(_factory)");
insert Expression(5345, 5344, "ISmartInvoiceFactory");
insert Identifier(5346, 5345, "ISmartInvoiceFactory");
insert CallArgument(5347, 5344, "_factory");
insert Expression(5348, 5347, "_factory");
insert Identifier(5349, 5348, "_factory");
insert Identifier(5350, 5342, "resolutionRateOf");
insert CallArgument(5351, 5340, "_resolver");
insert Expression(5352, 5351, "_resolver");
insert Identifier(5353, 5352, "_resolver");
insert Statement(5354, 5117, "if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }");
insert IfStatement(5355, 5354, "if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }");
insert Expression(5356, 5355, "_resolutionRate == 0");
insert BinaryExpression(5357, 5356, "_resolutionRate == 0");
insert Expression(5358, 5357, "_resolutionRate");
insert Identifier(5359, 5358, "_resolutionRate");
insert Expression(5360, 5357, "0");
insert NumberLiteral(5361, 5360, "0");
insert Statement(5362, 5355, "{\n            _resolutionRate = 20;\n        }");
insert BlockStatement(5363, 5362, "{\n            _resolutionRate = 20;\n        }");
insert Statement(5364, 5363, "_resolutionRate = 20;");
insert ExpressionStatement(5365, 5364, "_resolutionRate = 20;");
insert Expression(5366, 5365, "_resolutionRate = 20");
insert AssignmentExpression(5367, 5366, "_resolutionRate = 20");
insert Expression(5368, 5367, "_resolutionRate");
insert Identifier(5369, 5368, "_resolutionRate");
insert Expression(5370, 5367, "20");
insert NumberLiteral(5371, 5370, "20");
insert Statement(5372, 5117, "client = _client;");
insert ExpressionStatement(5373, 5372, "client = _client;");
insert Expression(5374, 5373, "client = _client");
insert AssignmentExpression(5375, 5374, "client = _client");
insert Expression(5376, 5375, "client");
insert Identifier(5377, 5376, "client");
insert Expression(5378, 5375, "_client");
insert Identifier(5379, 5378, "_client");
insert Statement(5380, 5117, "resolverType = ADR(_resolverType);");
insert ExpressionStatement(5381, 5380, "resolverType = ADR(_resolverType);");
insert Expression(5382, 5381, "resolverType = ADR(_resolverType)");
insert AssignmentExpression(5383, 5382, "resolverType = ADR(_resolverType)");
insert Expression(5384, 5383, "resolverType");
insert Identifier(5385, 5384, "resolverType");
insert Expression(5386, 5383, "ADR(_resolverType)");
insert CallExpression(5387, 5386, "ADR(_resolverType)");
insert Expression(5388, 5387, "ADR");
insert Identifier(5389, 5388, "ADR");
insert CallArgument(5390, 5387, "_resolverType");
insert Expression(5391, 5390, "_resolverType");
insert Identifier(5392, 5391, "_resolverType");
insert Statement(5393, 5117, "resolver = _resolver;");
insert ExpressionStatement(5394, 5393, "resolver = _resolver;");
insert Expression(5395, 5394, "resolver = _resolver");
insert AssignmentExpression(5396, 5395, "resolver = _resolver");
insert Expression(5397, 5396, "resolver");
insert Identifier(5398, 5397, "resolver");
insert Expression(5399, 5396, "_resolver");
insert Identifier(5400, 5399, "_resolver");
insert Statement(5401, 5117, "token = _token;");
insert ExpressionStatement(5402, 5401, "token = _token;");
insert Expression(5403, 5402, "token = _token");
insert AssignmentExpression(5404, 5403, "token = _token");
insert Expression(5405, 5404, "token");
insert Identifier(5406, 5405, "token");
insert Expression(5407, 5404, "_token");
insert Identifier(5408, 5407, "_token");
insert Statement(5409, 5117, "terminationTime = _terminationTime;");
insert ExpressionStatement(5410, 5409, "terminationTime = _terminationTime;");
insert Expression(5411, 5410, "terminationTime = _terminationTime");
insert AssignmentExpression(5412, 5411, "terminationTime = _terminationTime");
insert Expression(5413, 5412, "terminationTime");
insert Identifier(5414, 5413, "terminationTime");
insert Expression(5415, 5412, "_terminationTime");
insert Identifier(5416, 5415, "_terminationTime");
insert Statement(5417, 5117, "resolutionRate = _resolutionRate;");
insert ExpressionStatement(5418, 5417, "resolutionRate = _resolutionRate;");
insert Expression(5419, 5418, "resolutionRate = _resolutionRate");
insert AssignmentExpression(5420, 5419, "resolutionRate = _resolutionRate");
insert Expression(5421, 5420, "resolutionRate");
insert Identifier(5422, 5421, "resolutionRate");
insert Expression(5423, 5420, "_resolutionRate");
insert Identifier(5424, 5423, "_resolutionRate");
insert Statement(5425, 5117, "details = _details;");
insert ExpressionStatement(5426, 5425, "details = _details;");
insert Expression(5427, 5426, "details = _details");
insert AssignmentExpression(5428, 5427, "details = _details");
insert Expression(5429, 5428, "details");
insert Identifier(5430, 5429, "details");
insert Expression(5431, 5428, "_details");
insert Identifier(5432, 5431, "_details");
insert Statement(5433, 5117, "wrappedNativeToken = _wrappedNativeToken;");
insert ExpressionStatement(5434, 5433, "wrappedNativeToken = _wrappedNativeToken;");
insert Expression(5435, 5434, "wrappedNativeToken = _wrappedNativeToken");
insert AssignmentExpression(5436, 5435, "wrappedNativeToken = _wrappedNativeToken");
insert Expression(5437, 5436, "wrappedNativeToken");
insert Identifier(5438, 5437, "wrappedNativeToken");
insert Expression(5439, 5436, "_wrappedNativeToken");
insert Identifier(5440, 5439, "_wrappedNativeToken");
insert Statement(5441, 5117, "providerReceiver = _providerReceiver;");
insert ExpressionStatement(5442, 5441, "providerReceiver = _providerReceiver;");
insert Expression(5443, 5442, "providerReceiver = _providerReceiver");
insert AssignmentExpression(5444, 5443, "providerReceiver = _providerReceiver");
insert Expression(5445, 5444, "providerReceiver");
insert Identifier(5446, 5445, "providerReceiver");
insert Expression(5447, 5444, "_providerReceiver");
insert Identifier(5448, 5447, "_providerReceiver");
insert Statement(5449, 5117, "if (!_requireVerification) emit Verified(client, address(this));");
insert IfStatement(5450, 5449, "if (!_requireVerification) emit Verified(client, address(this));");
insert Expression(5451, 5450, "!_requireVerification");
insert UnaryExpression(5452, 5451, "!_requireVerification");
insert Expression(5453, 5452, "_requireVerification");
insert Identifier(5454, 5453, "_requireVerification");
insert Statement(5455, 5450, "emit Verified(client, address(this));");
insert EmitStatement(5456, 5455, "emit Verified(client, address(this));");
insert Expression(5457, 5456, "Verified");
insert Identifier(5458, 5457, "Verified");
insert CallArgument(5459, 5456, "client");
insert Expression(5460, 5459, "client");
insert Identifier(5461, 5460, "client");
insert CallArgument(5462, 5456, "address(this)");
insert Expression(5463, 5462, "address(this)");
insert TypeCastExpression(5464, 5463, "address(this)");
insert PrimitiveType(5465, 5464, "address");
insert CallArgument(5466, 5464, "this");
insert Expression(5467, 5466, "this");
insert Identifier(5468, 5467, "this");
insert Comment(5469, 4838, "/**\n     * @dev Internal function to transfer payment to the provider's receiver.\n     * @param _token The address of the token to transfer.\n     * @param _amount The amount of tokens to transfer.\n     */");
insert FunctionDefinition(5470, 4838, "function _transferPayment(\n        address _token,\n        uint256 _amount\n    ) internal virtual override {\n        IERC20(_token).safeTransfer(providerReceiver, _amount);\n    }");
insert Identifier(5471, 5470, "_transferPayment");
insert Parameter(5472, 5470, "address _token");
insert TypeName(5473, 5472, "address");
insert PrimitiveType(5474, 5473, "address");
insert Identifier(5475, 5472, "_token");
insert Parameter(5476, 5470, "uint256 _amount");
insert TypeName(5477, 5476, "uint256");
insert PrimitiveType(5478, 5477, "uint256");
insert Identifier(5479, 5476, "_amount");
insert Visibility(5480, 5470, "internal");
insert Virtual(5481, 5470, "virtual");
insert OverrideSpecifier(5482, 5470, "override");
insert FunctionBody(5483, 5470, "{\n        IERC20(_token).safeTransfer(providerReceiver, _amount);\n    }");
insert Statement(5484, 5483, "IERC20(_token).safeTransfer(providerReceiver, _amount);");
insert ExpressionStatement(5485, 5484, "IERC20(_token).safeTransfer(providerReceiver, _amount);");
insert Expression(5486, 5485, "IERC20(_token).safeTransfer(providerReceiver, _amount)");
insert CallExpression(5487, 5486, "IERC20(_token).safeTransfer(providerReceiver, _amount)");
insert Expression(5488, 5487, "IERC20(_token).safeTransfer");
insert MemberExpression(5489, 5488, "IERC20(_token).safeTransfer");
insert Expression(5490, 5489, "IERC20(_token)");
insert CallExpression(5491, 5490, "IERC20(_token)");
insert Expression(5492, 5491, "IERC20");
insert Identifier(5493, 5492, "IERC20");
insert CallArgument(5494, 5491, "_token");
insert Expression(5495, 5494, "_token");
insert Identifier(5496, 5495, "_token");
insert Identifier(5497, 5489, "safeTransfer");
insert CallArgument(5498, 5487, "providerReceiver");
insert Expression(5499, 5498, "providerReceiver");
insert Identifier(5500, 5499, "providerReceiver");
insert CallArgument(5501, 5487, "_amount");
insert Expression(5502, 5501, "_amount");
insert Identifier(5503, 5502, "_amount");
insert SourceFile(5504, 0, "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";\nimport {SmartInvoiceUpdatable} from \"./SmartInvoiceUpdatable.sol\";\n\n/// @title SmartInvoiceUpdatableV2\n/// @notice An updatable smart invoice escrow contract with embedded arbitration tailored for guild work.\ncontract SmartInvoiceUpdatableV2 is SmartInvoiceUpdatable {\n    using SafeERC20 for IERC20;\n\n    /// @notice The receiving address for the provider.\n    address public clientReceiver;\n\n    /// @dev Custom errors for more efficient gas usage.\n    error InvalidClientReceiver();\n\n    /// @notice Emitted when the client's receiver address is updated.\n    /// @param clientReceiver The updated client receiver address.\n    event UpdatedClientReceiver(address indexed clientReceiver);\n\n    /**\n     * @notice Internal function for updating the client's receiver address.\n     * @param _clientReceiver The updated client receiver address.\n     */\n    function _updateClientReceiver(address _clientReceiver) internal {\n        clientReceiver = _clientReceiver;\n        emit UpdatedClientReceiver(_clientReceiver);\n    }\n\n    /**\n     * @notice Updates the client's receiver address.\n     * @param _clientReceiver The updated client receiver address.\n     */\n    function updateClientReceiver(address _clientReceiver) external onlyClient {\n        if (_clientReceiver == address(0)) revert InvalidClientReceiver();\n        _updateClientReceiver(_clientReceiver);\n    }\n\n    /**\n     * @notice Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded.\n     */\n    function _handleData(bytes calldata _data) internal override {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver,\n            address _clientReceiver\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    address\n                )\n            );\n\n        if (_clientReceiver == address(0)) revert InvalidClientReceiver();\n        if (_providerReceiver == address(0)) revert InvalidProviderReceiver();\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        providerReceiver = _providerReceiver;\n        clientReceiver = _clientReceiver;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }\n\n    /**\n     * @dev Internal function to withdraw payment to the client's receiver.\n     * @param _token The address of the token to transfer.\n     * @param _amount The amount of tokens to transfer.\n     */\n    function _withdrawDeposit(\n        address _token,\n        uint256 _amount\n    ) internal virtual override {\n        IERC20(_token).safeTransfer(clientReceiver, _amount);\n    }\n}\n");
insert Comment(5505, 5504, "// SPDX-License-Identifier: MIT");
insert PragmaDirective(5506, 5504, "pragma solidity ^0.8.20;");
insert SolidityPragmaToken(5507, 5506, "solidity ^0.8.20");
insert SolidityVersionComparisonOperator(5508, 5507, " ^");
insert SolidityVersion(5509, 5507, "0.8.20");
insert ImportDirective(5510, 5504, "import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";");
insert Identifier(5511, 5510, "IERC20");
insert ImportDirective(5512, 5504, "import {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";");
insert Identifier(5513, 5512, "SafeERC20");
insert ImportDirective(5514, 5504, "import {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";");
insert Identifier(5515, 5514, "ISmartInvoiceFactory");
insert ImportDirective(5516, 5504, "import {SmartInvoiceUpdatable} from \"./SmartInvoiceUpdatable.sol\";");
insert Identifier(5517, 5516, "SmartInvoiceUpdatable");
insert Comment(5518, 5504, "/// @title SmartInvoiceUpdatableV2");
insert Comment(5519, 5504, "/// @notice An updatable smart invoice escrow contract with embedded arbitration tailored for guild work.");
insert ContractDeclaration(5520, 5504, "contract SmartInvoiceUpdatableV2 is SmartInvoiceUpdatable {\n    using SafeERC20 for IERC20;\n\n    /// @notice The receiving address for the provider.\n    address public clientReceiver;\n\n    /// @dev Custom errors for more efficient gas usage.\n    error InvalidClientReceiver();\n\n    /// @notice Emitted when the client's receiver address is updated.\n    /// @param clientReceiver The updated client receiver address.\n    event UpdatedClientReceiver(address indexed clientReceiver);\n\n    /**\n     * @notice Internal function for updating the client's receiver address.\n     * @param _clientReceiver The updated client receiver address.\n     */\n    function _updateClientReceiver(address _clientReceiver) internal {\n        clientReceiver = _clientReceiver;\n        emit UpdatedClientReceiver(_clientReceiver);\n    }\n\n    /**\n     * @notice Updates the client's receiver address.\n     * @param _clientReceiver The updated client receiver address.\n     */\n    function updateClientReceiver(address _clientReceiver) external onlyClient {\n        if (_clientReceiver == address(0)) revert InvalidClientReceiver();\n        _updateClientReceiver(_clientReceiver);\n    }\n\n    /**\n     * @notice Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded.\n     */\n    function _handleData(bytes calldata _data) internal override {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver,\n            address _clientReceiver\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    address\n                )\n            );\n\n        if (_clientReceiver == address(0)) revert InvalidClientReceiver();\n        if (_providerReceiver == address(0)) revert InvalidProviderReceiver();\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        providerReceiver = _providerReceiver;\n        clientReceiver = _clientReceiver;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }\n\n    /**\n     * @dev Internal function to withdraw payment to the client's receiver.\n     * @param _token The address of the token to transfer.\n     * @param _amount The amount of tokens to transfer.\n     */\n    function _withdrawDeposit(\n        address _token,\n        uint256 _amount\n    ) internal virtual override {\n        IERC20(_token).safeTransfer(clientReceiver, _amount);\n    }\n}");
insert Identifier(5521, 5520, "SmartInvoiceUpdatableV2");
insert InheritanceSpecifier(5522, 5520, "SmartInvoiceUpdatable");
insert UserDefinedType(5523, 5522, "SmartInvoiceUpdatable");
insert Identifier(5524, 5523, "SmartInvoiceUpdatable");
insert ContractBody(5525, 5520, "{\n    using SafeERC20 for IERC20;\n\n    /// @notice The receiving address for the provider.\n    address public clientReceiver;\n\n    /// @dev Custom errors for more efficient gas usage.\n    error InvalidClientReceiver();\n\n    /// @notice Emitted when the client's receiver address is updated.\n    /// @param clientReceiver The updated client receiver address.\n    event UpdatedClientReceiver(address indexed clientReceiver);\n\n    /**\n     * @notice Internal function for updating the client's receiver address.\n     * @param _clientReceiver The updated client receiver address.\n     */\n    function _updateClientReceiver(address _clientReceiver) internal {\n        clientReceiver = _clientReceiver;\n        emit UpdatedClientReceiver(_clientReceiver);\n    }\n\n    /**\n     * @notice Updates the client's receiver address.\n     * @param _clientReceiver The updated client receiver address.\n     */\n    function updateClientReceiver(address _clientReceiver) external onlyClient {\n        if (_clientReceiver == address(0)) revert InvalidClientReceiver();\n        _updateClientReceiver(_clientReceiver);\n    }\n\n    /**\n     * @notice Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded.\n     */\n    function _handleData(bytes calldata _data) internal override {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver,\n            address _clientReceiver\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    address\n                )\n            );\n\n        if (_clientReceiver == address(0)) revert InvalidClientReceiver();\n        if (_providerReceiver == address(0)) revert InvalidProviderReceiver();\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        providerReceiver = _providerReceiver;\n        clientReceiver = _clientReceiver;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }\n\n    /**\n     * @dev Internal function to withdraw payment to the client's receiver.\n     * @param _token The address of the token to transfer.\n     * @param _amount The amount of tokens to transfer.\n     */\n    function _withdrawDeposit(\n        address _token,\n        uint256 _amount\n    ) internal virtual override {\n        IERC20(_token).safeTransfer(clientReceiver, _amount);\n    }\n}");
insert UsingDirective(5526, 5525, "using SafeERC20 for IERC20;");
insert TypeAlias(5527, 5526, "SafeERC20");
insert Identifier(5528, 5527, "SafeERC20");
insert TypeName(5529, 5526, "IERC20");
insert UserDefinedType(5530, 5529, "IERC20");
insert Identifier(5531, 5530, "IERC20");
insert Comment(5532, 5525, "/// @notice The receiving address for the provider.");
insert StateVariableDeclaration(5533, 5525, "address public clientReceiver;");
insert TypeName(5534, 5533, "address");
insert PrimitiveType(5535, 5534, "address");
insert Visibility(5536, 5533, "public");
insert Identifier(5537, 5533, "clientReceiver");
insert Comment(5538, 5525, "/// @dev Custom errors for more efficient gas usage.");
insert ErrorDeclaration(5539, 5525, "error InvalidClientReceiver();");
insert Identifier(5540, 5539, "InvalidClientReceiver");
insert Comment(5541, 5525, "/// @notice Emitted when the client's receiver address is updated.");
insert Comment(5542, 5525, "/// @param clientReceiver The updated client receiver address.");
insert EventDefinition(5543, 5525, "event UpdatedClientReceiver(address indexed clientReceiver);");
insert Identifier(5544, 5543, "UpdatedClientReceiver");
insert EventParameter(5545, 5543, "address indexed clientReceiver");
insert TypeName(5546, 5545, "address");
insert PrimitiveType(5547, 5546, "address");
insert Identifier(5548, 5545, "clientReceiver");
insert Comment(5549, 5525, "/**\n     * @notice Internal function for updating the client's receiver address.\n     * @param _clientReceiver The updated client receiver address.\n     */");
insert FunctionDefinition(5550, 5525, "function _updateClientReceiver(address _clientReceiver) internal {\n        clientReceiver = _clientReceiver;\n        emit UpdatedClientReceiver(_clientReceiver);\n    }");
insert Identifier(5551, 5550, "_updateClientReceiver");
insert Parameter(5552, 5550, "address _clientReceiver");
insert TypeName(5553, 5552, "address");
insert PrimitiveType(5554, 5553, "address");
insert Identifier(5555, 5552, "_clientReceiver");
insert Visibility(5556, 5550, "internal");
insert FunctionBody(5557, 5550, "{\n        clientReceiver = _clientReceiver;\n        emit UpdatedClientReceiver(_clientReceiver);\n    }");
insert Statement(5558, 5557, "clientReceiver = _clientReceiver;");
insert ExpressionStatement(5559, 5558, "clientReceiver = _clientReceiver;");
insert Expression(5560, 5559, "clientReceiver = _clientReceiver");
insert AssignmentExpression(5561, 5560, "clientReceiver = _clientReceiver");
insert Expression(5562, 5561, "clientReceiver");
insert Identifier(5563, 5562, "clientReceiver");
insert Expression(5564, 5561, "_clientReceiver");
insert Identifier(5565, 5564, "_clientReceiver");
insert Statement(5566, 5557, "emit UpdatedClientReceiver(_clientReceiver);");
insert EmitStatement(5567, 5566, "emit UpdatedClientReceiver(_clientReceiver);");
insert Expression(5568, 5567, "UpdatedClientReceiver");
insert Identifier(5569, 5568, "UpdatedClientReceiver");
insert CallArgument(5570, 5567, "_clientReceiver");
insert Expression(5571, 5570, "_clientReceiver");
insert Identifier(5572, 5571, "_clientReceiver");
insert Comment(5573, 5525, "/**\n     * @notice Updates the client's receiver address.\n     * @param _clientReceiver The updated client receiver address.\n     */");
insert FunctionDefinition(5574, 5525, "function updateClientReceiver(address _clientReceiver) external onlyClient {\n        if (_clientReceiver == address(0)) revert InvalidClientReceiver();\n        _updateClientReceiver(_clientReceiver);\n    }");
insert Identifier(5575, 5574, "updateClientReceiver");
insert Parameter(5576, 5574, "address _clientReceiver");
insert TypeName(5577, 5576, "address");
insert PrimitiveType(5578, 5577, "address");
insert Identifier(5579, 5576, "_clientReceiver");
insert Visibility(5580, 5574, "external");
insert ModifierInvocation(5581, 5574, "onlyClient");
insert Identifier(5582, 5581, "onlyClient");
insert FunctionBody(5583, 5574, "{\n        if (_clientReceiver == address(0)) revert InvalidClientReceiver();\n        _updateClientReceiver(_clientReceiver);\n    }");
insert Statement(5584, 5583, "if (_clientReceiver == address(0)) revert InvalidClientReceiver();");
insert IfStatement(5585, 5584, "if (_clientReceiver == address(0)) revert InvalidClientReceiver();");
insert Expression(5586, 5585, "_clientReceiver == address(0)");
insert BinaryExpression(5587, 5586, "_clientReceiver == address(0)");
insert Expression(5588, 5587, "_clientReceiver");
insert Identifier(5589, 5588, "_clientReceiver");
insert Expression(5590, 5587, "address(0)");
insert TypeCastExpression(5591, 5590, "address(0)");
insert PrimitiveType(5592, 5591, "address");
insert CallArgument(5593, 5591, "0");
insert Expression(5594, 5593, "0");
insert NumberLiteral(5595, 5594, "0");
insert Statement(5596, 5585, "revert InvalidClientReceiver();");
insert RevertStatement(5597, 5596, "revert InvalidClientReceiver();");
insert Expression(5598, 5597, "InvalidClientReceiver");
insert Identifier(5599, 5598, "InvalidClientReceiver");
insert RevertArguments(5600, 5597, "()");
insert Statement(5601, 5583, "_updateClientReceiver(_clientReceiver);");
insert ExpressionStatement(5602, 5601, "_updateClientReceiver(_clientReceiver);");
insert Expression(5603, 5602, "_updateClientReceiver(_clientReceiver)");
insert CallExpression(5604, 5603, "_updateClientReceiver(_clientReceiver)");
insert Expression(5605, 5604, "_updateClientReceiver");
insert Identifier(5606, 5605, "_updateClientReceiver");
insert CallArgument(5607, 5604, "_clientReceiver");
insert Expression(5608, 5607, "_clientReceiver");
insert Identifier(5609, 5608, "_clientReceiver");
insert Comment(5610, 5525, "/**\n     * @notice Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded.\n     */");
insert FunctionDefinition(5611, 5525, "function _handleData(bytes calldata _data) internal override {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver,\n            address _clientReceiver\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    address\n                )\n            );\n\n        if (_clientReceiver == address(0)) revert InvalidClientReceiver();\n        if (_providerReceiver == address(0)) revert InvalidProviderReceiver();\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        providerReceiver = _providerReceiver;\n        clientReceiver = _clientReceiver;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }");
insert Identifier(5612, 5611, "_handleData");
insert Parameter(5613, 5611, "bytes calldata _data");
insert TypeName(5614, 5613, "bytes");
insert PrimitiveType(5615, 5614, "bytes");
insert Identifier(5616, 5613, "_data");
insert Visibility(5617, 5611, "internal");
insert OverrideSpecifier(5618, 5611, "override");
insert FunctionBody(5619, 5611, "{\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver,\n            address _clientReceiver\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    address\n                )\n            );\n\n        if (_clientReceiver == address(0)) revert InvalidClientReceiver();\n        if (_providerReceiver == address(0)) revert InvalidProviderReceiver();\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n        providerReceiver = _providerReceiver;\n        clientReceiver = _clientReceiver;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }");
insert Statement(5620, 5619, "(\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver,\n            address _clientReceiver\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    address\n                )\n            );");
insert VariableDeclarationStatement(5621, 5620, "(\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver,\n            address _clientReceiver\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    address\n                )\n            );");
insert VariableDeclarationTuple(5622, 5621, "(\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime, // exact termination date in seconds since epoch\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory,\n            address _providerReceiver,\n            address _clientReceiver\n        )");
insert VariableDeclaration(5623, 5622, "address _client");
insert TypeName(5624, 5623, "address");
insert PrimitiveType(5625, 5624, "address");
insert Identifier(5626, 5623, "_client");
insert VariableDeclaration(5627, 5622, "uint8 _resolverType");
insert TypeName(5628, 5627, "uint8");
insert PrimitiveType(5629, 5628, "uint8");
insert Identifier(5630, 5627, "_resolverType");
insert VariableDeclaration(5631, 5622, "address _resolver");
insert TypeName(5632, 5631, "address");
insert PrimitiveType(5633, 5632, "address");
insert Identifier(5634, 5631, "_resolver");
insert VariableDeclaration(5635, 5622, "address _token");
insert TypeName(5636, 5635, "address");
insert PrimitiveType(5637, 5636, "address");
insert Identifier(5638, 5635, "_token");
insert VariableDeclaration(5639, 5622, "uint256 _terminationTime");
insert TypeName(5640, 5639, "uint256");
insert PrimitiveType(5641, 5640, "uint256");
insert Identifier(5642, 5639, "_terminationTime");
insert Comment(5643, 5622, "// exact termination date in seconds since epoch");
insert VariableDeclaration(5644, 5622, "bytes32 _details");
insert TypeName(5645, 5644, "bytes32");
insert PrimitiveType(5646, 5645, "bytes32");
insert Identifier(5647, 5644, "_details");
insert VariableDeclaration(5648, 5622, "address _wrappedNativeToken");
insert TypeName(5649, 5648, "address");
insert PrimitiveType(5650, 5649, "address");
insert Identifier(5651, 5648, "_wrappedNativeToken");
insert VariableDeclaration(5652, 5622, "bool _requireVerification");
insert TypeName(5653, 5652, "bool");
insert PrimitiveType(5654, 5653, "bool");
insert Identifier(5655, 5652, "_requireVerification");
insert VariableDeclaration(5656, 5622, "address _factory");
insert TypeName(5657, 5656, "address");
insert PrimitiveType(5658, 5657, "address");
insert Identifier(5659, 5656, "_factory");
insert VariableDeclaration(5660, 5622, "address _providerReceiver");
insert TypeName(5661, 5660, "address");
insert PrimitiveType(5662, 5661, "address");
insert Identifier(5663, 5660, "_providerReceiver");
insert VariableDeclaration(5664, 5622, "address _clientReceiver");
insert TypeName(5665, 5664, "address");
insert PrimitiveType(5666, 5665, "address");
insert Identifier(5667, 5664, "_clientReceiver");
insert Expression(5668, 5621, "abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    address\n                )\n            )");
insert CallExpression(5669, 5668, "abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    address\n                )\n            )");
insert Expression(5670, 5669, "abi.decode");
insert MemberExpression(5671, 5670, "abi.decode");
insert Identifier(5672, 5671, "abi");
insert Identifier(5673, 5671, "decode");
insert CallArgument(5674, 5669, "_data");
insert Expression(5675, 5674, "_data");
insert Identifier(5676, 5675, "_data");
insert CallArgument(5677, 5669, "(\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    address\n                )");
insert Expression(5678, 5677, "(\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    address\n                )");
insert TupleExpression(5679, 5678, "(\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address,\n                    address,\n                    address\n                )");
insert Expression(5680, 5679, "address");
insert PrimitiveType(5681, 5680, "address");
insert Expression(5682, 5679, "uint8");
insert PrimitiveType(5683, 5682, "uint8");
insert Expression(5684, 5679, "address");
insert PrimitiveType(5685, 5684, "address");
insert Expression(5686, 5679, "address");
insert PrimitiveType(5687, 5686, "address");
insert Expression(5688, 5679, "uint256");
insert PrimitiveType(5689, 5688, "uint256");
insert Expression(5690, 5679, "bytes32");
insert PrimitiveType(5691, 5690, "bytes32");
insert Expression(5692, 5679, "address");
insert PrimitiveType(5693, 5692, "address");
insert Expression(5694, 5679, "bool");
insert PrimitiveType(5695, 5694, "bool");
insert Expression(5696, 5679, "address");
insert PrimitiveType(5697, 5696, "address");
insert Expression(5698, 5679, "address");
insert PrimitiveType(5699, 5698, "address");
insert Expression(5700, 5679, "address");
insert PrimitiveType(5701, 5700, "address");
insert Statement(5702, 5619, "if (_clientReceiver == address(0)) revert InvalidClientReceiver();");
insert IfStatement(5703, 5702, "if (_clientReceiver == address(0)) revert InvalidClientReceiver();");
insert Expression(5704, 5703, "_clientReceiver == address(0)");
insert BinaryExpression(5705, 5704, "_clientReceiver == address(0)");
insert Expression(5706, 5705, "_clientReceiver");
insert Identifier(5707, 5706, "_clientReceiver");
insert Expression(5708, 5705, "address(0)");
insert TypeCastExpression(5709, 5708, "address(0)");
insert PrimitiveType(5710, 5709, "address");
insert CallArgument(5711, 5709, "0");
insert Expression(5712, 5711, "0");
insert NumberLiteral(5713, 5712, "0");
insert Statement(5714, 5703, "revert InvalidClientReceiver();");
insert RevertStatement(5715, 5714, "revert InvalidClientReceiver();");
insert Expression(5716, 5715, "InvalidClientReceiver");
insert Identifier(5717, 5716, "InvalidClientReceiver");
insert RevertArguments(5718, 5715, "()");
insert Statement(5719, 5619, "if (_providerReceiver == address(0)) revert InvalidProviderReceiver();");
insert IfStatement(5720, 5719, "if (_providerReceiver == address(0)) revert InvalidProviderReceiver();");
insert Expression(5721, 5720, "_providerReceiver == address(0)");
insert BinaryExpression(5722, 5721, "_providerReceiver == address(0)");
insert Expression(5723, 5722, "_providerReceiver");
insert Identifier(5724, 5723, "_providerReceiver");
insert Expression(5725, 5722, "address(0)");
insert TypeCastExpression(5726, 5725, "address(0)");
insert PrimitiveType(5727, 5726, "address");
insert CallArgument(5728, 5726, "0");
insert Expression(5729, 5728, "0");
insert NumberLiteral(5730, 5729, "0");
insert Statement(5731, 5720, "revert InvalidProviderReceiver();");
insert RevertStatement(5732, 5731, "revert InvalidProviderReceiver();");
insert Expression(5733, 5732, "InvalidProviderReceiver");
insert Identifier(5734, 5733, "InvalidProviderReceiver");
insert RevertArguments(5735, 5732, "()");
insert Statement(5736, 5619, "if (_client == address(0)) revert InvalidClient();");
insert IfStatement(5737, 5736, "if (_client == address(0)) revert InvalidClient();");
insert Expression(5738, 5737, "_client == address(0)");
insert BinaryExpression(5739, 5738, "_client == address(0)");
insert Expression(5740, 5739, "_client");
insert Identifier(5741, 5740, "_client");
insert Expression(5742, 5739, "address(0)");
insert TypeCastExpression(5743, 5742, "address(0)");
insert PrimitiveType(5744, 5743, "address");
insert CallArgument(5745, 5743, "0");
insert Expression(5746, 5745, "0");
insert NumberLiteral(5747, 5746, "0");
insert Statement(5748, 5737, "revert InvalidClient();");
insert RevertStatement(5749, 5748, "revert InvalidClient();");
insert Expression(5750, 5749, "InvalidClient");
insert Identifier(5751, 5750, "InvalidClient");
insert RevertArguments(5752, 5749, "()");
insert Statement(5753, 5619, "if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();");
insert IfStatement(5754, 5753, "if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();");
insert Expression(5755, 5754, "_resolverType > uint8(ADR.ARBITRATOR)");
insert BinaryExpression(5756, 5755, "_resolverType > uint8(ADR.ARBITRATOR)");
insert Expression(5757, 5756, "_resolverType");
insert Identifier(5758, 5757, "_resolverType");
insert Expression(5759, 5756, "uint8(ADR.ARBITRATOR)");
insert TypeCastExpression(5760, 5759, "uint8(ADR.ARBITRATOR)");
insert PrimitiveType(5761, 5760, "uint8");
insert CallArgument(5762, 5760, "ADR.ARBITRATOR");
insert Expression(5763, 5762, "ADR.ARBITRATOR");
insert MemberExpression(5764, 5763, "ADR.ARBITRATOR");
insert Identifier(5765, 5764, "ADR");
insert Identifier(5766, 5764, "ARBITRATOR");
insert Statement(5767, 5754, "revert InvalidResolverType();");
insert RevertStatement(5768, 5767, "revert InvalidResolverType();");
insert Expression(5769, 5768, "InvalidResolverType");
insert Identifier(5770, 5769, "InvalidResolverType");
insert RevertArguments(5771, 5768, "()");
insert Statement(5772, 5619, "if (_resolver == address(0)) revert InvalidResolver();");
insert IfStatement(5773, 5772, "if (_resolver == address(0)) revert InvalidResolver();");
insert Expression(5774, 5773, "_resolver == address(0)");
insert BinaryExpression(5775, 5774, "_resolver == address(0)");
insert Expression(5776, 5775, "_resolver");
insert Identifier(5777, 5776, "_resolver");
insert Expression(5778, 5775, "address(0)");
insert TypeCastExpression(5779, 5778, "address(0)");
insert PrimitiveType(5780, 5779, "address");
insert CallArgument(5781, 5779, "0");
insert Expression(5782, 5781, "0");
insert NumberLiteral(5783, 5782, "0");
insert Statement(5784, 5773, "revert InvalidResolver();");
insert RevertStatement(5785, 5784, "revert InvalidResolver();");
insert Expression(5786, 5785, "InvalidResolver");
insert Identifier(5787, 5786, "InvalidResolver");
insert RevertArguments(5788, 5785, "()");
insert Statement(5789, 5619, "if (_token == address(0)) revert InvalidToken();");
insert IfStatement(5790, 5789, "if (_token == address(0)) revert InvalidToken();");
insert Expression(5791, 5790, "_token == address(0)");
insert BinaryExpression(5792, 5791, "_token == address(0)");
insert Expression(5793, 5792, "_token");
insert Identifier(5794, 5793, "_token");
insert Expression(5795, 5792, "address(0)");
insert TypeCastExpression(5796, 5795, "address(0)");
insert PrimitiveType(5797, 5796, "address");
insert CallArgument(5798, 5796, "0");
insert Expression(5799, 5798, "0");
insert NumberLiteral(5800, 5799, "0");
insert Statement(5801, 5790, "revert InvalidToken();");
insert RevertStatement(5802, 5801, "revert InvalidToken();");
insert Expression(5803, 5802, "InvalidToken");
insert Identifier(5804, 5803, "InvalidToken");
insert RevertArguments(5805, 5802, "()");
insert Statement(5806, 5619, "if (_terminationTime <= block.timestamp) revert DurationEnded();");
insert IfStatement(5807, 5806, "if (_terminationTime <= block.timestamp) revert DurationEnded();");
insert Expression(5808, 5807, "_terminationTime <= block.timestamp");
insert BinaryExpression(5809, 5808, "_terminationTime <= block.timestamp");
insert Expression(5810, 5809, "_terminationTime");
insert Identifier(5811, 5810, "_terminationTime");
insert Expression(5812, 5809, "block.timestamp");
insert MemberExpression(5813, 5812, "block.timestamp");
insert Identifier(5814, 5813, "block");
insert Identifier(5815, 5813, "timestamp");
insert Statement(5816, 5807, "revert DurationEnded();");
insert RevertStatement(5817, 5816, "revert DurationEnded();");
insert Expression(5818, 5817, "DurationEnded");
insert Identifier(5819, 5818, "DurationEnded");
insert RevertArguments(5820, 5817, "()");
insert Statement(5821, 5619, "if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();");
insert IfStatement(5822, 5821, "if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();");
insert Expression(5823, 5822, "_terminationTime > block.timestamp + MAX_TERMINATION_TIME");
insert BinaryExpression(5824, 5823, "_terminationTime > block.timestamp + MAX_TERMINATION_TIME");
insert Expression(5825, 5824, "_terminationTime > block.timestamp");
insert MemberExpression(5826, 5825, "_terminationTime > block.timestamp");
insert Expression(5827, 5826, "_terminationTime > block");
insert BinaryExpression(5828, 5827, "_terminationTime > block");
insert Expression(5829, 5828, "_terminationTime");
insert Identifier(5830, 5829, "_terminationTime");
insert Expression(5831, 5828, "block");
insert Identifier(5832, 5831, "block");
insert Identifier(5833, 5826, "timestamp");
insert Expression(5834, 5824, "MAX_TERMINATION_TIME");
insert Identifier(5835, 5834, "MAX_TERMINATION_TIME");
insert Statement(5836, 5822, "revert DurationTooLong();");
insert RevertStatement(5837, 5836, "revert DurationTooLong();");
insert Expression(5838, 5837, "DurationTooLong");
insert Identifier(5839, 5838, "DurationTooLong");
insert RevertArguments(5840, 5837, "()");
insert Statement(5841, 5619, "if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();");
insert IfStatement(5842, 5841, "if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();");
insert Expression(5843, 5842, "_wrappedNativeToken == address(0)");
insert BinaryExpression(5844, 5843, "_wrappedNativeToken == address(0)");
insert Expression(5845, 5844, "_wrappedNativeToken");
insert Identifier(5846, 5845, "_wrappedNativeToken");
insert Expression(5847, 5844, "address(0)");
insert TypeCastExpression(5848, 5847, "address(0)");
insert PrimitiveType(5849, 5848, "address");
insert CallArgument(5850, 5848, "0");
insert Expression(5851, 5850, "0");
insert NumberLiteral(5852, 5851, "0");
insert Statement(5853, 5842, "revert InvalidWrappedNativeToken();");
insert RevertStatement(5854, 5853, "revert InvalidWrappedNativeToken();");
insert Expression(5855, 5854, "InvalidWrappedNativeToken");
insert Identifier(5856, 5855, "InvalidWrappedNativeToken");
insert RevertArguments(5857, 5854, "()");
insert Statement(5858, 5619, "uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);");
insert VariableDeclarationStatement(5859, 5858, "uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);");
insert VariableDeclaration(5860, 5859, "uint256 _resolutionRate");
insert TypeName(5861, 5860, "uint256");
insert PrimitiveType(5862, 5861, "uint256");
insert Identifier(5863, 5860, "_resolutionRate");
insert Expression(5864, 5859, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver)");
insert CallExpression(5865, 5864, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver)");
insert Expression(5866, 5865, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf");
insert MemberExpression(5867, 5866, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf");
insert Expression(5868, 5867, "ISmartInvoiceFactory(_factory)");
insert CallExpression(5869, 5868, "ISmartInvoiceFactory(_factory)");
insert Expression(5870, 5869, "ISmartInvoiceFactory");
insert Identifier(5871, 5870, "ISmartInvoiceFactory");
insert CallArgument(5872, 5869, "_factory");
insert Expression(5873, 5872, "_factory");
insert Identifier(5874, 5873, "_factory");
insert Identifier(5875, 5867, "resolutionRateOf");
insert CallArgument(5876, 5865, "_resolver");
insert Expression(5877, 5876, "_resolver");
insert Identifier(5878, 5877, "_resolver");
insert Statement(5879, 5619, "if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }");
insert IfStatement(5880, 5879, "if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }");
insert Expression(5881, 5880, "_resolutionRate == 0");
insert BinaryExpression(5882, 5881, "_resolutionRate == 0");
insert Expression(5883, 5882, "_resolutionRate");
insert Identifier(5884, 5883, "_resolutionRate");
insert Expression(5885, 5882, "0");
insert NumberLiteral(5886, 5885, "0");
insert Statement(5887, 5880, "{\n            _resolutionRate = 20;\n        }");
insert BlockStatement(5888, 5887, "{\n            _resolutionRate = 20;\n        }");
insert Statement(5889, 5888, "_resolutionRate = 20;");
insert ExpressionStatement(5890, 5889, "_resolutionRate = 20;");
insert Expression(5891, 5890, "_resolutionRate = 20");
insert AssignmentExpression(5892, 5891, "_resolutionRate = 20");
insert Expression(5893, 5892, "_resolutionRate");
insert Identifier(5894, 5893, "_resolutionRate");
insert Expression(5895, 5892, "20");
insert NumberLiteral(5896, 5895, "20");
insert Statement(5897, 5619, "client = _client;");
insert ExpressionStatement(5898, 5897, "client = _client;");
insert Expression(5899, 5898, "client = _client");
insert AssignmentExpression(5900, 5899, "client = _client");
insert Expression(5901, 5900, "client");
insert Identifier(5902, 5901, "client");
insert Expression(5903, 5900, "_client");
insert Identifier(5904, 5903, "_client");
insert Statement(5905, 5619, "resolverType = ADR(_resolverType);");
insert ExpressionStatement(5906, 5905, "resolverType = ADR(_resolverType);");
insert Expression(5907, 5906, "resolverType = ADR(_resolverType)");
insert AssignmentExpression(5908, 5907, "resolverType = ADR(_resolverType)");
insert Expression(5909, 5908, "resolverType");
insert Identifier(5910, 5909, "resolverType");
insert Expression(5911, 5908, "ADR(_resolverType)");
insert CallExpression(5912, 5911, "ADR(_resolverType)");
insert Expression(5913, 5912, "ADR");
insert Identifier(5914, 5913, "ADR");
insert CallArgument(5915, 5912, "_resolverType");
insert Expression(5916, 5915, "_resolverType");
insert Identifier(5917, 5916, "_resolverType");
insert Statement(5918, 5619, "resolver = _resolver;");
insert ExpressionStatement(5919, 5918, "resolver = _resolver;");
insert Expression(5920, 5919, "resolver = _resolver");
insert AssignmentExpression(5921, 5920, "resolver = _resolver");
insert Expression(5922, 5921, "resolver");
insert Identifier(5923, 5922, "resolver");
insert Expression(5924, 5921, "_resolver");
insert Identifier(5925, 5924, "_resolver");
insert Statement(5926, 5619, "token = _token;");
insert ExpressionStatement(5927, 5926, "token = _token;");
insert Expression(5928, 5927, "token = _token");
insert AssignmentExpression(5929, 5928, "token = _token");
insert Expression(5930, 5929, "token");
insert Identifier(5931, 5930, "token");
insert Expression(5932, 5929, "_token");
insert Identifier(5933, 5932, "_token");
insert Statement(5934, 5619, "terminationTime = _terminationTime;");
insert ExpressionStatement(5935, 5934, "terminationTime = _terminationTime;");
insert Expression(5936, 5935, "terminationTime = _terminationTime");
insert AssignmentExpression(5937, 5936, "terminationTime = _terminationTime");
insert Expression(5938, 5937, "terminationTime");
insert Identifier(5939, 5938, "terminationTime");
insert Expression(5940, 5937, "_terminationTime");
insert Identifier(5941, 5940, "_terminationTime");
insert Statement(5942, 5619, "resolutionRate = _resolutionRate;");
insert ExpressionStatement(5943, 5942, "resolutionRate = _resolutionRate;");
insert Expression(5944, 5943, "resolutionRate = _resolutionRate");
insert AssignmentExpression(5945, 5944, "resolutionRate = _resolutionRate");
insert Expression(5946, 5945, "resolutionRate");
insert Identifier(5947, 5946, "resolutionRate");
insert Expression(5948, 5945, "_resolutionRate");
insert Identifier(5949, 5948, "_resolutionRate");
insert Statement(5950, 5619, "details = _details;");
insert ExpressionStatement(5951, 5950, "details = _details;");
insert Expression(5952, 5951, "details = _details");
insert AssignmentExpression(5953, 5952, "details = _details");
insert Expression(5954, 5953, "details");
insert Identifier(5955, 5954, "details");
insert Expression(5956, 5953, "_details");
insert Identifier(5957, 5956, "_details");
insert Statement(5958, 5619, "wrappedNativeToken = _wrappedNativeToken;");
insert ExpressionStatement(5959, 5958, "wrappedNativeToken = _wrappedNativeToken;");
insert Expression(5960, 5959, "wrappedNativeToken = _wrappedNativeToken");
insert AssignmentExpression(5961, 5960, "wrappedNativeToken = _wrappedNativeToken");
insert Expression(5962, 5961, "wrappedNativeToken");
insert Identifier(5963, 5962, "wrappedNativeToken");
insert Expression(5964, 5961, "_wrappedNativeToken");
insert Identifier(5965, 5964, "_wrappedNativeToken");
insert Statement(5966, 5619, "providerReceiver = _providerReceiver;");
insert ExpressionStatement(5967, 5966, "providerReceiver = _providerReceiver;");
insert Expression(5968, 5967, "providerReceiver = _providerReceiver");
insert AssignmentExpression(5969, 5968, "providerReceiver = _providerReceiver");
insert Expression(5970, 5969, "providerReceiver");
insert Identifier(5971, 5970, "providerReceiver");
insert Expression(5972, 5969, "_providerReceiver");
insert Identifier(5973, 5972, "_providerReceiver");
insert Statement(5974, 5619, "clientReceiver = _clientReceiver;");
insert ExpressionStatement(5975, 5974, "clientReceiver = _clientReceiver;");
insert Expression(5976, 5975, "clientReceiver = _clientReceiver");
insert AssignmentExpression(5977, 5976, "clientReceiver = _clientReceiver");
insert Expression(5978, 5977, "clientReceiver");
insert Identifier(5979, 5978, "clientReceiver");
insert Expression(5980, 5977, "_clientReceiver");
insert Identifier(5981, 5980, "_clientReceiver");
insert Statement(5982, 5619, "if (!_requireVerification) emit Verified(client, address(this));");
insert IfStatement(5983, 5982, "if (!_requireVerification) emit Verified(client, address(this));");
insert Expression(5984, 5983, "!_requireVerification");
insert UnaryExpression(5985, 5984, "!_requireVerification");
insert Expression(5986, 5985, "_requireVerification");
insert Identifier(5987, 5986, "_requireVerification");
insert Statement(5988, 5983, "emit Verified(client, address(this));");
insert EmitStatement(5989, 5988, "emit Verified(client, address(this));");
insert Expression(5990, 5989, "Verified");
insert Identifier(5991, 5990, "Verified");
insert CallArgument(5992, 5989, "client");
insert Expression(5993, 5992, "client");
insert Identifier(5994, 5993, "client");
insert CallArgument(5995, 5989, "address(this)");
insert Expression(5996, 5995, "address(this)");
insert TypeCastExpression(5997, 5996, "address(this)");
insert PrimitiveType(5998, 5997, "address");
insert CallArgument(5999, 5997, "this");
insert Expression(6000, 5999, "this");
insert Identifier(6001, 6000, "this");
insert Comment(6002, 5525, "/**\n     * @dev Internal function to withdraw payment to the client's receiver.\n     * @param _token The address of the token to transfer.\n     * @param _amount The amount of tokens to transfer.\n     */");
insert FunctionDefinition(6003, 5525, "function _withdrawDeposit(\n        address _token,\n        uint256 _amount\n    ) internal virtual override {\n        IERC20(_token).safeTransfer(clientReceiver, _amount);\n    }");
insert Identifier(6004, 6003, "_withdrawDeposit");
insert Parameter(6005, 6003, "address _token");
insert TypeName(6006, 6005, "address");
insert PrimitiveType(6007, 6006, "address");
insert Identifier(6008, 6005, "_token");
insert Parameter(6009, 6003, "uint256 _amount");
insert TypeName(6010, 6009, "uint256");
insert PrimitiveType(6011, 6010, "uint256");
insert Identifier(6012, 6009, "_amount");
insert Visibility(6013, 6003, "internal");
insert Virtual(6014, 6003, "virtual");
insert OverrideSpecifier(6015, 6003, "override");
insert FunctionBody(6016, 6003, "{\n        IERC20(_token).safeTransfer(clientReceiver, _amount);\n    }");
insert Statement(6017, 6016, "IERC20(_token).safeTransfer(clientReceiver, _amount);");
insert ExpressionStatement(6018, 6017, "IERC20(_token).safeTransfer(clientReceiver, _amount);");
insert Expression(6019, 6018, "IERC20(_token).safeTransfer(clientReceiver, _amount)");
insert CallExpression(6020, 6019, "IERC20(_token).safeTransfer(clientReceiver, _amount)");
insert Expression(6021, 6020, "IERC20(_token).safeTransfer");
insert MemberExpression(6022, 6021, "IERC20(_token).safeTransfer");
insert Expression(6023, 6022, "IERC20(_token)");
insert CallExpression(6024, 6023, "IERC20(_token)");
insert Expression(6025, 6024, "IERC20");
insert Identifier(6026, 6025, "IERC20");
insert CallArgument(6027, 6024, "_token");
insert Expression(6028, 6027, "_token");
insert Identifier(6029, 6028, "_token");
insert Identifier(6030, 6022, "safeTransfer");
insert CallArgument(6031, 6020, "clientReceiver");
insert Expression(6032, 6031, "clientReceiver");
insert Identifier(6033, 6032, "clientReceiver");
insert CallArgument(6034, 6020, "_amount");
insert Expression(6035, 6034, "_amount");
insert Identifier(6036, 6035, "_amount");
insert SourceFile(6037, 0, "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {SafeSplitsEscrowZap} from \"./SafeSplitsEscrowZap.sol\";\nimport {ISafeProxyFactory} from \"./interfaces/ISafeProxyFactory.sol\";\nimport {ISplitMain} from \"./interfaces/ISplitMain.sol\";\nimport {ISpoilsManager} from \"./interfaces/ISpoilsManager.sol\";\nimport {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";\nimport {IWRAPPED} from \"./interfaces/IWRAPPED.sol\";\n\n/// @title SafeSplitsDaoEscrowZap\n/// @notice Contract for creating and managing Safe splits with DAO escrow using customizable settings.\ncontract SafeSplitsDaoEscrowZap is SafeSplitsEscrowZap {\n    /// @notice The DAO controller address\n    address public dao;\n\n    /// @notice The DAO's SpoilsManager address\n    ISpoilsManager public spoilsManager;\n\n    /// @dev Custom error for DAO split creation failure\n    error DaoSplitCreationFailed();\n\n    /// @notice Emitted when a new Safe splits DAO escrow is created.\n    /// @param safe The address of the created Safe.\n    /// @param projectTeamSplit The address of the created project team split.\n    /// @param daoSplit The address of the created DAO split.\n    /// @param escrow The address of the created escrow.\n    event SafeSplitsDaoEscrowCreated(\n        address safe,\n        address projectTeamSplit,\n        address daoSplit,\n        address escrow\n    );\n\n    struct DaoZapData {\n        ZapData zapData;\n        address daoSplit;\n    }\n\n    /**\n     * @dev Internal function to create a new Split with the provided owners and percent allocations, optionally creates a DAO split for spoils.\n     * @param _owners The address list of owners for the raid party split.\n     * @param _percentAllocations The percent allocations for the raid party split.\n     * @param _splitsData Bundled data for splits.\n     * @param _daoZapData The data struct for storing deployment results.\n     * @return The updated `DaoZapData` with the deployed split addresses.\n     */\n    function _createSplit(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        bytes calldata _splitsData,\n        DaoZapData memory _daoZapData\n    ) internal returns (DaoZapData memory) {\n        (bool projectSplit, bool daoSplit) = abi.decode(\n            _splitsData,\n            (bool, bool)\n        );\n\n        // Create project team split if required\n        if (projectSplit) {\n            _daoZapData.zapData.projectTeamSplit = splitMain.createSplit(\n                _owners,\n                _percentAllocations,\n                distributorFee,\n                _daoZapData.zapData.safe\n            );\n        }\n\n        // Handle the case when project team split is not created\n        if (_daoZapData.zapData.projectTeamSplit == address(0)) {\n            if (_daoZapData.zapData.safe != address(0)) {\n                _daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe;\n            } else {\n                revert ProjectTeamSplitNotCreated();\n            }\n        }\n\n        // Create DAO split if required\n        if (!daoSplit) return _daoZapData;\n\n        // Prepare arrays for DAO split\n        address[] memory daoSplitRecipients = new address[](2);\n        uint32[] memory daoSplitPercentAllocations = new uint32[](2);\n\n        // Get DAO split recipients and amounts\n        address daoReceiver = spoilsManager.receiver();\n        uint32 daoSplitAmount = spoilsManager.getSpoils();\n        uint32 projectSplitAmount = (100 *\n            spoilsManager.SPLIT_PERCENTAGE_SCALE()) - daoSplitAmount;\n\n        // Sort the addresses and amounts in the correct order\n        if (\n            uint160(daoReceiver) < uint160(_daoZapData.zapData.projectTeamSplit)\n        ) {\n            daoSplitRecipients[0] = daoReceiver;\n            daoSplitRecipients[1] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitPercentAllocations[0] = daoSplitAmount;\n            daoSplitPercentAllocations[1] = projectSplitAmount;\n        } else {\n            daoSplitRecipients[0] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitRecipients[1] = daoReceiver;\n            daoSplitPercentAllocations[0] = projectSplitAmount;\n            daoSplitPercentAllocations[1] = daoSplitAmount;\n        }\n\n        // Create DAO split\n        _daoZapData.daoSplit = splitMain.createSplit(\n            daoSplitRecipients,\n            daoSplitPercentAllocations,\n            distributorFee,\n            dao\n        );\n\n        if (_daoZapData.daoSplit == address(0)) {\n            revert DaoSplitCreationFailed();\n        }\n\n        return _daoZapData;\n    }\n\n    /**\n     * @dev Internal function to handle escrow parameters.\n     * @param _daoZapData The data struct for storing deployment results.\n     * @return The escrow parameters for the deployment.\n     */\n    function _handleEscrowParams(\n        DaoZapData memory _daoZapData\n    ) internal view returns (address[] memory) {\n        address[] memory escrowParams = new address[](2);\n        escrowParams[0] = _daoZapData.zapData.safe;\n        escrowParams[1] = _daoZapData.zapData.projectTeamSplit;\n\n        if (_daoZapData.daoSplit != address(0)) {\n            escrowParams[0] = dao;\n            escrowParams[1] = _daoZapData.daoSplit;\n        }\n\n        return escrowParams;\n    }\n\n    /**\n     * @dev Internal function to create a new Safe, Split, and Escrow with DAO support.\n     * @param _owners The list of owners for the Safe and Split.\n     * @param _percentAllocations The percent allocations for the Split.\n     * @param _milestoneAmounts The milestone amounts for the Escrow.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitsData The encoded data for Split setup.\n     * @param _escrowData The encoded data for Escrow setup.\n     */\n    function _createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitsData,\n        bytes calldata _escrowData\n    ) internal override {\n        // Initialize DaoZapData\n        DaoZapData memory daoZapData = DaoZapData({\n            zapData: ZapData({\n                safe: _safeAddress,\n                projectTeamSplit: address(0),\n                escrow: address(0)\n            }),\n            daoSplit: address(0)\n        });\n\n        // Deploy Safe if not already provided\n        if (daoZapData.zapData.safe == address(0)) {\n            daoZapData.zapData = _deploySafe(\n                _owners,\n                _safeData,\n                daoZapData.zapData\n            );\n        }\n\n        // Create Split(s)\n        daoZapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitsData,\n            daoZapData\n        );\n\n        // Handle escrow parameters and deploy escrow\n        address[] memory escrowParams = _handleEscrowParams(daoZapData);\n        daoZapData.zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            daoZapData.zapData\n        );\n\n        // Emit event for the created Safe splits DAO escrow\n        emit SafeSplitsDaoEscrowCreated(\n            daoZapData.zapData.safe,\n            daoZapData.zapData.projectTeamSplit,\n            daoZapData.daoSplit,\n            daoZapData.zapData.escrow\n        );\n    }\n\n    /**\n     * @notice Deploys a new Safe, Project Team Split, DAO Split, and Escrow with the provided details.\n     * @param _owners The Safe owners and raid party split participants.\n     * @param _percentAllocations The percent allocations for the raid party split.\n     * @param _milestoneAmounts The milestone amounts for the escrow.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitsData The encoded data for Split setup.\n     * @param _escrowData The encoded data for escrow deployment.\n     */\n    function createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitsData,\n        bytes calldata _escrowData\n    ) public override {\n        if (_percentAllocations.length != _owners.length)\n            revert InvalidAllocationsOwnersData();\n        _createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitsData,\n            _escrowData\n        );\n    }\n\n    /**\n     * @dev Internal function to handle initialization data.\n     * @param _data The initialization data.\n     */\n    function _handleData(bytes calldata _data) internal override {\n        (\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _spoilsManager,\n            address _escrowFactory,\n            address _wrappedNativeToken,\n            address _dao\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address\n                )\n            );\n\n        safeSingleton = _safeSingleton;\n        fallbackHandler = _fallbackHandler;\n        safeFactory = ISafeProxyFactory(_safeFactory);\n        splitMain = ISplitMain(_splitMain);\n        spoilsManager = ISpoilsManager(_spoilsManager);\n        escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n        wrappedNativeToken = IWRAPPED(_wrappedNativeToken);\n        dao = _dao;\n    }\n}\n");
insert Comment(6038, 6037, "// SPDX-License-Identifier: MIT");
insert PragmaDirective(6039, 6037, "pragma solidity ^0.8.20;");
insert SolidityPragmaToken(6040, 6039, "solidity ^0.8.20");
insert SolidityVersionComparisonOperator(6041, 6040, " ^");
insert SolidityVersion(6042, 6040, "0.8.20");
insert ImportDirective(6043, 6037, "import {SafeSplitsEscrowZap} from \"./SafeSplitsEscrowZap.sol\";");
insert Identifier(6044, 6043, "SafeSplitsEscrowZap");
insert ImportDirective(6045, 6037, "import {ISafeProxyFactory} from \"./interfaces/ISafeProxyFactory.sol\";");
insert Identifier(6046, 6045, "ISafeProxyFactory");
insert ImportDirective(6047, 6037, "import {ISplitMain} from \"./interfaces/ISplitMain.sol\";");
insert Identifier(6048, 6047, "ISplitMain");
insert ImportDirective(6049, 6037, "import {ISpoilsManager} from \"./interfaces/ISpoilsManager.sol\";");
insert Identifier(6050, 6049, "ISpoilsManager");
insert ImportDirective(6051, 6037, "import {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";");
insert Identifier(6052, 6051, "ISmartInvoiceFactory");
insert ImportDirective(6053, 6037, "import {IWRAPPED} from \"./interfaces/IWRAPPED.sol\";");
insert Identifier(6054, 6053, "IWRAPPED");
insert Comment(6055, 6037, "/// @title SafeSplitsDaoEscrowZap");
insert Comment(6056, 6037, "/// @notice Contract for creating and managing Safe splits with DAO escrow using customizable settings.");
insert ContractDeclaration(6057, 6037, "contract SafeSplitsDaoEscrowZap is SafeSplitsEscrowZap {\n    /// @notice The DAO controller address\n    address public dao;\n\n    /// @notice The DAO's SpoilsManager address\n    ISpoilsManager public spoilsManager;\n\n    /// @dev Custom error for DAO split creation failure\n    error DaoSplitCreationFailed();\n\n    /// @notice Emitted when a new Safe splits DAO escrow is created.\n    /// @param safe The address of the created Safe.\n    /// @param projectTeamSplit The address of the created project team split.\n    /// @param daoSplit The address of the created DAO split.\n    /// @param escrow The address of the created escrow.\n    event SafeSplitsDaoEscrowCreated(\n        address safe,\n        address projectTeamSplit,\n        address daoSplit,\n        address escrow\n    );\n\n    struct DaoZapData {\n        ZapData zapData;\n        address daoSplit;\n    }\n\n    /**\n     * @dev Internal function to create a new Split with the provided owners and percent allocations, optionally creates a DAO split for spoils.\n     * @param _owners The address list of owners for the raid party split.\n     * @param _percentAllocations The percent allocations for the raid party split.\n     * @param _splitsData Bundled data for splits.\n     * @param _daoZapData The data struct for storing deployment results.\n     * @return The updated `DaoZapData` with the deployed split addresses.\n     */\n    function _createSplit(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        bytes calldata _splitsData,\n        DaoZapData memory _daoZapData\n    ) internal returns (DaoZapData memory) {\n        (bool projectSplit, bool daoSplit) = abi.decode(\n            _splitsData,\n            (bool, bool)\n        );\n\n        // Create project team split if required\n        if (projectSplit) {\n            _daoZapData.zapData.projectTeamSplit = splitMain.createSplit(\n                _owners,\n                _percentAllocations,\n                distributorFee,\n                _daoZapData.zapData.safe\n            );\n        }\n\n        // Handle the case when project team split is not created\n        if (_daoZapData.zapData.projectTeamSplit == address(0)) {\n            if (_daoZapData.zapData.safe != address(0)) {\n                _daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe;\n            } else {\n                revert ProjectTeamSplitNotCreated();\n            }\n        }\n\n        // Create DAO split if required\n        if (!daoSplit) return _daoZapData;\n\n        // Prepare arrays for DAO split\n        address[] memory daoSplitRecipients = new address[](2);\n        uint32[] memory daoSplitPercentAllocations = new uint32[](2);\n\n        // Get DAO split recipients and amounts\n        address daoReceiver = spoilsManager.receiver();\n        uint32 daoSplitAmount = spoilsManager.getSpoils();\n        uint32 projectSplitAmount = (100 *\n            spoilsManager.SPLIT_PERCENTAGE_SCALE()) - daoSplitAmount;\n\n        // Sort the addresses and amounts in the correct order\n        if (\n            uint160(daoReceiver) < uint160(_daoZapData.zapData.projectTeamSplit)\n        ) {\n            daoSplitRecipients[0] = daoReceiver;\n            daoSplitRecipients[1] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitPercentAllocations[0] = daoSplitAmount;\n            daoSplitPercentAllocations[1] = projectSplitAmount;\n        } else {\n            daoSplitRecipients[0] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitRecipients[1] = daoReceiver;\n            daoSplitPercentAllocations[0] = projectSplitAmount;\n            daoSplitPercentAllocations[1] = daoSplitAmount;\n        }\n\n        // Create DAO split\n        _daoZapData.daoSplit = splitMain.createSplit(\n            daoSplitRecipients,\n            daoSplitPercentAllocations,\n            distributorFee,\n            dao\n        );\n\n        if (_daoZapData.daoSplit == address(0)) {\n            revert DaoSplitCreationFailed();\n        }\n\n        return _daoZapData;\n    }\n\n    /**\n     * @dev Internal function to handle escrow parameters.\n     * @param _daoZapData The data struct for storing deployment results.\n     * @return The escrow parameters for the deployment.\n     */\n    function _handleEscrowParams(\n        DaoZapData memory _daoZapData\n    ) internal view returns (address[] memory) {\n        address[] memory escrowParams = new address[](2);\n        escrowParams[0] = _daoZapData.zapData.safe;\n        escrowParams[1] = _daoZapData.zapData.projectTeamSplit;\n\n        if (_daoZapData.daoSplit != address(0)) {\n            escrowParams[0] = dao;\n            escrowParams[1] = _daoZapData.daoSplit;\n        }\n\n        return escrowParams;\n    }\n\n    /**\n     * @dev Internal function to create a new Safe, Split, and Escrow with DAO support.\n     * @param _owners The list of owners for the Safe and Split.\n     * @param _percentAllocations The percent allocations for the Split.\n     * @param _milestoneAmounts The milestone amounts for the Escrow.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitsData The encoded data for Split setup.\n     * @param _escrowData The encoded data for Escrow setup.\n     */\n    function _createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitsData,\n        bytes calldata _escrowData\n    ) internal override {\n        // Initialize DaoZapData\n        DaoZapData memory daoZapData = DaoZapData({\n            zapData: ZapData({\n                safe: _safeAddress,\n                projectTeamSplit: address(0),\n                escrow: address(0)\n            }),\n            daoSplit: address(0)\n        });\n\n        // Deploy Safe if not already provided\n        if (daoZapData.zapData.safe == address(0)) {\n            daoZapData.zapData = _deploySafe(\n                _owners,\n                _safeData,\n                daoZapData.zapData\n            );\n        }\n\n        // Create Split(s)\n        daoZapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitsData,\n            daoZapData\n        );\n\n        // Handle escrow parameters and deploy escrow\n        address[] memory escrowParams = _handleEscrowParams(daoZapData);\n        daoZapData.zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            daoZapData.zapData\n        );\n\n        // Emit event for the created Safe splits DAO escrow\n        emit SafeSplitsDaoEscrowCreated(\n            daoZapData.zapData.safe,\n            daoZapData.zapData.projectTeamSplit,\n            daoZapData.daoSplit,\n            daoZapData.zapData.escrow\n        );\n    }\n\n    /**\n     * @notice Deploys a new Safe, Project Team Split, DAO Split, and Escrow with the provided details.\n     * @param _owners The Safe owners and raid party split participants.\n     * @param _percentAllocations The percent allocations for the raid party split.\n     * @param _milestoneAmounts The milestone amounts for the escrow.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitsData The encoded data for Split setup.\n     * @param _escrowData The encoded data for escrow deployment.\n     */\n    function createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitsData,\n        bytes calldata _escrowData\n    ) public override {\n        if (_percentAllocations.length != _owners.length)\n            revert InvalidAllocationsOwnersData();\n        _createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitsData,\n            _escrowData\n        );\n    }\n\n    /**\n     * @dev Internal function to handle initialization data.\n     * @param _data The initialization data.\n     */\n    function _handleData(bytes calldata _data) internal override {\n        (\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _spoilsManager,\n            address _escrowFactory,\n            address _wrappedNativeToken,\n            address _dao\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address\n                )\n            );\n\n        safeSingleton = _safeSingleton;\n        fallbackHandler = _fallbackHandler;\n        safeFactory = ISafeProxyFactory(_safeFactory);\n        splitMain = ISplitMain(_splitMain);\n        spoilsManager = ISpoilsManager(_spoilsManager);\n        escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n        wrappedNativeToken = IWRAPPED(_wrappedNativeToken);\n        dao = _dao;\n    }\n}");
insert Identifier(6058, 6057, "SafeSplitsDaoEscrowZap");
insert InheritanceSpecifier(6059, 6057, "SafeSplitsEscrowZap");
insert UserDefinedType(6060, 6059, "SafeSplitsEscrowZap");
insert Identifier(6061, 6060, "SafeSplitsEscrowZap");
insert ContractBody(6062, 6057, "{\n    /// @notice The DAO controller address\n    address public dao;\n\n    /// @notice The DAO's SpoilsManager address\n    ISpoilsManager public spoilsManager;\n\n    /// @dev Custom error for DAO split creation failure\n    error DaoSplitCreationFailed();\n\n    /// @notice Emitted when a new Safe splits DAO escrow is created.\n    /// @param safe The address of the created Safe.\n    /// @param projectTeamSplit The address of the created project team split.\n    /// @param daoSplit The address of the created DAO split.\n    /// @param escrow The address of the created escrow.\n    event SafeSplitsDaoEscrowCreated(\n        address safe,\n        address projectTeamSplit,\n        address daoSplit,\n        address escrow\n    );\n\n    struct DaoZapData {\n        ZapData zapData;\n        address daoSplit;\n    }\n\n    /**\n     * @dev Internal function to create a new Split with the provided owners and percent allocations, optionally creates a DAO split for spoils.\n     * @param _owners The address list of owners for the raid party split.\n     * @param _percentAllocations The percent allocations for the raid party split.\n     * @param _splitsData Bundled data for splits.\n     * @param _daoZapData The data struct for storing deployment results.\n     * @return The updated `DaoZapData` with the deployed split addresses.\n     */\n    function _createSplit(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        bytes calldata _splitsData,\n        DaoZapData memory _daoZapData\n    ) internal returns (DaoZapData memory) {\n        (bool projectSplit, bool daoSplit) = abi.decode(\n            _splitsData,\n            (bool, bool)\n        );\n\n        // Create project team split if required\n        if (projectSplit) {\n            _daoZapData.zapData.projectTeamSplit = splitMain.createSplit(\n                _owners,\n                _percentAllocations,\n                distributorFee,\n                _daoZapData.zapData.safe\n            );\n        }\n\n        // Handle the case when project team split is not created\n        if (_daoZapData.zapData.projectTeamSplit == address(0)) {\n            if (_daoZapData.zapData.safe != address(0)) {\n                _daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe;\n            } else {\n                revert ProjectTeamSplitNotCreated();\n            }\n        }\n\n        // Create DAO split if required\n        if (!daoSplit) return _daoZapData;\n\n        // Prepare arrays for DAO split\n        address[] memory daoSplitRecipients = new address[](2);\n        uint32[] memory daoSplitPercentAllocations = new uint32[](2);\n\n        // Get DAO split recipients and amounts\n        address daoReceiver = spoilsManager.receiver();\n        uint32 daoSplitAmount = spoilsManager.getSpoils();\n        uint32 projectSplitAmount = (100 *\n            spoilsManager.SPLIT_PERCENTAGE_SCALE()) - daoSplitAmount;\n\n        // Sort the addresses and amounts in the correct order\n        if (\n            uint160(daoReceiver) < uint160(_daoZapData.zapData.projectTeamSplit)\n        ) {\n            daoSplitRecipients[0] = daoReceiver;\n            daoSplitRecipients[1] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitPercentAllocations[0] = daoSplitAmount;\n            daoSplitPercentAllocations[1] = projectSplitAmount;\n        } else {\n            daoSplitRecipients[0] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitRecipients[1] = daoReceiver;\n            daoSplitPercentAllocations[0] = projectSplitAmount;\n            daoSplitPercentAllocations[1] = daoSplitAmount;\n        }\n\n        // Create DAO split\n        _daoZapData.daoSplit = splitMain.createSplit(\n            daoSplitRecipients,\n            daoSplitPercentAllocations,\n            distributorFee,\n            dao\n        );\n\n        if (_daoZapData.daoSplit == address(0)) {\n            revert DaoSplitCreationFailed();\n        }\n\n        return _daoZapData;\n    }\n\n    /**\n     * @dev Internal function to handle escrow parameters.\n     * @param _daoZapData The data struct for storing deployment results.\n     * @return The escrow parameters for the deployment.\n     */\n    function _handleEscrowParams(\n        DaoZapData memory _daoZapData\n    ) internal view returns (address[] memory) {\n        address[] memory escrowParams = new address[](2);\n        escrowParams[0] = _daoZapData.zapData.safe;\n        escrowParams[1] = _daoZapData.zapData.projectTeamSplit;\n\n        if (_daoZapData.daoSplit != address(0)) {\n            escrowParams[0] = dao;\n            escrowParams[1] = _daoZapData.daoSplit;\n        }\n\n        return escrowParams;\n    }\n\n    /**\n     * @dev Internal function to create a new Safe, Split, and Escrow with DAO support.\n     * @param _owners The list of owners for the Safe and Split.\n     * @param _percentAllocations The percent allocations for the Split.\n     * @param _milestoneAmounts The milestone amounts for the Escrow.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitsData The encoded data for Split setup.\n     * @param _escrowData The encoded data for Escrow setup.\n     */\n    function _createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitsData,\n        bytes calldata _escrowData\n    ) internal override {\n        // Initialize DaoZapData\n        DaoZapData memory daoZapData = DaoZapData({\n            zapData: ZapData({\n                safe: _safeAddress,\n                projectTeamSplit: address(0),\n                escrow: address(0)\n            }),\n            daoSplit: address(0)\n        });\n\n        // Deploy Safe if not already provided\n        if (daoZapData.zapData.safe == address(0)) {\n            daoZapData.zapData = _deploySafe(\n                _owners,\n                _safeData,\n                daoZapData.zapData\n            );\n        }\n\n        // Create Split(s)\n        daoZapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitsData,\n            daoZapData\n        );\n\n        // Handle escrow parameters and deploy escrow\n        address[] memory escrowParams = _handleEscrowParams(daoZapData);\n        daoZapData.zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            daoZapData.zapData\n        );\n\n        // Emit event for the created Safe splits DAO escrow\n        emit SafeSplitsDaoEscrowCreated(\n            daoZapData.zapData.safe,\n            daoZapData.zapData.projectTeamSplit,\n            daoZapData.daoSplit,\n            daoZapData.zapData.escrow\n        );\n    }\n\n    /**\n     * @notice Deploys a new Safe, Project Team Split, DAO Split, and Escrow with the provided details.\n     * @param _owners The Safe owners and raid party split participants.\n     * @param _percentAllocations The percent allocations for the raid party split.\n     * @param _milestoneAmounts The milestone amounts for the escrow.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitsData The encoded data for Split setup.\n     * @param _escrowData The encoded data for escrow deployment.\n     */\n    function createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitsData,\n        bytes calldata _escrowData\n    ) public override {\n        if (_percentAllocations.length != _owners.length)\n            revert InvalidAllocationsOwnersData();\n        _createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitsData,\n            _escrowData\n        );\n    }\n\n    /**\n     * @dev Internal function to handle initialization data.\n     * @param _data The initialization data.\n     */\n    function _handleData(bytes calldata _data) internal override {\n        (\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _spoilsManager,\n            address _escrowFactory,\n            address _wrappedNativeToken,\n            address _dao\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address\n                )\n            );\n\n        safeSingleton = _safeSingleton;\n        fallbackHandler = _fallbackHandler;\n        safeFactory = ISafeProxyFactory(_safeFactory);\n        splitMain = ISplitMain(_splitMain);\n        spoilsManager = ISpoilsManager(_spoilsManager);\n        escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n        wrappedNativeToken = IWRAPPED(_wrappedNativeToken);\n        dao = _dao;\n    }\n}");
insert Comment(6063, 6062, "/// @notice The DAO controller address");
insert StateVariableDeclaration(6064, 6062, "address public dao;");
insert TypeName(6065, 6064, "address");
insert PrimitiveType(6066, 6065, "address");
insert Visibility(6067, 6064, "public");
insert Identifier(6068, 6064, "dao");
insert Comment(6069, 6062, "/// @notice The DAO's SpoilsManager address");
insert StateVariableDeclaration(6070, 6062, "ISpoilsManager public spoilsManager;");
insert TypeName(6071, 6070, "ISpoilsManager");
insert UserDefinedType(6072, 6071, "ISpoilsManager");
insert Identifier(6073, 6072, "ISpoilsManager");
insert Visibility(6074, 6070, "public");
insert Identifier(6075, 6070, "spoilsManager");
insert Comment(6076, 6062, "/// @dev Custom error for DAO split creation failure");
insert ErrorDeclaration(6077, 6062, "error DaoSplitCreationFailed();");
insert Identifier(6078, 6077, "DaoSplitCreationFailed");
insert Comment(6079, 6062, "/// @notice Emitted when a new Safe splits DAO escrow is created.");
insert Comment(6080, 6062, "/// @param safe The address of the created Safe.");
insert Comment(6081, 6062, "/// @param projectTeamSplit The address of the created project team split.");
insert Comment(6082, 6062, "/// @param daoSplit The address of the created DAO split.");
insert Comment(6083, 6062, "/// @param escrow The address of the created escrow.");
insert EventDefinition(6084, 6062, "event SafeSplitsDaoEscrowCreated(\n        address safe,\n        address projectTeamSplit,\n        address daoSplit,\n        address escrow\n    );");
insert Identifier(6085, 6084, "SafeSplitsDaoEscrowCreated");
insert EventParameter(6086, 6084, "address safe");
insert TypeName(6087, 6086, "address");
insert PrimitiveType(6088, 6087, "address");
insert Identifier(6089, 6086, "safe");
insert EventParameter(6090, 6084, "address projectTeamSplit");
insert TypeName(6091, 6090, "address");
insert PrimitiveType(6092, 6091, "address");
insert Identifier(6093, 6090, "projectTeamSplit");
insert EventParameter(6094, 6084, "address daoSplit");
insert TypeName(6095, 6094, "address");
insert PrimitiveType(6096, 6095, "address");
insert Identifier(6097, 6094, "daoSplit");
insert EventParameter(6098, 6084, "address escrow");
insert TypeName(6099, 6098, "address");
insert PrimitiveType(6100, 6099, "address");
insert Identifier(6101, 6098, "escrow");
insert StructDeclaration(6102, 6062, "struct DaoZapData {\n        ZapData zapData;\n        address daoSplit;\n    }");
insert Identifier(6103, 6102, "DaoZapData");
insert StructBody(6104, 6102, "{\n        ZapData zapData;\n        address daoSplit;\n    }");
insert StructMember(6105, 6104, "ZapData zapData;");
insert TypeName(6106, 6105, "ZapData");
insert UserDefinedType(6107, 6106, "ZapData");
insert Identifier(6108, 6107, "ZapData");
insert Identifier(6109, 6105, "zapData");
insert StructMember(6110, 6104, "address daoSplit;");
insert TypeName(6111, 6110, "address");
insert PrimitiveType(6112, 6111, "address");
insert Identifier(6113, 6110, "daoSplit");
insert Comment(6114, 6062, "/**\n     * @dev Internal function to create a new Split with the provided owners and percent allocations, optionally creates a DAO split for spoils.\n     * @param _owners The address list of owners for the raid party split.\n     * @param _percentAllocations The percent allocations for the raid party split.\n     * @param _splitsData Bundled data for splits.\n     * @param _daoZapData The data struct for storing deployment results.\n     * @return The updated `DaoZapData` with the deployed split addresses.\n     */");
insert FunctionDefinition(6115, 6062, "function _createSplit(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        bytes calldata _splitsData,\n        DaoZapData memory _daoZapData\n    ) internal returns (DaoZapData memory) {\n        (bool projectSplit, bool daoSplit) = abi.decode(\n            _splitsData,\n            (bool, bool)\n        );\n\n        // Create project team split if required\n        if (projectSplit) {\n            _daoZapData.zapData.projectTeamSplit = splitMain.createSplit(\n                _owners,\n                _percentAllocations,\n                distributorFee,\n                _daoZapData.zapData.safe\n            );\n        }\n\n        // Handle the case when project team split is not created\n        if (_daoZapData.zapData.projectTeamSplit == address(0)) {\n            if (_daoZapData.zapData.safe != address(0)) {\n                _daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe;\n            } else {\n                revert ProjectTeamSplitNotCreated();\n            }\n        }\n\n        // Create DAO split if required\n        if (!daoSplit) return _daoZapData;\n\n        // Prepare arrays for DAO split\n        address[] memory daoSplitRecipients = new address[](2);\n        uint32[] memory daoSplitPercentAllocations = new uint32[](2);\n\n        // Get DAO split recipients and amounts\n        address daoReceiver = spoilsManager.receiver();\n        uint32 daoSplitAmount = spoilsManager.getSpoils();\n        uint32 projectSplitAmount = (100 *\n            spoilsManager.SPLIT_PERCENTAGE_SCALE()) - daoSplitAmount;\n\n        // Sort the addresses and amounts in the correct order\n        if (\n            uint160(daoReceiver) < uint160(_daoZapData.zapData.projectTeamSplit)\n        ) {\n            daoSplitRecipients[0] = daoReceiver;\n            daoSplitRecipients[1] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitPercentAllocations[0] = daoSplitAmount;\n            daoSplitPercentAllocations[1] = projectSplitAmount;\n        } else {\n            daoSplitRecipients[0] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitRecipients[1] = daoReceiver;\n            daoSplitPercentAllocations[0] = projectSplitAmount;\n            daoSplitPercentAllocations[1] = daoSplitAmount;\n        }\n\n        // Create DAO split\n        _daoZapData.daoSplit = splitMain.createSplit(\n            daoSplitRecipients,\n            daoSplitPercentAllocations,\n            distributorFee,\n            dao\n        );\n\n        if (_daoZapData.daoSplit == address(0)) {\n            revert DaoSplitCreationFailed();\n        }\n\n        return _daoZapData;\n    }");
insert Identifier(6116, 6115, "_createSplit");
insert Parameter(6117, 6115, "address[] memory _owners");
insert TypeName(6118, 6117, "address[]");
insert TypeName(6119, 6118, "address");
insert PrimitiveType(6120, 6119, "address");
insert Identifier(6121, 6117, "_owners");
insert Parameter(6122, 6115, "uint32[] memory _percentAllocations");
insert TypeName(6123, 6122, "uint32[]");
insert TypeName(6124, 6123, "uint32");
insert PrimitiveType(6125, 6124, "uint32");
insert Identifier(6126, 6122, "_percentAllocations");
insert Parameter(6127, 6115, "bytes calldata _splitsData");
insert TypeName(6128, 6127, "bytes");
insert PrimitiveType(6129, 6128, "bytes");
insert Identifier(6130, 6127, "_splitsData");
insert Parameter(6131, 6115, "DaoZapData memory _daoZapData");
insert TypeName(6132, 6131, "DaoZapData");
insert UserDefinedType(6133, 6132, "DaoZapData");
insert Identifier(6134, 6133, "DaoZapData");
insert Identifier(6135, 6131, "_daoZapData");
insert Visibility(6136, 6115, "internal");
insert ReturnTypeDefinition(6137, 6115, "returns (DaoZapData memory)");
insert Parameter(6138, 6137, "DaoZapData memory");
insert TypeName(6139, 6138, "DaoZapData");
insert UserDefinedType(6140, 6139, "DaoZapData");
insert Identifier(6141, 6140, "DaoZapData");
insert FunctionBody(6142, 6115, "{\n        (bool projectSplit, bool daoSplit) = abi.decode(\n            _splitsData,\n            (bool, bool)\n        );\n\n        // Create project team split if required\n        if (projectSplit) {\n            _daoZapData.zapData.projectTeamSplit = splitMain.createSplit(\n                _owners,\n                _percentAllocations,\n                distributorFee,\n                _daoZapData.zapData.safe\n            );\n        }\n\n        // Handle the case when project team split is not created\n        if (_daoZapData.zapData.projectTeamSplit == address(0)) {\n            if (_daoZapData.zapData.safe != address(0)) {\n                _daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe;\n            } else {\n                revert ProjectTeamSplitNotCreated();\n            }\n        }\n\n        // Create DAO split if required\n        if (!daoSplit) return _daoZapData;\n\n        // Prepare arrays for DAO split\n        address[] memory daoSplitRecipients = new address[](2);\n        uint32[] memory daoSplitPercentAllocations = new uint32[](2);\n\n        // Get DAO split recipients and amounts\n        address daoReceiver = spoilsManager.receiver();\n        uint32 daoSplitAmount = spoilsManager.getSpoils();\n        uint32 projectSplitAmount = (100 *\n            spoilsManager.SPLIT_PERCENTAGE_SCALE()) - daoSplitAmount;\n\n        // Sort the addresses and amounts in the correct order\n        if (\n            uint160(daoReceiver) < uint160(_daoZapData.zapData.projectTeamSplit)\n        ) {\n            daoSplitRecipients[0] = daoReceiver;\n            daoSplitRecipients[1] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitPercentAllocations[0] = daoSplitAmount;\n            daoSplitPercentAllocations[1] = projectSplitAmount;\n        } else {\n            daoSplitRecipients[0] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitRecipients[1] = daoReceiver;\n            daoSplitPercentAllocations[0] = projectSplitAmount;\n            daoSplitPercentAllocations[1] = daoSplitAmount;\n        }\n\n        // Create DAO split\n        _daoZapData.daoSplit = splitMain.createSplit(\n            daoSplitRecipients,\n            daoSplitPercentAllocations,\n            distributorFee,\n            dao\n        );\n\n        if (_daoZapData.daoSplit == address(0)) {\n            revert DaoSplitCreationFailed();\n        }\n\n        return _daoZapData;\n    }");
insert Statement(6143, 6142, "(bool projectSplit, bool daoSplit) = abi.decode(\n            _splitsData,\n            (bool, bool)\n        );");
insert VariableDeclarationStatement(6144, 6143, "(bool projectSplit, bool daoSplit) = abi.decode(\n            _splitsData,\n            (bool, bool)\n        );");
insert VariableDeclarationTuple(6145, 6144, "(bool projectSplit, bool daoSplit)");
insert VariableDeclaration(6146, 6145, "bool projectSplit");
insert TypeName(6147, 6146, "bool");
insert PrimitiveType(6148, 6147, "bool");
insert Identifier(6149, 6146, "projectSplit");
insert VariableDeclaration(6150, 6145, "bool daoSplit");
insert TypeName(6151, 6150, "bool");
insert PrimitiveType(6152, 6151, "bool");
insert Identifier(6153, 6150, "daoSplit");
insert Expression(6154, 6144, "abi.decode(\n            _splitsData,\n            (bool, bool)\n        )");
insert CallExpression(6155, 6154, "abi.decode(\n            _splitsData,\n            (bool, bool)\n        )");
insert Expression(6156, 6155, "abi.decode");
insert MemberExpression(6157, 6156, "abi.decode");
insert Identifier(6158, 6157, "abi");
insert Identifier(6159, 6157, "decode");
insert CallArgument(6160, 6155, "_splitsData");
insert Expression(6161, 6160, "_splitsData");
insert Identifier(6162, 6161, "_splitsData");
insert CallArgument(6163, 6155, "(bool, bool)");
insert Expression(6164, 6163, "(bool, bool)");
insert TupleExpression(6165, 6164, "(bool, bool)");
insert Expression(6166, 6165, "bool");
insert PrimitiveType(6167, 6166, "bool");
insert Expression(6168, 6165, "bool");
insert PrimitiveType(6169, 6168, "bool");
insert Comment(6170, 6142, "// Create project team split if required");
insert Statement(6171, 6142, "if (projectSplit) {\n            _daoZapData.zapData.projectTeamSplit = splitMain.createSplit(\n                _owners,\n                _percentAllocations,\n                distributorFee,\n                _daoZapData.zapData.safe\n            );\n        }");
insert IfStatement(6172, 6171, "if (projectSplit) {\n            _daoZapData.zapData.projectTeamSplit = splitMain.createSplit(\n                _owners,\n                _percentAllocations,\n                distributorFee,\n                _daoZapData.zapData.safe\n            );\n        }");
insert Expression(6173, 6172, "projectSplit");
insert Identifier(6174, 6173, "projectSplit");
insert Statement(6175, 6172, "{\n            _daoZapData.zapData.projectTeamSplit = splitMain.createSplit(\n                _owners,\n                _percentAllocations,\n                distributorFee,\n                _daoZapData.zapData.safe\n            );\n        }");
insert BlockStatement(6176, 6175, "{\n            _daoZapData.zapData.projectTeamSplit = splitMain.createSplit(\n                _owners,\n                _percentAllocations,\n                distributorFee,\n                _daoZapData.zapData.safe\n            );\n        }");
insert Statement(6177, 6176, "_daoZapData.zapData.projectTeamSplit = splitMain.createSplit(\n                _owners,\n                _percentAllocations,\n                distributorFee,\n                _daoZapData.zapData.safe\n            );");
insert ExpressionStatement(6178, 6177, "_daoZapData.zapData.projectTeamSplit = splitMain.createSplit(\n                _owners,\n                _percentAllocations,\n                distributorFee,\n                _daoZapData.zapData.safe\n            );");
insert Expression(6179, 6178, "_daoZapData.zapData.projectTeamSplit = splitMain.createSplit(\n                _owners,\n                _percentAllocations,\n                distributorFee,\n                _daoZapData.zapData.safe\n            )");
insert AssignmentExpression(6180, 6179, "_daoZapData.zapData.projectTeamSplit = splitMain.createSplit(\n                _owners,\n                _percentAllocations,\n                distributorFee,\n                _daoZapData.zapData.safe\n            )");
insert Expression(6181, 6180, "_daoZapData.zapData.projectTeamSplit");
insert MemberExpression(6182, 6181, "_daoZapData.zapData.projectTeamSplit");
insert Expression(6183, 6182, "_daoZapData.zapData");
insert MemberExpression(6184, 6183, "_daoZapData.zapData");
insert Identifier(6185, 6184, "_daoZapData");
insert Identifier(6186, 6184, "zapData");
insert Identifier(6187, 6182, "projectTeamSplit");
insert Expression(6188, 6180, "splitMain.createSplit(\n                _owners,\n                _percentAllocations,\n                distributorFee,\n                _daoZapData.zapData.safe\n            )");
insert CallExpression(6189, 6188, "splitMain.createSplit(\n                _owners,\n                _percentAllocations,\n                distributorFee,\n                _daoZapData.zapData.safe\n            )");
insert Expression(6190, 6189, "splitMain.createSplit");
insert MemberExpression(6191, 6190, "splitMain.createSplit");
insert Identifier(6192, 6191, "splitMain");
insert Identifier(6193, 6191, "createSplit");
insert CallArgument(6194, 6189, "_owners");
insert Expression(6195, 6194, "_owners");
insert Identifier(6196, 6195, "_owners");
insert CallArgument(6197, 6189, "_percentAllocations");
insert Expression(6198, 6197, "_percentAllocations");
insert Identifier(6199, 6198, "_percentAllocations");
insert CallArgument(6200, 6189, "distributorFee");
insert Expression(6201, 6200, "distributorFee");
insert Identifier(6202, 6201, "distributorFee");
insert CallArgument(6203, 6189, "_daoZapData.zapData.safe");
insert Expression(6204, 6203, "_daoZapData.zapData.safe");
insert MemberExpression(6205, 6204, "_daoZapData.zapData.safe");
insert Expression(6206, 6205, "_daoZapData.zapData");
insert MemberExpression(6207, 6206, "_daoZapData.zapData");
insert Identifier(6208, 6207, "_daoZapData");
insert Identifier(6209, 6207, "zapData");
insert Identifier(6210, 6205, "safe");
insert Comment(6211, 6142, "// Handle the case when project team split is not created");
insert Statement(6212, 6142, "if (_daoZapData.zapData.projectTeamSplit == address(0)) {\n            if (_daoZapData.zapData.safe != address(0)) {\n                _daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe;\n            } else {\n                revert ProjectTeamSplitNotCreated();\n            }\n        }");
insert IfStatement(6213, 6212, "if (_daoZapData.zapData.projectTeamSplit == address(0)) {\n            if (_daoZapData.zapData.safe != address(0)) {\n                _daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe;\n            } else {\n                revert ProjectTeamSplitNotCreated();\n            }\n        }");
insert Expression(6214, 6213, "_daoZapData.zapData.projectTeamSplit == address(0)");
insert BinaryExpression(6215, 6214, "_daoZapData.zapData.projectTeamSplit == address(0)");
insert Expression(6216, 6215, "_daoZapData.zapData.projectTeamSplit");
insert MemberExpression(6217, 6216, "_daoZapData.zapData.projectTeamSplit");
insert Expression(6218, 6217, "_daoZapData.zapData");
insert MemberExpression(6219, 6218, "_daoZapData.zapData");
insert Identifier(6220, 6219, "_daoZapData");
insert Identifier(6221, 6219, "zapData");
insert Identifier(6222, 6217, "projectTeamSplit");
insert Expression(6223, 6215, "address(0)");
insert TypeCastExpression(6224, 6223, "address(0)");
insert PrimitiveType(6225, 6224, "address");
insert CallArgument(6226, 6224, "0");
insert Expression(6227, 6226, "0");
insert NumberLiteral(6228, 6227, "0");
insert Statement(6229, 6213, "{\n            if (_daoZapData.zapData.safe != address(0)) {\n                _daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe;\n            } else {\n                revert ProjectTeamSplitNotCreated();\n            }\n        }");
insert BlockStatement(6230, 6229, "{\n            if (_daoZapData.zapData.safe != address(0)) {\n                _daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe;\n            } else {\n                revert ProjectTeamSplitNotCreated();\n            }\n        }");
insert Statement(6231, 6230, "if (_daoZapData.zapData.safe != address(0)) {\n                _daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe;\n            } else {\n                revert ProjectTeamSplitNotCreated();\n            }");
insert IfStatement(6232, 6231, "if (_daoZapData.zapData.safe != address(0)) {\n                _daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe;\n            } else {\n                revert ProjectTeamSplitNotCreated();\n            }");
insert Expression(6233, 6232, "_daoZapData.zapData.safe != address(0)");
insert BinaryExpression(6234, 6233, "_daoZapData.zapData.safe != address(0)");
insert Expression(6235, 6234, "_daoZapData.zapData.safe");
insert MemberExpression(6236, 6235, "_daoZapData.zapData.safe");
insert Expression(6237, 6236, "_daoZapData.zapData");
insert MemberExpression(6238, 6237, "_daoZapData.zapData");
insert Identifier(6239, 6238, "_daoZapData");
insert Identifier(6240, 6238, "zapData");
insert Identifier(6241, 6236, "safe");
insert Expression(6242, 6234, "address(0)");
insert TypeCastExpression(6243, 6242, "address(0)");
insert PrimitiveType(6244, 6243, "address");
insert CallArgument(6245, 6243, "0");
insert Expression(6246, 6245, "0");
insert NumberLiteral(6247, 6246, "0");
insert Statement(6248, 6232, "{\n                _daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe;\n            }");
insert BlockStatement(6249, 6248, "{\n                _daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe;\n            }");
insert Statement(6250, 6249, "_daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe;");
insert ExpressionStatement(6251, 6250, "_daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe;");
insert Expression(6252, 6251, "_daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe");
insert AssignmentExpression(6253, 6252, "_daoZapData.zapData.projectTeamSplit = _daoZapData.zapData.safe");
insert Expression(6254, 6253, "_daoZapData.zapData.projectTeamSplit");
insert MemberExpression(6255, 6254, "_daoZapData.zapData.projectTeamSplit");
insert Expression(6256, 6255, "_daoZapData.zapData");
insert MemberExpression(6257, 6256, "_daoZapData.zapData");
insert Identifier(6258, 6257, "_daoZapData");
insert Identifier(6259, 6257, "zapData");
insert Identifier(6260, 6255, "projectTeamSplit");
insert Expression(6261, 6253, "_daoZapData.zapData.safe");
insert MemberExpression(6262, 6261, "_daoZapData.zapData.safe");
insert Expression(6263, 6262, "_daoZapData.zapData");
insert MemberExpression(6264, 6263, "_daoZapData.zapData");
insert Identifier(6265, 6264, "_daoZapData");
insert Identifier(6266, 6264, "zapData");
insert Identifier(6267, 6262, "safe");
insert Statement(6268, 6232, "{\n                revert ProjectTeamSplitNotCreated();\n            }");
insert BlockStatement(6269, 6268, "{\n                revert ProjectTeamSplitNotCreated();\n            }");
insert Statement(6270, 6269, "revert ProjectTeamSplitNotCreated();");
insert RevertStatement(6271, 6270, "revert ProjectTeamSplitNotCreated();");
insert Expression(6272, 6271, "ProjectTeamSplitNotCreated");
insert Identifier(6273, 6272, "ProjectTeamSplitNotCreated");
insert RevertArguments(6274, 6271, "()");
insert Comment(6275, 6142, "// Create DAO split if required");
insert Statement(6276, 6142, "if (!daoSplit) return _daoZapData;");
insert IfStatement(6277, 6276, "if (!daoSplit) return _daoZapData;");
insert Expression(6278, 6277, "!daoSplit");
insert UnaryExpression(6279, 6278, "!daoSplit");
insert Expression(6280, 6279, "daoSplit");
insert Identifier(6281, 6280, "daoSplit");
insert Statement(6282, 6277, "return _daoZapData;");
insert ReturnStatement(6283, 6282, "return _daoZapData;");
insert Expression(6284, 6283, "_daoZapData");
insert Identifier(6285, 6284, "_daoZapData");
insert Comment(6286, 6142, "// Prepare arrays for DAO split");
insert Statement(6287, 6142, "address[] memory daoSplitRecipients = new address[](2);");
insert VariableDeclarationStatement(6288, 6287, "address[] memory daoSplitRecipients = new address[](2);");
insert VariableDeclaration(6289, 6288, "address[] memory daoSplitRecipients");
insert TypeName(6290, 6289, "address[]");
insert TypeName(6291, 6290, "address");
insert PrimitiveType(6292, 6291, "address");
insert Identifier(6293, 6289, "daoSplitRecipients");
insert Expression(6294, 6288, "new address[](2)");
insert CallExpression(6295, 6294, "new address[](2)");
insert Expression(6296, 6295, "new address[]");
insert NewExpression(6297, 6296, "new address[]");
insert TypeName(6298, 6297, "address[]");
insert TypeName(6299, 6298, "address");
insert PrimitiveType(6300, 6299, "address");
insert CallArgument(6301, 6295, "2");
insert Expression(6302, 6301, "2");
insert NumberLiteral(6303, 6302, "2");
insert Statement(6304, 6142, "uint32[] memory daoSplitPercentAllocations = new uint32[](2);");
insert VariableDeclarationStatement(6305, 6304, "uint32[] memory daoSplitPercentAllocations = new uint32[](2);");
insert VariableDeclaration(6306, 6305, "uint32[] memory daoSplitPercentAllocations");
insert TypeName(6307, 6306, "uint32[]");
insert TypeName(6308, 6307, "uint32");
insert PrimitiveType(6309, 6308, "uint32");
insert Identifier(6310, 6306, "daoSplitPercentAllocations");
insert Expression(6311, 6305, "new uint32[](2)");
insert CallExpression(6312, 6311, "new uint32[](2)");
insert Expression(6313, 6312, "new uint32[]");
insert NewExpression(6314, 6313, "new uint32[]");
insert TypeName(6315, 6314, "uint32[]");
insert TypeName(6316, 6315, "uint32");
insert PrimitiveType(6317, 6316, "uint32");
insert CallArgument(6318, 6312, "2");
insert Expression(6319, 6318, "2");
insert NumberLiteral(6320, 6319, "2");
insert Comment(6321, 6142, "// Get DAO split recipients and amounts");
insert Statement(6322, 6142, "address daoReceiver = spoilsManager.receiver();");
insert VariableDeclarationStatement(6323, 6322, "address daoReceiver = spoilsManager.receiver();");
insert VariableDeclaration(6324, 6323, "address daoReceiver");
insert TypeName(6325, 6324, "address");
insert PrimitiveType(6326, 6325, "address");
insert Identifier(6327, 6324, "daoReceiver");
insert Expression(6328, 6323, "spoilsManager.receiver()");
insert CallExpression(6329, 6328, "spoilsManager.receiver()");
insert Expression(6330, 6329, "spoilsManager.receiver");
insert MemberExpression(6331, 6330, "spoilsManager.receiver");
insert Identifier(6332, 6331, "spoilsManager");
insert Identifier(6333, 6331, "receiver");
insert Statement(6334, 6142, "uint32 daoSplitAmount = spoilsManager.getSpoils();");
insert VariableDeclarationStatement(6335, 6334, "uint32 daoSplitAmount = spoilsManager.getSpoils();");
insert VariableDeclaration(6336, 6335, "uint32 daoSplitAmount");
insert TypeName(6337, 6336, "uint32");
insert PrimitiveType(6338, 6337, "uint32");
insert Identifier(6339, 6336, "daoSplitAmount");
insert Expression(6340, 6335, "spoilsManager.getSpoils()");
insert CallExpression(6341, 6340, "spoilsManager.getSpoils()");
insert Expression(6342, 6341, "spoilsManager.getSpoils");
insert MemberExpression(6343, 6342, "spoilsManager.getSpoils");
insert Identifier(6344, 6343, "spoilsManager");
insert Identifier(6345, 6343, "getSpoils");
insert Statement(6346, 6142, "uint32 projectSplitAmount = (100 *\n            spoilsManager.SPLIT_PERCENTAGE_SCALE()) - daoSplitAmount;");
insert VariableDeclarationStatement(6347, 6346, "uint32 projectSplitAmount = (100 *\n            spoilsManager.SPLIT_PERCENTAGE_SCALE()) - daoSplitAmount;");
insert VariableDeclaration(6348, 6347, "uint32 projectSplitAmount");
insert TypeName(6349, 6348, "uint32");
insert PrimitiveType(6350, 6349, "uint32");
insert Identifier(6351, 6348, "projectSplitAmount");
insert Expression(6352, 6347, "(100 *\n            spoilsManager.SPLIT_PERCENTAGE_SCALE()) - daoSplitAmount");
insert BinaryExpression(6353, 6352, "(100 *\n            spoilsManager.SPLIT_PERCENTAGE_SCALE()) - daoSplitAmount");
insert Expression(6354, 6353, "(100 *\n            spoilsManager.SPLIT_PERCENTAGE_SCALE())");
insert ParenthesizedExpression(6355, 6354, "(100 *\n            spoilsManager.SPLIT_PERCENTAGE_SCALE())");
insert Expression(6356, 6355, "100 *\n            spoilsManager.SPLIT_PERCENTAGE_SCALE()");
insert CallExpression(6357, 6356, "100 *\n            spoilsManager.SPLIT_PERCENTAGE_SCALE()");
insert Expression(6358, 6357, "100 *\n            spoilsManager.SPLIT_PERCENTAGE_SCALE");
insert MemberExpression(6359, 6358, "100 *\n            spoilsManager.SPLIT_PERCENTAGE_SCALE");
insert Expression(6360, 6359, "100 *\n            spoilsManager");
insert BinaryExpression(6361, 6360, "100 *\n            spoilsManager");
insert Expression(6362, 6361, "100");
insert NumberLiteral(6363, 6362, "100");
insert Expression(6364, 6361, "spoilsManager");
insert Identifier(6365, 6364, "spoilsManager");
insert Identifier(6366, 6359, "SPLIT_PERCENTAGE_SCALE");
insert Expression(6367, 6353, "daoSplitAmount");
insert Identifier(6368, 6367, "daoSplitAmount");
insert Comment(6369, 6142, "// Sort the addresses and amounts in the correct order");
insert Statement(6370, 6142, "if (\n            uint160(daoReceiver) < uint160(_daoZapData.zapData.projectTeamSplit)\n        ) {\n            daoSplitRecipients[0] = daoReceiver;\n            daoSplitRecipients[1] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitPercentAllocations[0] = daoSplitAmount;\n            daoSplitPercentAllocations[1] = projectSplitAmount;\n        } else {\n            daoSplitRecipients[0] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitRecipients[1] = daoReceiver;\n            daoSplitPercentAllocations[0] = projectSplitAmount;\n            daoSplitPercentAllocations[1] = daoSplitAmount;\n        }");
insert IfStatement(6371, 6370, "if (\n            uint160(daoReceiver) < uint160(_daoZapData.zapData.projectTeamSplit)\n        ) {\n            daoSplitRecipients[0] = daoReceiver;\n            daoSplitRecipients[1] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitPercentAllocations[0] = daoSplitAmount;\n            daoSplitPercentAllocations[1] = projectSplitAmount;\n        } else {\n            daoSplitRecipients[0] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitRecipients[1] = daoReceiver;\n            daoSplitPercentAllocations[0] = projectSplitAmount;\n            daoSplitPercentAllocations[1] = daoSplitAmount;\n        }");
insert Expression(6372, 6371, "uint160(daoReceiver) < uint160(_daoZapData.zapData.projectTeamSplit)");
insert BinaryExpression(6373, 6372, "uint160(daoReceiver) < uint160(_daoZapData.zapData.projectTeamSplit)");
insert Expression(6374, 6373, "uint160(daoReceiver)");
insert TypeCastExpression(6375, 6374, "uint160(daoReceiver)");
insert PrimitiveType(6376, 6375, "uint160");
insert CallArgument(6377, 6375, "daoReceiver");
insert Expression(6378, 6377, "daoReceiver");
insert Identifier(6379, 6378, "daoReceiver");
insert Expression(6380, 6373, "uint160(_daoZapData.zapData.projectTeamSplit)");
insert TypeCastExpression(6381, 6380, "uint160(_daoZapData.zapData.projectTeamSplit)");
insert PrimitiveType(6382, 6381, "uint160");
insert CallArgument(6383, 6381, "_daoZapData.zapData.projectTeamSplit");
insert Expression(6384, 6383, "_daoZapData.zapData.projectTeamSplit");
insert MemberExpression(6385, 6384, "_daoZapData.zapData.projectTeamSplit");
insert Expression(6386, 6385, "_daoZapData.zapData");
insert MemberExpression(6387, 6386, "_daoZapData.zapData");
insert Identifier(6388, 6387, "_daoZapData");
insert Identifier(6389, 6387, "zapData");
insert Identifier(6390, 6385, "projectTeamSplit");
insert Statement(6391, 6371, "{\n            daoSplitRecipients[0] = daoReceiver;\n            daoSplitRecipients[1] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitPercentAllocations[0] = daoSplitAmount;\n            daoSplitPercentAllocations[1] = projectSplitAmount;\n        }");
insert BlockStatement(6392, 6391, "{\n            daoSplitRecipients[0] = daoReceiver;\n            daoSplitRecipients[1] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitPercentAllocations[0] = daoSplitAmount;\n            daoSplitPercentAllocations[1] = projectSplitAmount;\n        }");
insert Statement(6393, 6392, "daoSplitRecipients[0] = daoReceiver;");
insert ExpressionStatement(6394, 6393, "daoSplitRecipients[0] = daoReceiver;");
insert Expression(6395, 6394, "daoSplitRecipients[0] = daoReceiver");
insert AssignmentExpression(6396, 6395, "daoSplitRecipients[0] = daoReceiver");
insert Expression(6397, 6396, "daoSplitRecipients[0]");
insert ArrayAccess(6398, 6397, "daoSplitRecipients[0]");
insert Expression(6399, 6398, "daoSplitRecipients");
insert Identifier(6400, 6399, "daoSplitRecipients");
insert Expression(6401, 6398, "0");
insert NumberLiteral(6402, 6401, "0");
insert Expression(6403, 6396, "daoReceiver");
insert Identifier(6404, 6403, "daoReceiver");
insert Statement(6405, 6392, "daoSplitRecipients[1] = _daoZapData.zapData.projectTeamSplit;");
insert ExpressionStatement(6406, 6405, "daoSplitRecipients[1] = _daoZapData.zapData.projectTeamSplit;");
insert Expression(6407, 6406, "daoSplitRecipients[1] = _daoZapData.zapData.projectTeamSplit");
insert AssignmentExpression(6408, 6407, "daoSplitRecipients[1] = _daoZapData.zapData.projectTeamSplit");
insert Expression(6409, 6408, "daoSplitRecipients[1]");
insert ArrayAccess(6410, 6409, "daoSplitRecipients[1]");
insert Expression(6411, 6410, "daoSplitRecipients");
insert Identifier(6412, 6411, "daoSplitRecipients");
insert Expression(6413, 6410, "1");
insert NumberLiteral(6414, 6413, "1");
insert Expression(6415, 6408, "_daoZapData.zapData.projectTeamSplit");
insert MemberExpression(6416, 6415, "_daoZapData.zapData.projectTeamSplit");
insert Expression(6417, 6416, "_daoZapData.zapData");
insert MemberExpression(6418, 6417, "_daoZapData.zapData");
insert Identifier(6419, 6418, "_daoZapData");
insert Identifier(6420, 6418, "zapData");
insert Identifier(6421, 6416, "projectTeamSplit");
insert Statement(6422, 6392, "daoSplitPercentAllocations[0] = daoSplitAmount;");
insert ExpressionStatement(6423, 6422, "daoSplitPercentAllocations[0] = daoSplitAmount;");
insert Expression(6424, 6423, "daoSplitPercentAllocations[0] = daoSplitAmount");
insert AssignmentExpression(6425, 6424, "daoSplitPercentAllocations[0] = daoSplitAmount");
insert Expression(6426, 6425, "daoSplitPercentAllocations[0]");
insert ArrayAccess(6427, 6426, "daoSplitPercentAllocations[0]");
insert Expression(6428, 6427, "daoSplitPercentAllocations");
insert Identifier(6429, 6428, "daoSplitPercentAllocations");
insert Expression(6430, 6427, "0");
insert NumberLiteral(6431, 6430, "0");
insert Expression(6432, 6425, "daoSplitAmount");
insert Identifier(6433, 6432, "daoSplitAmount");
insert Statement(6434, 6392, "daoSplitPercentAllocations[1] = projectSplitAmount;");
insert ExpressionStatement(6435, 6434, "daoSplitPercentAllocations[1] = projectSplitAmount;");
insert Expression(6436, 6435, "daoSplitPercentAllocations[1] = projectSplitAmount");
insert AssignmentExpression(6437, 6436, "daoSplitPercentAllocations[1] = projectSplitAmount");
insert Expression(6438, 6437, "daoSplitPercentAllocations[1]");
insert ArrayAccess(6439, 6438, "daoSplitPercentAllocations[1]");
insert Expression(6440, 6439, "daoSplitPercentAllocations");
insert Identifier(6441, 6440, "daoSplitPercentAllocations");
insert Expression(6442, 6439, "1");
insert NumberLiteral(6443, 6442, "1");
insert Expression(6444, 6437, "projectSplitAmount");
insert Identifier(6445, 6444, "projectSplitAmount");
insert Statement(6446, 6371, "{\n            daoSplitRecipients[0] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitRecipients[1] = daoReceiver;\n            daoSplitPercentAllocations[0] = projectSplitAmount;\n            daoSplitPercentAllocations[1] = daoSplitAmount;\n        }");
insert BlockStatement(6447, 6446, "{\n            daoSplitRecipients[0] = _daoZapData.zapData.projectTeamSplit;\n            daoSplitRecipients[1] = daoReceiver;\n            daoSplitPercentAllocations[0] = projectSplitAmount;\n            daoSplitPercentAllocations[1] = daoSplitAmount;\n        }");
insert Statement(6448, 6447, "daoSplitRecipients[0] = _daoZapData.zapData.projectTeamSplit;");
insert ExpressionStatement(6449, 6448, "daoSplitRecipients[0] = _daoZapData.zapData.projectTeamSplit;");
insert Expression(6450, 6449, "daoSplitRecipients[0] = _daoZapData.zapData.projectTeamSplit");
insert AssignmentExpression(6451, 6450, "daoSplitRecipients[0] = _daoZapData.zapData.projectTeamSplit");
insert Expression(6452, 6451, "daoSplitRecipients[0]");
insert ArrayAccess(6453, 6452, "daoSplitRecipients[0]");
insert Expression(6454, 6453, "daoSplitRecipients");
insert Identifier(6455, 6454, "daoSplitRecipients");
insert Expression(6456, 6453, "0");
insert NumberLiteral(6457, 6456, "0");
insert Expression(6458, 6451, "_daoZapData.zapData.projectTeamSplit");
insert MemberExpression(6459, 6458, "_daoZapData.zapData.projectTeamSplit");
insert Expression(6460, 6459, "_daoZapData.zapData");
insert MemberExpression(6461, 6460, "_daoZapData.zapData");
insert Identifier(6462, 6461, "_daoZapData");
insert Identifier(6463, 6461, "zapData");
insert Identifier(6464, 6459, "projectTeamSplit");
insert Statement(6465, 6447, "daoSplitRecipients[1] = daoReceiver;");
insert ExpressionStatement(6466, 6465, "daoSplitRecipients[1] = daoReceiver;");
insert Expression(6467, 6466, "daoSplitRecipients[1] = daoReceiver");
insert AssignmentExpression(6468, 6467, "daoSplitRecipients[1] = daoReceiver");
insert Expression(6469, 6468, "daoSplitRecipients[1]");
insert ArrayAccess(6470, 6469, "daoSplitRecipients[1]");
insert Expression(6471, 6470, "daoSplitRecipients");
insert Identifier(6472, 6471, "daoSplitRecipients");
insert Expression(6473, 6470, "1");
insert NumberLiteral(6474, 6473, "1");
insert Expression(6475, 6468, "daoReceiver");
insert Identifier(6476, 6475, "daoReceiver");
insert Statement(6477, 6447, "daoSplitPercentAllocations[0] = projectSplitAmount;");
insert ExpressionStatement(6478, 6477, "daoSplitPercentAllocations[0] = projectSplitAmount;");
insert Expression(6479, 6478, "daoSplitPercentAllocations[0] = projectSplitAmount");
insert AssignmentExpression(6480, 6479, "daoSplitPercentAllocations[0] = projectSplitAmount");
insert Expression(6481, 6480, "daoSplitPercentAllocations[0]");
insert ArrayAccess(6482, 6481, "daoSplitPercentAllocations[0]");
insert Expression(6483, 6482, "daoSplitPercentAllocations");
insert Identifier(6484, 6483, "daoSplitPercentAllocations");
insert Expression(6485, 6482, "0");
insert NumberLiteral(6486, 6485, "0");
insert Expression(6487, 6480, "projectSplitAmount");
insert Identifier(6488, 6487, "projectSplitAmount");
insert Statement(6489, 6447, "daoSplitPercentAllocations[1] = daoSplitAmount;");
insert ExpressionStatement(6490, 6489, "daoSplitPercentAllocations[1] = daoSplitAmount;");
insert Expression(6491, 6490, "daoSplitPercentAllocations[1] = daoSplitAmount");
insert AssignmentExpression(6492, 6491, "daoSplitPercentAllocations[1] = daoSplitAmount");
insert Expression(6493, 6492, "daoSplitPercentAllocations[1]");
insert ArrayAccess(6494, 6493, "daoSplitPercentAllocations[1]");
insert Expression(6495, 6494, "daoSplitPercentAllocations");
insert Identifier(6496, 6495, "daoSplitPercentAllocations");
insert Expression(6497, 6494, "1");
insert NumberLiteral(6498, 6497, "1");
insert Expression(6499, 6492, "daoSplitAmount");
insert Identifier(6500, 6499, "daoSplitAmount");
insert Comment(6501, 6142, "// Create DAO split");
insert Statement(6502, 6142, "_daoZapData.daoSplit = splitMain.createSplit(\n            daoSplitRecipients,\n            daoSplitPercentAllocations,\n            distributorFee,\n            dao\n        );");
insert ExpressionStatement(6503, 6502, "_daoZapData.daoSplit = splitMain.createSplit(\n            daoSplitRecipients,\n            daoSplitPercentAllocations,\n            distributorFee,\n            dao\n        );");
insert Expression(6504, 6503, "_daoZapData.daoSplit = splitMain.createSplit(\n            daoSplitRecipients,\n            daoSplitPercentAllocations,\n            distributorFee,\n            dao\n        )");
insert AssignmentExpression(6505, 6504, "_daoZapData.daoSplit = splitMain.createSplit(\n            daoSplitRecipients,\n            daoSplitPercentAllocations,\n            distributorFee,\n            dao\n        )");
insert Expression(6506, 6505, "_daoZapData.daoSplit");
insert MemberExpression(6507, 6506, "_daoZapData.daoSplit");
insert Identifier(6508, 6507, "_daoZapData");
insert Identifier(6509, 6507, "daoSplit");
insert Expression(6510, 6505, "splitMain.createSplit(\n            daoSplitRecipients,\n            daoSplitPercentAllocations,\n            distributorFee,\n            dao\n        )");
insert CallExpression(6511, 6510, "splitMain.createSplit(\n            daoSplitRecipients,\n            daoSplitPercentAllocations,\n            distributorFee,\n            dao\n        )");
insert Expression(6512, 6511, "splitMain.createSplit");
insert MemberExpression(6513, 6512, "splitMain.createSplit");
insert Identifier(6514, 6513, "splitMain");
insert Identifier(6515, 6513, "createSplit");
insert CallArgument(6516, 6511, "daoSplitRecipients");
insert Expression(6517, 6516, "daoSplitRecipients");
insert Identifier(6518, 6517, "daoSplitRecipients");
insert CallArgument(6519, 6511, "daoSplitPercentAllocations");
insert Expression(6520, 6519, "daoSplitPercentAllocations");
insert Identifier(6521, 6520, "daoSplitPercentAllocations");
insert CallArgument(6522, 6511, "distributorFee");
insert Expression(6523, 6522, "distributorFee");
insert Identifier(6524, 6523, "distributorFee");
insert CallArgument(6525, 6511, "dao");
insert Expression(6526, 6525, "dao");
insert Identifier(6527, 6526, "dao");
insert Statement(6528, 6142, "if (_daoZapData.daoSplit == address(0)) {\n            revert DaoSplitCreationFailed();\n        }");
insert IfStatement(6529, 6528, "if (_daoZapData.daoSplit == address(0)) {\n            revert DaoSplitCreationFailed();\n        }");
insert Expression(6530, 6529, "_daoZapData.daoSplit == address(0)");
insert BinaryExpression(6531, 6530, "_daoZapData.daoSplit == address(0)");
insert Expression(6532, 6531, "_daoZapData.daoSplit");
insert MemberExpression(6533, 6532, "_daoZapData.daoSplit");
insert Identifier(6534, 6533, "_daoZapData");
insert Identifier(6535, 6533, "daoSplit");
insert Expression(6536, 6531, "address(0)");
insert TypeCastExpression(6537, 6536, "address(0)");
insert PrimitiveType(6538, 6537, "address");
insert CallArgument(6539, 6537, "0");
insert Expression(6540, 6539, "0");
insert NumberLiteral(6541, 6540, "0");
insert Statement(6542, 6529, "{\n            revert DaoSplitCreationFailed();\n        }");
insert BlockStatement(6543, 6542, "{\n            revert DaoSplitCreationFailed();\n        }");
insert Statement(6544, 6543, "revert DaoSplitCreationFailed();");
insert RevertStatement(6545, 6544, "revert DaoSplitCreationFailed();");
insert Expression(6546, 6545, "DaoSplitCreationFailed");
insert Identifier(6547, 6546, "DaoSplitCreationFailed");
insert RevertArguments(6548, 6545, "()");
insert Statement(6549, 6142, "return _daoZapData;");
insert ReturnStatement(6550, 6549, "return _daoZapData;");
insert Expression(6551, 6550, "_daoZapData");
insert Identifier(6552, 6551, "_daoZapData");
insert Comment(6553, 6062, "/**\n     * @dev Internal function to handle escrow parameters.\n     * @param _daoZapData The data struct for storing deployment results.\n     * @return The escrow parameters for the deployment.\n     */");
insert FunctionDefinition(6554, 6062, "function _handleEscrowParams(\n        DaoZapData memory _daoZapData\n    ) internal view returns (address[] memory) {\n        address[] memory escrowParams = new address[](2);\n        escrowParams[0] = _daoZapData.zapData.safe;\n        escrowParams[1] = _daoZapData.zapData.projectTeamSplit;\n\n        if (_daoZapData.daoSplit != address(0)) {\n            escrowParams[0] = dao;\n            escrowParams[1] = _daoZapData.daoSplit;\n        }\n\n        return escrowParams;\n    }");
insert Identifier(6555, 6554, "_handleEscrowParams");
insert Parameter(6556, 6554, "DaoZapData memory _daoZapData");
insert TypeName(6557, 6556, "DaoZapData");
insert UserDefinedType(6558, 6557, "DaoZapData");
insert Identifier(6559, 6558, "DaoZapData");
insert Identifier(6560, 6556, "_daoZapData");
insert Visibility(6561, 6554, "internal");
insert StateMutability(6562, 6554, "view");
insert ReturnTypeDefinition(6563, 6554, "returns (address[] memory)");
insert Parameter(6564, 6563, "address[] memory");
insert TypeName(6565, 6564, "address[]");
insert TypeName(6566, 6565, "address");
insert PrimitiveType(6567, 6566, "address");
insert FunctionBody(6568, 6554, "{\n        address[] memory escrowParams = new address[](2);\n        escrowParams[0] = _daoZapData.zapData.safe;\n        escrowParams[1] = _daoZapData.zapData.projectTeamSplit;\n\n        if (_daoZapData.daoSplit != address(0)) {\n            escrowParams[0] = dao;\n            escrowParams[1] = _daoZapData.daoSplit;\n        }\n\n        return escrowParams;\n    }");
insert Statement(6569, 6568, "address[] memory escrowParams = new address[](2);");
insert VariableDeclarationStatement(6570, 6569, "address[] memory escrowParams = new address[](2);");
insert VariableDeclaration(6571, 6570, "address[] memory escrowParams");
insert TypeName(6572, 6571, "address[]");
insert TypeName(6573, 6572, "address");
insert PrimitiveType(6574, 6573, "address");
insert Identifier(6575, 6571, "escrowParams");
insert Expression(6576, 6570, "new address[](2)");
insert CallExpression(6577, 6576, "new address[](2)");
insert Expression(6578, 6577, "new address[]");
insert NewExpression(6579, 6578, "new address[]");
insert TypeName(6580, 6579, "address[]");
insert TypeName(6581, 6580, "address");
insert PrimitiveType(6582, 6581, "address");
insert CallArgument(6583, 6577, "2");
insert Expression(6584, 6583, "2");
insert NumberLiteral(6585, 6584, "2");
insert Statement(6586, 6568, "escrowParams[0] = _daoZapData.zapData.safe;");
insert ExpressionStatement(6587, 6586, "escrowParams[0] = _daoZapData.zapData.safe;");
insert Expression(6588, 6587, "escrowParams[0] = _daoZapData.zapData.safe");
insert AssignmentExpression(6589, 6588, "escrowParams[0] = _daoZapData.zapData.safe");
insert Expression(6590, 6589, "escrowParams[0]");
insert ArrayAccess(6591, 6590, "escrowParams[0]");
insert Expression(6592, 6591, "escrowParams");
insert Identifier(6593, 6592, "escrowParams");
insert Expression(6594, 6591, "0");
insert NumberLiteral(6595, 6594, "0");
insert Expression(6596, 6589, "_daoZapData.zapData.safe");
insert MemberExpression(6597, 6596, "_daoZapData.zapData.safe");
insert Expression(6598, 6597, "_daoZapData.zapData");
insert MemberExpression(6599, 6598, "_daoZapData.zapData");
insert Identifier(6600, 6599, "_daoZapData");
insert Identifier(6601, 6599, "zapData");
insert Identifier(6602, 6597, "safe");
insert Statement(6603, 6568, "escrowParams[1] = _daoZapData.zapData.projectTeamSplit;");
insert ExpressionStatement(6604, 6603, "escrowParams[1] = _daoZapData.zapData.projectTeamSplit;");
insert Expression(6605, 6604, "escrowParams[1] = _daoZapData.zapData.projectTeamSplit");
insert AssignmentExpression(6606, 6605, "escrowParams[1] = _daoZapData.zapData.projectTeamSplit");
insert Expression(6607, 6606, "escrowParams[1]");
insert ArrayAccess(6608, 6607, "escrowParams[1]");
insert Expression(6609, 6608, "escrowParams");
insert Identifier(6610, 6609, "escrowParams");
insert Expression(6611, 6608, "1");
insert NumberLiteral(6612, 6611, "1");
insert Expression(6613, 6606, "_daoZapData.zapData.projectTeamSplit");
insert MemberExpression(6614, 6613, "_daoZapData.zapData.projectTeamSplit");
insert Expression(6615, 6614, "_daoZapData.zapData");
insert MemberExpression(6616, 6615, "_daoZapData.zapData");
insert Identifier(6617, 6616, "_daoZapData");
insert Identifier(6618, 6616, "zapData");
insert Identifier(6619, 6614, "projectTeamSplit");
insert Statement(6620, 6568, "if (_daoZapData.daoSplit != address(0)) {\n            escrowParams[0] = dao;\n            escrowParams[1] = _daoZapData.daoSplit;\n        }");
insert IfStatement(6621, 6620, "if (_daoZapData.daoSplit != address(0)) {\n            escrowParams[0] = dao;\n            escrowParams[1] = _daoZapData.daoSplit;\n        }");
insert Expression(6622, 6621, "_daoZapData.daoSplit != address(0)");
insert BinaryExpression(6623, 6622, "_daoZapData.daoSplit != address(0)");
insert Expression(6624, 6623, "_daoZapData.daoSplit");
insert MemberExpression(6625, 6624, "_daoZapData.daoSplit");
insert Identifier(6626, 6625, "_daoZapData");
insert Identifier(6627, 6625, "daoSplit");
insert Expression(6628, 6623, "address(0)");
insert TypeCastExpression(6629, 6628, "address(0)");
insert PrimitiveType(6630, 6629, "address");
insert CallArgument(6631, 6629, "0");
insert Expression(6632, 6631, "0");
insert NumberLiteral(6633, 6632, "0");
insert Statement(6634, 6621, "{\n            escrowParams[0] = dao;\n            escrowParams[1] = _daoZapData.daoSplit;\n        }");
insert BlockStatement(6635, 6634, "{\n            escrowParams[0] = dao;\n            escrowParams[1] = _daoZapData.daoSplit;\n        }");
insert Statement(6636, 6635, "escrowParams[0] = dao;");
insert ExpressionStatement(6637, 6636, "escrowParams[0] = dao;");
insert Expression(6638, 6637, "escrowParams[0] = dao");
insert AssignmentExpression(6639, 6638, "escrowParams[0] = dao");
insert Expression(6640, 6639, "escrowParams[0]");
insert ArrayAccess(6641, 6640, "escrowParams[0]");
insert Expression(6642, 6641, "escrowParams");
insert Identifier(6643, 6642, "escrowParams");
insert Expression(6644, 6641, "0");
insert NumberLiteral(6645, 6644, "0");
insert Expression(6646, 6639, "dao");
insert Identifier(6647, 6646, "dao");
insert Statement(6648, 6635, "escrowParams[1] = _daoZapData.daoSplit;");
insert ExpressionStatement(6649, 6648, "escrowParams[1] = _daoZapData.daoSplit;");
insert Expression(6650, 6649, "escrowParams[1] = _daoZapData.daoSplit");
insert AssignmentExpression(6651, 6650, "escrowParams[1] = _daoZapData.daoSplit");
insert Expression(6652, 6651, "escrowParams[1]");
insert ArrayAccess(6653, 6652, "escrowParams[1]");
insert Expression(6654, 6653, "escrowParams");
insert Identifier(6655, 6654, "escrowParams");
insert Expression(6656, 6653, "1");
insert NumberLiteral(6657, 6656, "1");
insert Expression(6658, 6651, "_daoZapData.daoSplit");
insert MemberExpression(6659, 6658, "_daoZapData.daoSplit");
insert Identifier(6660, 6659, "_daoZapData");
insert Identifier(6661, 6659, "daoSplit");
insert Statement(6662, 6568, "return escrowParams;");
insert ReturnStatement(6663, 6662, "return escrowParams;");
insert Expression(6664, 6663, "escrowParams");
insert Identifier(6665, 6664, "escrowParams");
insert Comment(6666, 6062, "/**\n     * @dev Internal function to create a new Safe, Split, and Escrow with DAO support.\n     * @param _owners The list of owners for the Safe and Split.\n     * @param _percentAllocations The percent allocations for the Split.\n     * @param _milestoneAmounts The milestone amounts for the Escrow.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitsData The encoded data for Split setup.\n     * @param _escrowData The encoded data for Escrow setup.\n     */");
insert FunctionDefinition(6667, 6062, "function _createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitsData,\n        bytes calldata _escrowData\n    ) internal override {\n        // Initialize DaoZapData\n        DaoZapData memory daoZapData = DaoZapData({\n            zapData: ZapData({\n                safe: _safeAddress,\n                projectTeamSplit: address(0),\n                escrow: address(0)\n            }),\n            daoSplit: address(0)\n        });\n\n        // Deploy Safe if not already provided\n        if (daoZapData.zapData.safe == address(0)) {\n            daoZapData.zapData = _deploySafe(\n                _owners,\n                _safeData,\n                daoZapData.zapData\n            );\n        }\n\n        // Create Split(s)\n        daoZapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitsData,\n            daoZapData\n        );\n\n        // Handle escrow parameters and deploy escrow\n        address[] memory escrowParams = _handleEscrowParams(daoZapData);\n        daoZapData.zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            daoZapData.zapData\n        );\n\n        // Emit event for the created Safe splits DAO escrow\n        emit SafeSplitsDaoEscrowCreated(\n            daoZapData.zapData.safe,\n            daoZapData.zapData.projectTeamSplit,\n            daoZapData.daoSplit,\n            daoZapData.zapData.escrow\n        );\n    }");
insert Identifier(6668, 6667, "_createSafeSplitEscrow");
insert Parameter(6669, 6667, "address[] memory _owners");
insert TypeName(6670, 6669, "address[]");
insert TypeName(6671, 6670, "address");
insert PrimitiveType(6672, 6671, "address");
insert Identifier(6673, 6669, "_owners");
insert Parameter(6674, 6667, "uint32[] memory _percentAllocations");
insert TypeName(6675, 6674, "uint32[]");
insert TypeName(6676, 6675, "uint32");
insert PrimitiveType(6677, 6676, "uint32");
insert Identifier(6678, 6674, "_percentAllocations");
insert Parameter(6679, 6667, "uint256[] memory _milestoneAmounts");
insert TypeName(6680, 6679, "uint256[]");
insert TypeName(6681, 6680, "uint256");
insert PrimitiveType(6682, 6681, "uint256");
insert Identifier(6683, 6679, "_milestoneAmounts");
insert Parameter(6684, 6667, "bytes calldata _safeData");
insert TypeName(6685, 6684, "bytes");
insert PrimitiveType(6686, 6685, "bytes");
insert Identifier(6687, 6684, "_safeData");
insert Parameter(6688, 6667, "address _safeAddress");
insert TypeName(6689, 6688, "address");
insert PrimitiveType(6690, 6689, "address");
insert Identifier(6691, 6688, "_safeAddress");
insert Parameter(6692, 6667, "bytes calldata _splitsData");
insert TypeName(6693, 6692, "bytes");
insert PrimitiveType(6694, 6693, "bytes");
insert Identifier(6695, 6692, "_splitsData");
insert Parameter(6696, 6667, "bytes calldata _escrowData");
insert TypeName(6697, 6696, "bytes");
insert PrimitiveType(6698, 6697, "bytes");
insert Identifier(6699, 6696, "_escrowData");
insert Visibility(6700, 6667, "internal");
insert OverrideSpecifier(6701, 6667, "override");
insert FunctionBody(6702, 6667, "{\n        // Initialize DaoZapData\n        DaoZapData memory daoZapData = DaoZapData({\n            zapData: ZapData({\n                safe: _safeAddress,\n                projectTeamSplit: address(0),\n                escrow: address(0)\n            }),\n            daoSplit: address(0)\n        });\n\n        // Deploy Safe if not already provided\n        if (daoZapData.zapData.safe == address(0)) {\n            daoZapData.zapData = _deploySafe(\n                _owners,\n                _safeData,\n                daoZapData.zapData\n            );\n        }\n\n        // Create Split(s)\n        daoZapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitsData,\n            daoZapData\n        );\n\n        // Handle escrow parameters and deploy escrow\n        address[] memory escrowParams = _handleEscrowParams(daoZapData);\n        daoZapData.zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            daoZapData.zapData\n        );\n\n        // Emit event for the created Safe splits DAO escrow\n        emit SafeSplitsDaoEscrowCreated(\n            daoZapData.zapData.safe,\n            daoZapData.zapData.projectTeamSplit,\n            daoZapData.daoSplit,\n            daoZapData.zapData.escrow\n        );\n    }");
insert Comment(6703, 6702, "// Initialize DaoZapData");
insert Statement(6704, 6702, "DaoZapData memory daoZapData = DaoZapData({\n            zapData: ZapData({\n                safe: _safeAddress,\n                projectTeamSplit: address(0),\n                escrow: address(0)\n            }),\n            daoSplit: address(0)\n        });");
insert VariableDeclarationStatement(6705, 6704, "DaoZapData memory daoZapData = DaoZapData({\n            zapData: ZapData({\n                safe: _safeAddress,\n                projectTeamSplit: address(0),\n                escrow: address(0)\n            }),\n            daoSplit: address(0)\n        });");
insert VariableDeclaration(6706, 6705, "DaoZapData memory daoZapData");
insert TypeName(6707, 6706, "DaoZapData");
insert UserDefinedType(6708, 6707, "DaoZapData");
insert Identifier(6709, 6708, "DaoZapData");
insert Identifier(6710, 6706, "daoZapData");
insert Expression(6711, 6705, "DaoZapData({\n            zapData: ZapData({\n                safe: _safeAddress,\n                projectTeamSplit: address(0),\n                escrow: address(0)\n            }),\n            daoSplit: address(0)\n        })");
insert CallExpression(6712, 6711, "DaoZapData({\n            zapData: ZapData({\n                safe: _safeAddress,\n                projectTeamSplit: address(0),\n                escrow: address(0)\n            }),\n            daoSplit: address(0)\n        })");
insert Expression(6713, 6712, "DaoZapData");
insert Identifier(6714, 6713, "DaoZapData");
insert CallArgument(6715, 6712, "{\n            zapData: ZapData({\n                safe: _safeAddress,\n                projectTeamSplit: address(0),\n                escrow: address(0)\n            }),\n            daoSplit: address(0)\n        }");
insert CallStructArgument(6716, 6715, "zapData: ZapData({\n                safe: _safeAddress,\n                projectTeamSplit: address(0),\n                escrow: address(0)\n            })");
insert Identifier(6717, 6716, "zapData");
insert Expression(6718, 6716, "ZapData({\n                safe: _safeAddress,\n                projectTeamSplit: address(0),\n                escrow: address(0)\n            })");
insert CallExpression(6719, 6718, "ZapData({\n                safe: _safeAddress,\n                projectTeamSplit: address(0),\n                escrow: address(0)\n            })");
insert Expression(6720, 6719, "ZapData");
insert Identifier(6721, 6720, "ZapData");
insert CallArgument(6722, 6719, "{\n                safe: _safeAddress,\n                projectTeamSplit: address(0),\n                escrow: address(0)\n            }");
insert CallStructArgument(6723, 6722, "safe: _safeAddress");
insert Identifier(6724, 6723, "safe");
insert Expression(6725, 6723, "_safeAddress");
insert Identifier(6726, 6725, "_safeAddress");
insert CallStructArgument(6727, 6722, "projectTeamSplit: address(0)");
insert Identifier(6728, 6727, "projectTeamSplit");
insert Expression(6729, 6727, "address(0)");
insert TypeCastExpression(6730, 6729, "address(0)");
insert PrimitiveType(6731, 6730, "address");
insert CallArgument(6732, 6730, "0");
insert Expression(6733, 6732, "0");
insert NumberLiteral(6734, 6733, "0");
insert CallStructArgument(6735, 6722, "escrow: address(0)");
insert Identifier(6736, 6735, "escrow");
insert Expression(6737, 6735, "address(0)");
insert TypeCastExpression(6738, 6737, "address(0)");
insert PrimitiveType(6739, 6738, "address");
insert CallArgument(6740, 6738, "0");
insert Expression(6741, 6740, "0");
insert NumberLiteral(6742, 6741, "0");
insert CallStructArgument(6743, 6715, "daoSplit: address(0)");
insert Identifier(6744, 6743, "daoSplit");
insert Expression(6745, 6743, "address(0)");
insert TypeCastExpression(6746, 6745, "address(0)");
insert PrimitiveType(6747, 6746, "address");
insert CallArgument(6748, 6746, "0");
insert Expression(6749, 6748, "0");
insert NumberLiteral(6750, 6749, "0");
insert Comment(6751, 6702, "// Deploy Safe if not already provided");
insert Statement(6752, 6702, "if (daoZapData.zapData.safe == address(0)) {\n            daoZapData.zapData = _deploySafe(\n                _owners,\n                _safeData,\n                daoZapData.zapData\n            );\n        }");
insert IfStatement(6753, 6752, "if (daoZapData.zapData.safe == address(0)) {\n            daoZapData.zapData = _deploySafe(\n                _owners,\n                _safeData,\n                daoZapData.zapData\n            );\n        }");
insert Expression(6754, 6753, "daoZapData.zapData.safe == address(0)");
insert BinaryExpression(6755, 6754, "daoZapData.zapData.safe == address(0)");
insert Expression(6756, 6755, "daoZapData.zapData.safe");
insert MemberExpression(6757, 6756, "daoZapData.zapData.safe");
insert Expression(6758, 6757, "daoZapData.zapData");
insert MemberExpression(6759, 6758, "daoZapData.zapData");
insert Identifier(6760, 6759, "daoZapData");
insert Identifier(6761, 6759, "zapData");
insert Identifier(6762, 6757, "safe");
insert Expression(6763, 6755, "address(0)");
insert TypeCastExpression(6764, 6763, "address(0)");
insert PrimitiveType(6765, 6764, "address");
insert CallArgument(6766, 6764, "0");
insert Expression(6767, 6766, "0");
insert NumberLiteral(6768, 6767, "0");
insert Statement(6769, 6753, "{\n            daoZapData.zapData = _deploySafe(\n                _owners,\n                _safeData,\n                daoZapData.zapData\n            );\n        }");
insert BlockStatement(6770, 6769, "{\n            daoZapData.zapData = _deploySafe(\n                _owners,\n                _safeData,\n                daoZapData.zapData\n            );\n        }");
insert Statement(6771, 6770, "daoZapData.zapData = _deploySafe(\n                _owners,\n                _safeData,\n                daoZapData.zapData\n            );");
insert ExpressionStatement(6772, 6771, "daoZapData.zapData = _deploySafe(\n                _owners,\n                _safeData,\n                daoZapData.zapData\n            );");
insert Expression(6773, 6772, "daoZapData.zapData = _deploySafe(\n                _owners,\n                _safeData,\n                daoZapData.zapData\n            )");
insert AssignmentExpression(6774, 6773, "daoZapData.zapData = _deploySafe(\n                _owners,\n                _safeData,\n                daoZapData.zapData\n            )");
insert Expression(6775, 6774, "daoZapData.zapData");
insert MemberExpression(6776, 6775, "daoZapData.zapData");
insert Identifier(6777, 6776, "daoZapData");
insert Identifier(6778, 6776, "zapData");
insert Expression(6779, 6774, "_deploySafe(\n                _owners,\n                _safeData,\n                daoZapData.zapData\n            )");
insert CallExpression(6780, 6779, "_deploySafe(\n                _owners,\n                _safeData,\n                daoZapData.zapData\n            )");
insert Expression(6781, 6780, "_deploySafe");
insert Identifier(6782, 6781, "_deploySafe");
insert CallArgument(6783, 6780, "_owners");
insert Expression(6784, 6783, "_owners");
insert Identifier(6785, 6784, "_owners");
insert CallArgument(6786, 6780, "_safeData");
insert Expression(6787, 6786, "_safeData");
insert Identifier(6788, 6787, "_safeData");
insert CallArgument(6789, 6780, "daoZapData.zapData");
insert Expression(6790, 6789, "daoZapData.zapData");
insert MemberExpression(6791, 6790, "daoZapData.zapData");
insert Identifier(6792, 6791, "daoZapData");
insert Identifier(6793, 6791, "zapData");
insert Comment(6794, 6702, "// Create Split(s)");
insert Statement(6795, 6702, "daoZapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitsData,\n            daoZapData\n        );");
insert ExpressionStatement(6796, 6795, "daoZapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitsData,\n            daoZapData\n        );");
insert Expression(6797, 6796, "daoZapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitsData,\n            daoZapData\n        )");
insert AssignmentExpression(6798, 6797, "daoZapData = _createSplit(\n            _owners,\n            _percentAllocations,\n            _splitsData,\n            daoZapData\n        )");
insert Expression(6799, 6798, "daoZapData");
insert Identifier(6800, 6799, "daoZapData");
insert Expression(6801, 6798, "_createSplit(\n            _owners,\n            _percentAllocations,\n            _splitsData,\n            daoZapData\n        )");
insert CallExpression(6802, 6801, "_createSplit(\n            _owners,\n            _percentAllocations,\n            _splitsData,\n            daoZapData\n        )");
insert Expression(6803, 6802, "_createSplit");
insert Identifier(6804, 6803, "_createSplit");
insert CallArgument(6805, 6802, "_owners");
insert Expression(6806, 6805, "_owners");
insert Identifier(6807, 6806, "_owners");
insert CallArgument(6808, 6802, "_percentAllocations");
insert Expression(6809, 6808, "_percentAllocations");
insert Identifier(6810, 6809, "_percentAllocations");
insert CallArgument(6811, 6802, "_splitsData");
insert Expression(6812, 6811, "_splitsData");
insert Identifier(6813, 6812, "_splitsData");
insert CallArgument(6814, 6802, "daoZapData");
insert Expression(6815, 6814, "daoZapData");
insert Identifier(6816, 6815, "daoZapData");
insert Comment(6817, 6702, "// Handle escrow parameters and deploy escrow");
insert Statement(6818, 6702, "address[] memory escrowParams = _handleEscrowParams(daoZapData);");
insert VariableDeclarationStatement(6819, 6818, "address[] memory escrowParams = _handleEscrowParams(daoZapData);");
insert VariableDeclaration(6820, 6819, "address[] memory escrowParams");
insert TypeName(6821, 6820, "address[]");
insert TypeName(6822, 6821, "address");
insert PrimitiveType(6823, 6822, "address");
insert Identifier(6824, 6820, "escrowParams");
insert Expression(6825, 6819, "_handleEscrowParams(daoZapData)");
insert CallExpression(6826, 6825, "_handleEscrowParams(daoZapData)");
insert Expression(6827, 6826, "_handleEscrowParams");
insert Identifier(6828, 6827, "_handleEscrowParams");
insert CallArgument(6829, 6826, "daoZapData");
insert Expression(6830, 6829, "daoZapData");
insert Identifier(6831, 6830, "daoZapData");
insert Statement(6832, 6702, "daoZapData.zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            daoZapData.zapData\n        );");
insert ExpressionStatement(6833, 6832, "daoZapData.zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            daoZapData.zapData\n        );");
insert Expression(6834, 6833, "daoZapData.zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            daoZapData.zapData\n        )");
insert AssignmentExpression(6835, 6834, "daoZapData.zapData = _deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            daoZapData.zapData\n        )");
insert Expression(6836, 6835, "daoZapData.zapData");
insert MemberExpression(6837, 6836, "daoZapData.zapData");
insert Identifier(6838, 6837, "daoZapData");
insert Identifier(6839, 6837, "zapData");
insert Expression(6840, 6835, "_deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            daoZapData.zapData\n        )");
insert CallExpression(6841, 6840, "_deployEscrow(\n            _milestoneAmounts,\n            _escrowData,\n            escrowParams,\n            daoZapData.zapData\n        )");
insert Expression(6842, 6841, "_deployEscrow");
insert Identifier(6843, 6842, "_deployEscrow");
insert CallArgument(6844, 6841, "_milestoneAmounts");
insert Expression(6845, 6844, "_milestoneAmounts");
insert Identifier(6846, 6845, "_milestoneAmounts");
insert CallArgument(6847, 6841, "_escrowData");
insert Expression(6848, 6847, "_escrowData");
insert Identifier(6849, 6848, "_escrowData");
insert CallArgument(6850, 6841, "escrowParams");
insert Expression(6851, 6850, "escrowParams");
insert Identifier(6852, 6851, "escrowParams");
insert CallArgument(6853, 6841, "daoZapData.zapData");
insert Expression(6854, 6853, "daoZapData.zapData");
insert MemberExpression(6855, 6854, "daoZapData.zapData");
insert Identifier(6856, 6855, "daoZapData");
insert Identifier(6857, 6855, "zapData");
insert Comment(6858, 6702, "// Emit event for the created Safe splits DAO escrow");
insert Statement(6859, 6702, "emit SafeSplitsDaoEscrowCreated(\n            daoZapData.zapData.safe,\n            daoZapData.zapData.projectTeamSplit,\n            daoZapData.daoSplit,\n            daoZapData.zapData.escrow\n        );");
insert EmitStatement(6860, 6859, "emit SafeSplitsDaoEscrowCreated(\n            daoZapData.zapData.safe,\n            daoZapData.zapData.projectTeamSplit,\n            daoZapData.daoSplit,\n            daoZapData.zapData.escrow\n        );");
insert Expression(6861, 6860, "SafeSplitsDaoEscrowCreated");
insert Identifier(6862, 6861, "SafeSplitsDaoEscrowCreated");
insert CallArgument(6863, 6860, "daoZapData.zapData.safe");
insert Expression(6864, 6863, "daoZapData.zapData.safe");
insert MemberExpression(6865, 6864, "daoZapData.zapData.safe");
insert Expression(6866, 6865, "daoZapData.zapData");
insert MemberExpression(6867, 6866, "daoZapData.zapData");
insert Identifier(6868, 6867, "daoZapData");
insert Identifier(6869, 6867, "zapData");
insert Identifier(6870, 6865, "safe");
insert CallArgument(6871, 6860, "daoZapData.zapData.projectTeamSplit");
insert Expression(6872, 6871, "daoZapData.zapData.projectTeamSplit");
insert MemberExpression(6873, 6872, "daoZapData.zapData.projectTeamSplit");
insert Expression(6874, 6873, "daoZapData.zapData");
insert MemberExpression(6875, 6874, "daoZapData.zapData");
insert Identifier(6876, 6875, "daoZapData");
insert Identifier(6877, 6875, "zapData");
insert Identifier(6878, 6873, "projectTeamSplit");
insert CallArgument(6879, 6860, "daoZapData.daoSplit");
insert Expression(6880, 6879, "daoZapData.daoSplit");
insert MemberExpression(6881, 6880, "daoZapData.daoSplit");
insert Identifier(6882, 6881, "daoZapData");
insert Identifier(6883, 6881, "daoSplit");
insert CallArgument(6884, 6860, "daoZapData.zapData.escrow");
insert Expression(6885, 6884, "daoZapData.zapData.escrow");
insert MemberExpression(6886, 6885, "daoZapData.zapData.escrow");
insert Expression(6887, 6886, "daoZapData.zapData");
insert MemberExpression(6888, 6887, "daoZapData.zapData");
insert Identifier(6889, 6888, "daoZapData");
insert Identifier(6890, 6888, "zapData");
insert Identifier(6891, 6886, "escrow");
insert Comment(6892, 6062, "/**\n     * @notice Deploys a new Safe, Project Team Split, DAO Split, and Escrow with the provided details.\n     * @param _owners The Safe owners and raid party split participants.\n     * @param _percentAllocations The percent allocations for the raid party split.\n     * @param _milestoneAmounts The milestone amounts for the escrow.\n     * @param _safeData The encoded data for Safe setup.\n     * @param _safeAddress The address of an existing Safe.\n     * @param _splitsData The encoded data for Split setup.\n     * @param _escrowData The encoded data for escrow deployment.\n     */");
insert FunctionDefinition(6893, 6062, "function createSafeSplitEscrow(\n        address[] memory _owners,\n        uint32[] memory _percentAllocations,\n        uint256[] memory _milestoneAmounts,\n        bytes calldata _safeData,\n        address _safeAddress,\n        bytes calldata _splitsData,\n        bytes calldata _escrowData\n    ) public override {\n        if (_percentAllocations.length != _owners.length)\n            revert InvalidAllocationsOwnersData();\n        _createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitsData,\n            _escrowData\n        );\n    }");
insert Identifier(6894, 6893, "createSafeSplitEscrow");
insert Parameter(6895, 6893, "address[] memory _owners");
insert TypeName(6896, 6895, "address[]");
insert TypeName(6897, 6896, "address");
insert PrimitiveType(6898, 6897, "address");
insert Identifier(6899, 6895, "_owners");
insert Parameter(6900, 6893, "uint32[] memory _percentAllocations");
insert TypeName(6901, 6900, "uint32[]");
insert TypeName(6902, 6901, "uint32");
insert PrimitiveType(6903, 6902, "uint32");
insert Identifier(6904, 6900, "_percentAllocations");
insert Parameter(6905, 6893, "uint256[] memory _milestoneAmounts");
insert TypeName(6906, 6905, "uint256[]");
insert TypeName(6907, 6906, "uint256");
insert PrimitiveType(6908, 6907, "uint256");
insert Identifier(6909, 6905, "_milestoneAmounts");
insert Parameter(6910, 6893, "bytes calldata _safeData");
insert TypeName(6911, 6910, "bytes");
insert PrimitiveType(6912, 6911, "bytes");
insert Identifier(6913, 6910, "_safeData");
insert Parameter(6914, 6893, "address _safeAddress");
insert TypeName(6915, 6914, "address");
insert PrimitiveType(6916, 6915, "address");
insert Identifier(6917, 6914, "_safeAddress");
insert Parameter(6918, 6893, "bytes calldata _splitsData");
insert TypeName(6919, 6918, "bytes");
insert PrimitiveType(6920, 6919, "bytes");
insert Identifier(6921, 6918, "_splitsData");
insert Parameter(6922, 6893, "bytes calldata _escrowData");
insert TypeName(6923, 6922, "bytes");
insert PrimitiveType(6924, 6923, "bytes");
insert Identifier(6925, 6922, "_escrowData");
insert Visibility(6926, 6893, "public");
insert OverrideSpecifier(6927, 6893, "override");
insert FunctionBody(6928, 6893, "{\n        if (_percentAllocations.length != _owners.length)\n            revert InvalidAllocationsOwnersData();\n        _createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitsData,\n            _escrowData\n        );\n    }");
insert Statement(6929, 6928, "if (_percentAllocations.length != _owners.length)\n            revert InvalidAllocationsOwnersData();");
insert IfStatement(6930, 6929, "if (_percentAllocations.length != _owners.length)\n            revert InvalidAllocationsOwnersData();");
insert Expression(6931, 6930, "_percentAllocations.length != _owners.length");
insert BinaryExpression(6932, 6931, "_percentAllocations.length != _owners.length");
insert Expression(6933, 6932, "_percentAllocations.length");
insert MemberExpression(6934, 6933, "_percentAllocations.length");
insert Identifier(6935, 6934, "_percentAllocations");
insert Identifier(6936, 6934, "length");
insert Expression(6937, 6932, "_owners.length");
insert MemberExpression(6938, 6937, "_owners.length");
insert Identifier(6939, 6938, "_owners");
insert Identifier(6940, 6938, "length");
insert Statement(6941, 6930, "revert InvalidAllocationsOwnersData();");
insert RevertStatement(6942, 6941, "revert InvalidAllocationsOwnersData();");
insert Expression(6943, 6942, "InvalidAllocationsOwnersData");
insert Identifier(6944, 6943, "InvalidAllocationsOwnersData");
insert RevertArguments(6945, 6942, "()");
insert Statement(6946, 6928, "_createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitsData,\n            _escrowData\n        );");
insert ExpressionStatement(6947, 6946, "_createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitsData,\n            _escrowData\n        );");
insert Expression(6948, 6947, "_createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitsData,\n            _escrowData\n        )");
insert CallExpression(6949, 6948, "_createSafeSplitEscrow(\n            _owners,\n            _percentAllocations,\n            _milestoneAmounts,\n            _safeData,\n            _safeAddress,\n            _splitsData,\n            _escrowData\n        )");
insert Expression(6950, 6949, "_createSafeSplitEscrow");
insert Identifier(6951, 6950, "_createSafeSplitEscrow");
insert CallArgument(6952, 6949, "_owners");
insert Expression(6953, 6952, "_owners");
insert Identifier(6954, 6953, "_owners");
insert CallArgument(6955, 6949, "_percentAllocations");
insert Expression(6956, 6955, "_percentAllocations");
insert Identifier(6957, 6956, "_percentAllocations");
insert CallArgument(6958, 6949, "_milestoneAmounts");
insert Expression(6959, 6958, "_milestoneAmounts");
insert Identifier(6960, 6959, "_milestoneAmounts");
insert CallArgument(6961, 6949, "_safeData");
insert Expression(6962, 6961, "_safeData");
insert Identifier(6963, 6962, "_safeData");
insert CallArgument(6964, 6949, "_safeAddress");
insert Expression(6965, 6964, "_safeAddress");
insert Identifier(6966, 6965, "_safeAddress");
insert CallArgument(6967, 6949, "_splitsData");
insert Expression(6968, 6967, "_splitsData");
insert Identifier(6969, 6968, "_splitsData");
insert CallArgument(6970, 6949, "_escrowData");
insert Expression(6971, 6970, "_escrowData");
insert Identifier(6972, 6971, "_escrowData");
insert Comment(6973, 6062, "/**\n     * @dev Internal function to handle initialization data.\n     * @param _data The initialization data.\n     */");
insert FunctionDefinition(6974, 6062, "function _handleData(bytes calldata _data) internal override {\n        (\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _spoilsManager,\n            address _escrowFactory,\n            address _wrappedNativeToken,\n            address _dao\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address\n                )\n            );\n\n        safeSingleton = _safeSingleton;\n        fallbackHandler = _fallbackHandler;\n        safeFactory = ISafeProxyFactory(_safeFactory);\n        splitMain = ISplitMain(_splitMain);\n        spoilsManager = ISpoilsManager(_spoilsManager);\n        escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n        wrappedNativeToken = IWRAPPED(_wrappedNativeToken);\n        dao = _dao;\n    }");
insert Identifier(6975, 6974, "_handleData");
insert Parameter(6976, 6974, "bytes calldata _data");
insert TypeName(6977, 6976, "bytes");
insert PrimitiveType(6978, 6977, "bytes");
insert Identifier(6979, 6976, "_data");
insert Visibility(6980, 6974, "internal");
insert OverrideSpecifier(6981, 6974, "override");
insert FunctionBody(6982, 6974, "{\n        (\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _spoilsManager,\n            address _escrowFactory,\n            address _wrappedNativeToken,\n            address _dao\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address\n                )\n            );\n\n        safeSingleton = _safeSingleton;\n        fallbackHandler = _fallbackHandler;\n        safeFactory = ISafeProxyFactory(_safeFactory);\n        splitMain = ISplitMain(_splitMain);\n        spoilsManager = ISpoilsManager(_spoilsManager);\n        escrowFactory = ISmartInvoiceFactory(_escrowFactory);\n        wrappedNativeToken = IWRAPPED(_wrappedNativeToken);\n        dao = _dao;\n    }");
insert Statement(6983, 6982, "(\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _spoilsManager,\n            address _escrowFactory,\n            address _wrappedNativeToken,\n            address _dao\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address\n                )\n            );");
insert VariableDeclarationStatement(6984, 6983, "(\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _spoilsManager,\n            address _escrowFactory,\n            address _wrappedNativeToken,\n            address _dao\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address\n                )\n            );");
insert VariableDeclarationTuple(6985, 6984, "(\n            address _safeSingleton,\n            address _fallbackHandler,\n            address _safeFactory,\n            address _splitMain,\n            address _spoilsManager,\n            address _escrowFactory,\n            address _wrappedNativeToken,\n            address _dao\n        )");
insert VariableDeclaration(6986, 6985, "address _safeSingleton");
insert TypeName(6987, 6986, "address");
insert PrimitiveType(6988, 6987, "address");
insert Identifier(6989, 6986, "_safeSingleton");
insert VariableDeclaration(6990, 6985, "address _fallbackHandler");
insert TypeName(6991, 6990, "address");
insert PrimitiveType(6992, 6991, "address");
insert Identifier(6993, 6990, "_fallbackHandler");
insert VariableDeclaration(6994, 6985, "address _safeFactory");
insert TypeName(6995, 6994, "address");
insert PrimitiveType(6996, 6995, "address");
insert Identifier(6997, 6994, "_safeFactory");
insert VariableDeclaration(6998, 6985, "address _splitMain");
insert TypeName(6999, 6998, "address");
insert PrimitiveType(7000, 6999, "address");
insert Identifier(7001, 6998, "_splitMain");
insert VariableDeclaration(7002, 6985, "address _spoilsManager");
insert TypeName(7003, 7002, "address");
insert PrimitiveType(7004, 7003, "address");
insert Identifier(7005, 7002, "_spoilsManager");
insert VariableDeclaration(7006, 6985, "address _escrowFactory");
insert TypeName(7007, 7006, "address");
insert PrimitiveType(7008, 7007, "address");
insert Identifier(7009, 7006, "_escrowFactory");
insert VariableDeclaration(7010, 6985, "address _wrappedNativeToken");
insert TypeName(7011, 7010, "address");
insert PrimitiveType(7012, 7011, "address");
insert Identifier(7013, 7010, "_wrappedNativeToken");
insert VariableDeclaration(7014, 6985, "address _dao");
insert TypeName(7015, 7014, "address");
insert PrimitiveType(7016, 7015, "address");
insert Identifier(7017, 7014, "_dao");
insert Expression(7018, 6984, "abi.decode(\n                _data,\n                (\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address\n                )\n            )");
insert CallExpression(7019, 7018, "abi.decode(\n                _data,\n                (\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address\n                )\n            )");
insert Expression(7020, 7019, "abi.decode");
insert MemberExpression(7021, 7020, "abi.decode");
insert Identifier(7022, 7021, "abi");
insert Identifier(7023, 7021, "decode");
insert CallArgument(7024, 7019, "_data");
insert Expression(7025, 7024, "_data");
insert Identifier(7026, 7025, "_data");
insert CallArgument(7027, 7019, "(\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address\n                )");
insert Expression(7028, 7027, "(\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address\n                )");
insert TupleExpression(7029, 7028, "(\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address,\n                    address\n                )");
insert Expression(7030, 7029, "address");
insert PrimitiveType(7031, 7030, "address");
insert Expression(7032, 7029, "address");
insert PrimitiveType(7033, 7032, "address");
insert Expression(7034, 7029, "address");
insert PrimitiveType(7035, 7034, "address");
insert Expression(7036, 7029, "address");
insert PrimitiveType(7037, 7036, "address");
insert Expression(7038, 7029, "address");
insert PrimitiveType(7039, 7038, "address");
insert Expression(7040, 7029, "address");
insert PrimitiveType(7041, 7040, "address");
insert Expression(7042, 7029, "address");
insert PrimitiveType(7043, 7042, "address");
insert Expression(7044, 7029, "address");
insert PrimitiveType(7045, 7044, "address");
insert Statement(7046, 6982, "safeSingleton = _safeSingleton;");
insert ExpressionStatement(7047, 7046, "safeSingleton = _safeSingleton;");
insert Expression(7048, 7047, "safeSingleton = _safeSingleton");
insert AssignmentExpression(7049, 7048, "safeSingleton = _safeSingleton");
insert Expression(7050, 7049, "safeSingleton");
insert Identifier(7051, 7050, "safeSingleton");
insert Expression(7052, 7049, "_safeSingleton");
insert Identifier(7053, 7052, "_safeSingleton");
insert Statement(7054, 6982, "fallbackHandler = _fallbackHandler;");
insert ExpressionStatement(7055, 7054, "fallbackHandler = _fallbackHandler;");
insert Expression(7056, 7055, "fallbackHandler = _fallbackHandler");
insert AssignmentExpression(7057, 7056, "fallbackHandler = _fallbackHandler");
insert Expression(7058, 7057, "fallbackHandler");
insert Identifier(7059, 7058, "fallbackHandler");
insert Expression(7060, 7057, "_fallbackHandler");
insert Identifier(7061, 7060, "_fallbackHandler");
insert Statement(7062, 6982, "safeFactory = ISafeProxyFactory(_safeFactory);");
insert ExpressionStatement(7063, 7062, "safeFactory = ISafeProxyFactory(_safeFactory);");
insert Expression(7064, 7063, "safeFactory = ISafeProxyFactory(_safeFactory)");
insert AssignmentExpression(7065, 7064, "safeFactory = ISafeProxyFactory(_safeFactory)");
insert Expression(7066, 7065, "safeFactory");
insert Identifier(7067, 7066, "safeFactory");
insert Expression(7068, 7065, "ISafeProxyFactory(_safeFactory)");
insert CallExpression(7069, 7068, "ISafeProxyFactory(_safeFactory)");
insert Expression(7070, 7069, "ISafeProxyFactory");
insert Identifier(7071, 7070, "ISafeProxyFactory");
insert CallArgument(7072, 7069, "_safeFactory");
insert Expression(7073, 7072, "_safeFactory");
insert Identifier(7074, 7073, "_safeFactory");
insert Statement(7075, 6982, "splitMain = ISplitMain(_splitMain);");
insert ExpressionStatement(7076, 7075, "splitMain = ISplitMain(_splitMain);");
insert Expression(7077, 7076, "splitMain = ISplitMain(_splitMain)");
insert AssignmentExpression(7078, 7077, "splitMain = ISplitMain(_splitMain)");
insert Expression(7079, 7078, "splitMain");
insert Identifier(7080, 7079, "splitMain");
insert Expression(7081, 7078, "ISplitMain(_splitMain)");
insert CallExpression(7082, 7081, "ISplitMain(_splitMain)");
insert Expression(7083, 7082, "ISplitMain");
insert Identifier(7084, 7083, "ISplitMain");
insert CallArgument(7085, 7082, "_splitMain");
insert Expression(7086, 7085, "_splitMain");
insert Identifier(7087, 7086, "_splitMain");
insert Statement(7088, 6982, "spoilsManager = ISpoilsManager(_spoilsManager);");
insert ExpressionStatement(7089, 7088, "spoilsManager = ISpoilsManager(_spoilsManager);");
insert Expression(7090, 7089, "spoilsManager = ISpoilsManager(_spoilsManager)");
insert AssignmentExpression(7091, 7090, "spoilsManager = ISpoilsManager(_spoilsManager)");
insert Expression(7092, 7091, "spoilsManager");
insert Identifier(7093, 7092, "spoilsManager");
insert Expression(7094, 7091, "ISpoilsManager(_spoilsManager)");
insert CallExpression(7095, 7094, "ISpoilsManager(_spoilsManager)");
insert Expression(7096, 7095, "ISpoilsManager");
insert Identifier(7097, 7096, "ISpoilsManager");
insert CallArgument(7098, 7095, "_spoilsManager");
insert Expression(7099, 7098, "_spoilsManager");
insert Identifier(7100, 7099, "_spoilsManager");
insert Statement(7101, 6982, "escrowFactory = ISmartInvoiceFactory(_escrowFactory);");
insert ExpressionStatement(7102, 7101, "escrowFactory = ISmartInvoiceFactory(_escrowFactory);");
insert Expression(7103, 7102, "escrowFactory = ISmartInvoiceFactory(_escrowFactory)");
insert AssignmentExpression(7104, 7103, "escrowFactory = ISmartInvoiceFactory(_escrowFactory)");
insert Expression(7105, 7104, "escrowFactory");
insert Identifier(7106, 7105, "escrowFactory");
insert Expression(7107, 7104, "ISmartInvoiceFactory(_escrowFactory)");
insert CallExpression(7108, 7107, "ISmartInvoiceFactory(_escrowFactory)");
insert Expression(7109, 7108, "ISmartInvoiceFactory");
insert Identifier(7110, 7109, "ISmartInvoiceFactory");
insert CallArgument(7111, 7108, "_escrowFactory");
insert Expression(7112, 7111, "_escrowFactory");
insert Identifier(7113, 7112, "_escrowFactory");
insert Statement(7114, 6982, "wrappedNativeToken = IWRAPPED(_wrappedNativeToken);");
insert ExpressionStatement(7115, 7114, "wrappedNativeToken = IWRAPPED(_wrappedNativeToken);");
insert Expression(7116, 7115, "wrappedNativeToken = IWRAPPED(_wrappedNativeToken)");
insert AssignmentExpression(7117, 7116, "wrappedNativeToken = IWRAPPED(_wrappedNativeToken)");
insert Expression(7118, 7117, "wrappedNativeToken");
insert Identifier(7119, 7118, "wrappedNativeToken");
insert Expression(7120, 7117, "IWRAPPED(_wrappedNativeToken)");
insert CallExpression(7121, 7120, "IWRAPPED(_wrappedNativeToken)");
insert Expression(7122, 7121, "IWRAPPED");
insert Identifier(7123, 7122, "IWRAPPED");
insert CallArgument(7124, 7121, "_wrappedNativeToken");
insert Expression(7125, 7124, "_wrappedNativeToken");
insert Identifier(7126, 7125, "_wrappedNativeToken");
insert Statement(7127, 6982, "dao = _dao;");
insert ExpressionStatement(7128, 7127, "dao = _dao;");
insert Expression(7129, 7128, "dao = _dao");
insert AssignmentExpression(7130, 7129, "dao = _dao");
insert Expression(7131, 7130, "dao");
insert Identifier(7132, 7131, "dao");
insert Expression(7133, 7130, "_dao");
insert Identifier(7134, 7133, "_dao");
insert SourceFile(7135, 0, "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {SafeSplitsEscrowZap} from \"./SafeSplitsEscrowZap.sol\";\n\n/// @title SafeSplitsEscrowZapFactory\n/// @notice Factory contract for creating SafeSplitsEscrowZap instances using the Clones library.\ncontract SafeSplitsEscrowZapFactory {\n    /// @notice The address of the SafeSplitsEscrowZap implementation used for creating clones.\n    address public implementation;\n\n    /// @notice Emitted when a new SafeSplitsEscrowZap is created.\n    /// @param safeSplitsEscrowZap The address of the newly created SafeSplitsEscrowZap instance.\n    /// @param implementation The address of the implementation contract used for creating the clone.\n    /// @param salt The salt used to create the deterministic address of the clone.\n    event SafeSplitsEscrowZapCreated(\n        address indexed safeSplitsEscrowZap,\n        address indexed implementation,\n        bytes32 indexed salt\n    );\n\n    /// @notice Constructor to initialize the factory with the address of the SafeSplitsEscrowZap implementation.\n    /// @param _implementation The address of the SafeSplitsEscrowZap implementation.\n    constructor(address _implementation) {\n        implementation = _implementation;\n    }\n\n    /**\n     * @notice Creates a new SafeSplitsEscrowZap instance using a deterministic address.\n     * @param _data Initialization data to be passed to the new SafeSplitsEscrowZap instance.\n     * @param _salt Salt used to create the deterministic address of the clone.\n     * @return safeSplitsEscrowZap The address of the newly created SafeSplitsEscrowZap instance.\n     */\n    function createSafeSplitsEscrowZap(\n        bytes calldata _data,\n        bytes32 _salt\n    ) external returns (address safeSplitsEscrowZap) {\n        safeSplitsEscrowZap = Clones.cloneDeterministic(implementation, _salt);\n        SafeSplitsEscrowZap(safeSplitsEscrowZap).init(_data);\n\n        emit SafeSplitsEscrowZapCreated(\n            safeSplitsEscrowZap,\n            implementation,\n            _salt\n        );\n\n        return safeSplitsEscrowZap;\n    }\n}\n");
insert Comment(7136, 7135, "// SPDX-License-Identifier: MIT");
insert PragmaDirective(7137, 7135, "pragma solidity ^0.8.20;");
insert SolidityPragmaToken(7138, 7137, "solidity ^0.8.20");
insert SolidityVersionComparisonOperator(7139, 7138, " ^");
insert SolidityVersion(7140, 7138, "0.8.20");
insert ImportDirective(7141, 7135, "import {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";");
insert Identifier(7142, 7141, "Clones");
insert ImportDirective(7143, 7135, "import {SafeSplitsEscrowZap} from \"./SafeSplitsEscrowZap.sol\";");
insert Identifier(7144, 7143, "SafeSplitsEscrowZap");
insert Comment(7145, 7135, "/// @title SafeSplitsEscrowZapFactory");
insert Comment(7146, 7135, "/// @notice Factory contract for creating SafeSplitsEscrowZap instances using the Clones library.");
insert ContractDeclaration(7147, 7135, "contract SafeSplitsEscrowZapFactory {\n    /// @notice The address of the SafeSplitsEscrowZap implementation used for creating clones.\n    address public implementation;\n\n    /// @notice Emitted when a new SafeSplitsEscrowZap is created.\n    /// @param safeSplitsEscrowZap The address of the newly created SafeSplitsEscrowZap instance.\n    /// @param implementation The address of the implementation contract used for creating the clone.\n    /// @param salt The salt used to create the deterministic address of the clone.\n    event SafeSplitsEscrowZapCreated(\n        address indexed safeSplitsEscrowZap,\n        address indexed implementation,\n        bytes32 indexed salt\n    );\n\n    /// @notice Constructor to initialize the factory with the address of the SafeSplitsEscrowZap implementation.\n    /// @param _implementation The address of the SafeSplitsEscrowZap implementation.\n    constructor(address _implementation) {\n        implementation = _implementation;\n    }\n\n    /**\n     * @notice Creates a new SafeSplitsEscrowZap instance using a deterministic address.\n     * @param _data Initialization data to be passed to the new SafeSplitsEscrowZap instance.\n     * @param _salt Salt used to create the deterministic address of the clone.\n     * @return safeSplitsEscrowZap The address of the newly created SafeSplitsEscrowZap instance.\n     */\n    function createSafeSplitsEscrowZap(\n        bytes calldata _data,\n        bytes32 _salt\n    ) external returns (address safeSplitsEscrowZap) {\n        safeSplitsEscrowZap = Clones.cloneDeterministic(implementation, _salt);\n        SafeSplitsEscrowZap(safeSplitsEscrowZap).init(_data);\n\n        emit SafeSplitsEscrowZapCreated(\n            safeSplitsEscrowZap,\n            implementation,\n            _salt\n        );\n\n        return safeSplitsEscrowZap;\n    }\n}");
insert Identifier(7148, 7147, "SafeSplitsEscrowZapFactory");
insert ContractBody(7149, 7147, "{\n    /// @notice The address of the SafeSplitsEscrowZap implementation used for creating clones.\n    address public implementation;\n\n    /// @notice Emitted when a new SafeSplitsEscrowZap is created.\n    /// @param safeSplitsEscrowZap The address of the newly created SafeSplitsEscrowZap instance.\n    /// @param implementation The address of the implementation contract used for creating the clone.\n    /// @param salt The salt used to create the deterministic address of the clone.\n    event SafeSplitsEscrowZapCreated(\n        address indexed safeSplitsEscrowZap,\n        address indexed implementation,\n        bytes32 indexed salt\n    );\n\n    /// @notice Constructor to initialize the factory with the address of the SafeSplitsEscrowZap implementation.\n    /// @param _implementation The address of the SafeSplitsEscrowZap implementation.\n    constructor(address _implementation) {\n        implementation = _implementation;\n    }\n\n    /**\n     * @notice Creates a new SafeSplitsEscrowZap instance using a deterministic address.\n     * @param _data Initialization data to be passed to the new SafeSplitsEscrowZap instance.\n     * @param _salt Salt used to create the deterministic address of the clone.\n     * @return safeSplitsEscrowZap The address of the newly created SafeSplitsEscrowZap instance.\n     */\n    function createSafeSplitsEscrowZap(\n        bytes calldata _data,\n        bytes32 _salt\n    ) external returns (address safeSplitsEscrowZap) {\n        safeSplitsEscrowZap = Clones.cloneDeterministic(implementation, _salt);\n        SafeSplitsEscrowZap(safeSplitsEscrowZap).init(_data);\n\n        emit SafeSplitsEscrowZapCreated(\n            safeSplitsEscrowZap,\n            implementation,\n            _salt\n        );\n\n        return safeSplitsEscrowZap;\n    }\n}");
insert Comment(7150, 7149, "/// @notice The address of the SafeSplitsEscrowZap implementation used for creating clones.");
insert StateVariableDeclaration(7151, 7149, "address public implementation;");
insert TypeName(7152, 7151, "address");
insert PrimitiveType(7153, 7152, "address");
insert Visibility(7154, 7151, "public");
insert Identifier(7155, 7151, "implementation");
insert Comment(7156, 7149, "/// @notice Emitted when a new SafeSplitsEscrowZap is created.");
insert Comment(7157, 7149, "/// @param safeSplitsEscrowZap The address of the newly created SafeSplitsEscrowZap instance.");
insert Comment(7158, 7149, "/// @param implementation The address of the implementation contract used for creating the clone.");
insert Comment(7159, 7149, "/// @param salt The salt used to create the deterministic address of the clone.");
insert EventDefinition(7160, 7149, "event SafeSplitsEscrowZapCreated(\n        address indexed safeSplitsEscrowZap,\n        address indexed implementation,\n        bytes32 indexed salt\n    );");
insert Identifier(7161, 7160, "SafeSplitsEscrowZapCreated");
insert EventParameter(7162, 7160, "address indexed safeSplitsEscrowZap");
insert TypeName(7163, 7162, "address");
insert PrimitiveType(7164, 7163, "address");
insert Identifier(7165, 7162, "safeSplitsEscrowZap");
insert EventParameter(7166, 7160, "address indexed implementation");
insert TypeName(7167, 7166, "address");
insert PrimitiveType(7168, 7167, "address");
insert Identifier(7169, 7166, "implementation");
insert EventParameter(7170, 7160, "bytes32 indexed salt");
insert TypeName(7171, 7170, "bytes32");
insert PrimitiveType(7172, 7171, "bytes32");
insert Identifier(7173, 7170, "salt");
insert Comment(7174, 7149, "/// @notice Constructor to initialize the factory with the address of the SafeSplitsEscrowZap implementation.");
insert Comment(7175, 7149, "/// @param _implementation The address of the SafeSplitsEscrowZap implementation.");
insert ConstructorDefinition(7176, 7149, "constructor(address _implementation) {\n        implementation = _implementation;\n    }");
insert Parameter(7177, 7176, "address _implementation");
insert TypeName(7178, 7177, "address");
insert PrimitiveType(7179, 7178, "address");
insert Identifier(7180, 7177, "_implementation");
insert FunctionBody(7181, 7176, "{\n        implementation = _implementation;\n    }");
insert Statement(7182, 7181, "implementation = _implementation;");
insert ExpressionStatement(7183, 7182, "implementation = _implementation;");
insert Expression(7184, 7183, "implementation = _implementation");
insert AssignmentExpression(7185, 7184, "implementation = _implementation");
insert Expression(7186, 7185, "implementation");
insert Identifier(7187, 7186, "implementation");
insert Expression(7188, 7185, "_implementation");
insert Identifier(7189, 7188, "_implementation");
insert Comment(7190, 7149, "/**\n     * @notice Creates a new SafeSplitsEscrowZap instance using a deterministic address.\n     * @param _data Initialization data to be passed to the new SafeSplitsEscrowZap instance.\n     * @param _salt Salt used to create the deterministic address of the clone.\n     * @return safeSplitsEscrowZap The address of the newly created SafeSplitsEscrowZap instance.\n     */");
insert FunctionDefinition(7191, 7149, "function createSafeSplitsEscrowZap(\n        bytes calldata _data,\n        bytes32 _salt\n    ) external returns (address safeSplitsEscrowZap) {\n        safeSplitsEscrowZap = Clones.cloneDeterministic(implementation, _salt);\n        SafeSplitsEscrowZap(safeSplitsEscrowZap).init(_data);\n\n        emit SafeSplitsEscrowZapCreated(\n            safeSplitsEscrowZap,\n            implementation,\n            _salt\n        );\n\n        return safeSplitsEscrowZap;\n    }");
insert Identifier(7192, 7191, "createSafeSplitsEscrowZap");
insert Parameter(7193, 7191, "bytes calldata _data");
insert TypeName(7194, 7193, "bytes");
insert PrimitiveType(7195, 7194, "bytes");
insert Identifier(7196, 7193, "_data");
insert Parameter(7197, 7191, "bytes32 _salt");
insert TypeName(7198, 7197, "bytes32");
insert PrimitiveType(7199, 7198, "bytes32");
insert Identifier(7200, 7197, "_salt");
insert Visibility(7201, 7191, "external");
insert ReturnTypeDefinition(7202, 7191, "returns (address safeSplitsEscrowZap)");
insert Parameter(7203, 7202, "address safeSplitsEscrowZap");
insert TypeName(7204, 7203, "address");
insert PrimitiveType(7205, 7204, "address");
insert Identifier(7206, 7203, "safeSplitsEscrowZap");
insert FunctionBody(7207, 7191, "{\n        safeSplitsEscrowZap = Clones.cloneDeterministic(implementation, _salt);\n        SafeSplitsEscrowZap(safeSplitsEscrowZap).init(_data);\n\n        emit SafeSplitsEscrowZapCreated(\n            safeSplitsEscrowZap,\n            implementation,\n            _salt\n        );\n\n        return safeSplitsEscrowZap;\n    }");
insert Statement(7208, 7207, "safeSplitsEscrowZap = Clones.cloneDeterministic(implementation, _salt);");
insert ExpressionStatement(7209, 7208, "safeSplitsEscrowZap = Clones.cloneDeterministic(implementation, _salt);");
insert Expression(7210, 7209, "safeSplitsEscrowZap = Clones.cloneDeterministic(implementation, _salt)");
insert AssignmentExpression(7211, 7210, "safeSplitsEscrowZap = Clones.cloneDeterministic(implementation, _salt)");
insert Expression(7212, 7211, "safeSplitsEscrowZap");
insert Identifier(7213, 7212, "safeSplitsEscrowZap");
insert Expression(7214, 7211, "Clones.cloneDeterministic(implementation, _salt)");
insert CallExpression(7215, 7214, "Clones.cloneDeterministic(implementation, _salt)");
insert Expression(7216, 7215, "Clones.cloneDeterministic");
insert MemberExpression(7217, 7216, "Clones.cloneDeterministic");
insert Identifier(7218, 7217, "Clones");
insert Identifier(7219, 7217, "cloneDeterministic");
insert CallArgument(7220, 7215, "implementation");
insert Expression(7221, 7220, "implementation");
insert Identifier(7222, 7221, "implementation");
insert CallArgument(7223, 7215, "_salt");
insert Expression(7224, 7223, "_salt");
insert Identifier(7225, 7224, "_salt");
insert Statement(7226, 7207, "SafeSplitsEscrowZap(safeSplitsEscrowZap).init(_data);");
insert ExpressionStatement(7227, 7226, "SafeSplitsEscrowZap(safeSplitsEscrowZap).init(_data);");
insert Expression(7228, 7227, "SafeSplitsEscrowZap(safeSplitsEscrowZap).init(_data)");
insert CallExpression(7229, 7228, "SafeSplitsEscrowZap(safeSplitsEscrowZap).init(_data)");
insert Expression(7230, 7229, "SafeSplitsEscrowZap(safeSplitsEscrowZap).init");
insert MemberExpression(7231, 7230, "SafeSplitsEscrowZap(safeSplitsEscrowZap).init");
insert Expression(7232, 7231, "SafeSplitsEscrowZap(safeSplitsEscrowZap)");
insert CallExpression(7233, 7232, "SafeSplitsEscrowZap(safeSplitsEscrowZap)");
insert Expression(7234, 7233, "SafeSplitsEscrowZap");
insert Identifier(7235, 7234, "SafeSplitsEscrowZap");
insert CallArgument(7236, 7233, "safeSplitsEscrowZap");
insert Expression(7237, 7236, "safeSplitsEscrowZap");
insert Identifier(7238, 7237, "safeSplitsEscrowZap");
insert Identifier(7239, 7231, "init");
insert CallArgument(7240, 7229, "_data");
insert Expression(7241, 7240, "_data");
insert Identifier(7242, 7241, "_data");
insert Statement(7243, 7207, "emit SafeSplitsEscrowZapCreated(\n            safeSplitsEscrowZap,\n            implementation,\n            _salt\n        );");
insert EmitStatement(7244, 7243, "emit SafeSplitsEscrowZapCreated(\n            safeSplitsEscrowZap,\n            implementation,\n            _salt\n        );");
insert Expression(7245, 7244, "SafeSplitsEscrowZapCreated");
insert Identifier(7246, 7245, "SafeSplitsEscrowZapCreated");
insert CallArgument(7247, 7244, "safeSplitsEscrowZap");
insert Expression(7248, 7247, "safeSplitsEscrowZap");
insert Identifier(7249, 7248, "safeSplitsEscrowZap");
insert CallArgument(7250, 7244, "implementation");
insert Expression(7251, 7250, "implementation");
insert Identifier(7252, 7251, "implementation");
insert CallArgument(7253, 7244, "_salt");
insert Expression(7254, 7253, "_salt");
insert Identifier(7255, 7254, "_salt");
insert Statement(7256, 7207, "return safeSplitsEscrowZap;");
insert ReturnStatement(7257, 7256, "return safeSplitsEscrowZap;");
insert Expression(7258, 7257, "safeSplitsEscrowZap");
insert Identifier(7259, 7258, "safeSplitsEscrowZap");
insert SourceFile(7260, 0, "// SPDX-License-Identifier: MIT\n// solhint-disable not-rely-on-time, max-states-count\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {ISmartInvoiceEscrow} from \"./interfaces/ISmartInvoiceEscrow.sol\";\nimport {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";\nimport {IArbitrable} from \"./interfaces/IArbitrable.sol\";\nimport {IArbitrator} from \"./interfaces/IArbitrator.sol\";\nimport {IWRAPPED} from \"./interfaces/IWRAPPED.sol\";\n\n/// @title SmartInvoiceEscrow\n/// @notice A contract that acts as a digital escrow for split payments with embedded arbitration, designed for use in guild or collaborative work settings.\ncontract SmartInvoiceEscrow is\n    ISmartInvoiceEscrow,\n    IArbitrable,\n    Initializable,\n    Context,\n    ReentrancyGuard\n{\n    using SafeERC20 for IERC20;\n\n    enum ADR {\n        INDIVIDUAL,\n        ARBITRATOR\n    }\n\n    uint256 public constant NUM_RULING_OPTIONS = 5; // excludes options 0, 1 and 2\n\n    uint8[2][6] public RULINGS = [\n        [1, 1], // 0 = refused to arbitrate\n        [1, 0], // 1 = 100% to client\n        [3, 1], // 2 = 75% to client\n        [1, 1], // 3 = 50% to client\n        [1, 3], // 4 = 25% to client\n        [0, 1] // 5 = 0% to client\n    ];\n\n    uint256 public constant MAX_TERMINATION_TIME = 63113904; // 2-year limit on locker\n\n    address public wrappedNativeToken;\n\n    address public client;\n    address public provider;\n    ADR public resolverType;\n    address public resolver;\n    address public token;\n    uint256 public terminationTime;\n    uint256 public resolutionRate;\n    bytes32 public details;\n\n    uint256[] public amounts; // milestones split into amounts\n    uint256 public total = 0;\n    bool public locked;\n    uint256 public milestone = 0; // current milestone - starts from 0 to amounts.length\n    uint256 public released = 0;\n    uint256 public disputeId;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes the contract with the provided provider, amounts, and data.\n     * @param _provider The address of the provider\n     * @param _amounts The array of amounts associated with the provider\n     * @param _data The additional data needed for initialization\n     */\n    function init(\n        address _provider,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external virtual override initializer {\n        if (_provider == address(0)) revert InvalidProvider();\n\n        _handleData(_data);\n\n        provider = _provider;\n        amounts = _amounts;\n        uint256 _total = 0;\n        for (uint256 i = 0; i < amounts.length; i++) {\n            _total += amounts[i];\n        }\n        total = _total;\n    }\n\n    /**\n     * @dev Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded\n     */\n    function _handleData(bytes calldata _data) internal virtual {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address\n                )\n            );\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }\n\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_resolutionRate == 0) revert InvalidResolutionRate();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }\n\n    /**\n     * @dev Verifies the client and contract are paired\n     */\n    function verify() external override {\n        if (msg.sender != client) revert NotClient();\n        emit Verified(client, address(this));\n    }\n\n    /**\n     * @dev Adds milestones without extra details.\n     * @param _milestones The array of new milestones to be added\n     */\n    function addMilestones(uint256[] calldata _milestones) external override {\n        _addMilestones(_milestones, bytes32(0));\n    }\n\n    /**\n     * @dev Adds milestones with extra details.\n     * @param _milestones The array of new milestones to be added\n     * @param _details Additional details for the milestones\n     */\n    function addMilestones(\n        uint256[] calldata _milestones,\n        bytes32 _details\n    ) external override {\n        _addMilestones(_milestones, _details);\n    }\n\n    /**\n     * @dev Internal function to add milestones and update the contract state.\n     * @param _milestones The array of new milestones to be added\n     * @param _details Additional details for the milestones\n     */\n    function _addMilestones(\n        uint256[] calldata _milestones,\n        bytes32 _details\n    ) internal {\n        if (locked) revert Locked();\n        if (block.timestamp >= terminationTime) revert Terminated();\n        if (_msgSender() != client && _msgSender() != provider)\n            revert NotParty();\n        if (_milestones.length == 0) revert NoMilestones();\n        if (_milestones.length > 10) revert ExceedsMilestoneLimit();\n\n        uint256 newLength = amounts.length + _milestones.length;\n        uint256[] memory baseArray = new uint256[](newLength);\n        uint256 newTotal = total;\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            baseArray[i] = amounts[i];\n        }\n        for (uint256 i = amounts.length; i < newLength; i++) {\n            baseArray[i] = _milestones[i - amounts.length];\n            newTotal += _milestones[i - amounts.length];\n        }\n\n        total = newTotal;\n        amounts = baseArray;\n\n        if (_details != bytes32(0)) {\n            details = _details;\n            emit DetailsUpdated(msg.sender, _details);\n        }\n\n        emit MilestonesAdded(msg.sender, address(this), _milestones);\n    }\n\n    /**\n     * @dev Returns the amounts associated with the milestones.\n     * @return An array of amounts for each milestone\n     */\n    function getAmounts() public view returns (uint256[] memory) {\n        return amounts;\n    }\n\n    /**\n     * @dev Internal function to release funds from the contract to the provider.\n     */\n    function _release() internal virtual {\n        if (locked) revert Locked();\n        if (_msgSender() != client) revert NotClient();\n\n        uint256 currentMilestone = milestone;\n        uint256 balance = IERC20(token).balanceOf(address(this));\n\n        if (currentMilestone < amounts.length) {\n            uint256 amount = amounts[currentMilestone];\n            if (currentMilestone == amounts.length - 1 && amount < balance) {\n                amount = balance;\n            }\n            if (balance < amount) revert InsufficientBalance();\n\n            milestone = milestone + 1;\n            _transferPayment(token, amount);\n            released = released + amount;\n            emit Release(currentMilestone, amount);\n        } else {\n            if (balance == 0) revert BalanceIsZero();\n\n            _transferPayment(token, balance);\n            released = released + balance;\n            emit Release(currentMilestone, balance);\n        }\n    }\n\n    /**\n     * @dev External function to release funds from the contract to the provider.\n     * Uses the internal `_release` function to perform the actual release.\n     */\n    function release() external virtual override nonReentrant {\n        return _release();\n    }\n\n    /**\n     * @dev External function to release funds from the contract to the provider up to a certain milestone.\n     * @param _milestone The milestone to release funds to\n     */\n    function release(\n        uint256 _milestone\n    ) external virtual override nonReentrant {\n        if (locked) revert Locked();\n        if (_msgSender() != client) revert NotClient();\n        if (_milestone < milestone) revert InvalidMilestone();\n        if (_milestone >= amounts.length) revert InvalidMilestone();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        uint256 amount = 0;\n        for (uint256 j = milestone; j <= _milestone; j++) {\n            if (j == amounts.length - 1 && amount + amounts[j] < balance) {\n                emit Release(j, balance - amount);\n                amount = balance;\n            } else {\n                emit Release(j, amounts[j]);\n                amount = amount + amounts[j];\n            }\n        }\n        if (balance < amount) revert InsufficientBalance();\n\n        _transferPayment(token, amount);\n        released = released + amount;\n        milestone = _milestone + 1;\n    }\n\n    /**\n     * @dev External function to release tokens from the contract to the provider.\n     * Uses the internal `_release` function to perform the actual release.\n     * @param _token The token to release funds from\n     */\n    function releaseTokens(\n        address _token\n    ) external virtual override nonReentrant {\n        if (_token == token) {\n            _release();\n        } else {\n            if (_msgSender() != client) revert NotClient();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            _transferPayment(_token, balance);\n        }\n    }\n\n    /**\n     * @dev Internal function to withdraw funds from the contract to the client.\n     */\n    function _withdraw() internal {\n        if (locked) revert Locked();\n        if (block.timestamp <= terminationTime) revert Terminated();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n\n        _withdrawDeposit(token, balance);\n        milestone = amounts.length;\n\n        emit Withdraw(balance);\n    }\n\n    /**\n     * @dev External function to withdraw funds from the contract to the client.\n     * Uses the internal `_withdraw` function to perform the actual withdrawal.\n     */\n    function withdraw() external override nonReentrant {\n        return _withdraw();\n    }\n\n    /**\n     * @dev External function to withdraw tokens from the contract to the client.\n     * Uses the internal `_withdraw` function to perform the actual withdrawal.\n     * @param _token The token to withdraw\n     */\n    function withdrawTokens(address _token) external override nonReentrant {\n        if (_token == token) {\n            _withdraw();\n        } else {\n            if (block.timestamp <= terminationTime) revert Terminated();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n\n            _withdrawDeposit(_token, balance);\n        }\n    }\n\n    /**\n     * @dev External function to lock the contract.\n     * @param _details Details of the dispute\n     */\n    function lock(bytes32 _details) external payable override nonReentrant {\n        if (locked) revert Locked();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n        if (block.timestamp >= terminationTime) revert Terminated();\n        if (_msgSender() != client && _msgSender() != provider)\n            revert NotParty();\n\n        if (resolverType == ADR.ARBITRATOR) {\n            disputeId = IArbitrator(resolver).createDispute{value: msg.value}(\n                NUM_RULING_OPTIONS,\n                abi.encodePacked(details)\n            );\n        }\n        locked = true;\n\n        emit Lock(_msgSender(), _details);\n    }\n\n    /**\n     * @dev External function to resolve the contract.\n     * @param _clientAward The amount to award the client\n     * @param _providerAward The amount to award the provider\n     * @param _details Details of the dispute\n     */\n    function resolve(\n        uint256 _clientAward,\n        uint256 _providerAward,\n        bytes32 _details\n    ) external virtual override nonReentrant {\n        if (resolverType != ADR.INDIVIDUAL) revert InvalidIndividualResolver();\n        if (!locked) revert Locked();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n        if (_msgSender() != resolver) revert NotResolver();\n\n        uint256 resolutionFee = balance / resolutionRate;\n\n        if (_clientAward + _providerAward != balance - resolutionFee)\n            revert ResolutionMismatch();\n\n        if (_providerAward > 0) {\n            _transferPayment(token, _providerAward);\n        }\n        if (_clientAward > 0) {\n            _withdrawDeposit(token, _clientAward);\n        }\n        if (resolutionFee > 0) {\n            IERC20(token).safeTransfer(resolver, resolutionFee);\n        }\n\n        milestone = amounts.length;\n        locked = false;\n\n        emit Resolve(\n            _msgSender(),\n            _clientAward,\n            _providerAward,\n            resolutionFee,\n            _details\n        );\n    }\n\n    /**\n     * @dev External function to rule on a dispute.\n     * @param _disputeId The ID of the dispute\n     * @param _ruling The ruling of the arbitrator\n     */\n    function rule(\n        uint256 _disputeId,\n        uint256 _ruling\n    ) external virtual override nonReentrant {\n        if (resolverType != ADR.ARBITRATOR) revert InvalidArbitratorResolver();\n        if (!locked) revert Locked();\n        if (_msgSender() != resolver) revert NotResolver();\n        if (_disputeId != disputeId) revert IncorrectDisputeId();\n        if (_ruling > NUM_RULING_OPTIONS) revert InvalidRuling();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n\n        uint8[2] memory ruling = _getRuling(_ruling);\n        uint8 clientShare = ruling[0];\n        uint8 providerShare = ruling[1];\n        uint8 denom = clientShare + providerShare;\n        uint256 providerAward = (balance * providerShare) / denom;\n        uint256 clientAward = balance - providerAward;\n\n        if (providerAward > 0) {\n            _transferPayment(token, providerAward);\n        }\n        if (clientAward > 0) {\n            _withdrawDeposit(token, clientAward);\n        }\n\n        milestone = amounts.length;\n        locked = false;\n\n        emit Rule(resolver, clientAward, providerAward, _ruling);\n        emit Ruling(resolver, _disputeId, _ruling);\n    }\n\n    /**\n     * @dev Internal function to get the ruling of the arbitrator.\n     * @param _ruling The ruling of the arbitrator\n     */\n    function _getRuling(\n        uint256 _ruling\n    ) internal pure returns (uint8[2] memory ruling) {\n        uint8[2][6] memory rulings = [\n            [1, 1], // 0 = refused to arbitrate\n            [1, 0], // 1 = 100% to client\n            [3, 1], // 2 = 75% to client\n            [1, 1], // 3 = 50% to client\n            [1, 3], // 4 = 25% to client\n            [0, 1] // 5 = 0% to client\n        ];\n        ruling = rulings[_ruling];\n    }\n\n    /**\n     * @dev Internal function to transfer payment to the provider.\n     * @param _token The token to transfer\n     * @param _amount The amount to transfer\n     */\n    function _transferPayment(\n        address _token,\n        uint256 _amount\n    ) internal virtual {\n        IERC20(_token).safeTransfer(provider, _amount);\n    }\n\n    /**\n     * @dev Internal function to withdraw deposit to the client.\n     * @param _token The token to withdraw\n     * @param _amount The amount to withdraw\n     */\n    function _withdrawDeposit(\n        address _token,\n        uint256 _amount\n    ) internal virtual {\n        IERC20(_token).safeTransfer(client, _amount);\n    }\n\n    // receive eth transfers\n    // solhint-disable-next-line no-complex-fallback\n    receive() external payable {\n        if (locked) revert Locked();\n        if (token != wrappedNativeToken) revert InvalidWrappedNativeToken();\n        IWRAPPED(wrappedNativeToken).deposit{value: msg.value}();\n        emit Deposit(_msgSender(), msg.value);\n    }\n}\n");
insert Comment(7261, 7260, "// SPDX-License-Identifier: MIT");
insert Comment(7262, 7260, "// solhint-disable not-rely-on-time, max-states-count");
insert PragmaDirective(7263, 7260, "pragma solidity ^0.8.20;");
insert SolidityPragmaToken(7264, 7263, "solidity ^0.8.20");
insert SolidityVersionComparisonOperator(7265, 7264, " ^");
insert SolidityVersion(7266, 7264, "0.8.20");
insert ImportDirective(7267, 7260, "import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";");
insert Identifier(7268, 7267, "IERC20");
insert ImportDirective(7269, 7260, "import {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";");
insert Identifier(7270, 7269, "SafeERC20");
insert ImportDirective(7271, 7260, "import {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";");
insert Identifier(7272, 7271, "ReentrancyGuard");
insert ImportDirective(7273, 7260, "import {Context} from \"@openzeppelin/contracts/utils/Context.sol\";");
insert Identifier(7274, 7273, "Context");
insert ImportDirective(7275, 7260, "import {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";");
insert Identifier(7276, 7275, "Initializable");
insert ImportDirective(7277, 7260, "import {ISmartInvoiceEscrow} from \"./interfaces/ISmartInvoiceEscrow.sol\";");
insert Identifier(7278, 7277, "ISmartInvoiceEscrow");
insert ImportDirective(7279, 7260, "import {ISmartInvoiceFactory} from \"./interfaces/ISmartInvoiceFactory.sol\";");
insert Identifier(7280, 7279, "ISmartInvoiceFactory");
insert ImportDirective(7281, 7260, "import {IArbitrable} from \"./interfaces/IArbitrable.sol\";");
insert Identifier(7282, 7281, "IArbitrable");
insert ImportDirective(7283, 7260, "import {IArbitrator} from \"./interfaces/IArbitrator.sol\";");
insert Identifier(7284, 7283, "IArbitrator");
insert ImportDirective(7285, 7260, "import {IWRAPPED} from \"./interfaces/IWRAPPED.sol\";");
insert Identifier(7286, 7285, "IWRAPPED");
insert Comment(7287, 7260, "/// @title SmartInvoiceEscrow");
insert Comment(7288, 7260, "/// @notice A contract that acts as a digital escrow for split payments with embedded arbitration, designed for use in guild or collaborative work settings.");
insert ContractDeclaration(7289, 7260, "contract SmartInvoiceEscrow is\n    ISmartInvoiceEscrow,\n    IArbitrable,\n    Initializable,\n    Context,\n    ReentrancyGuard\n{\n    using SafeERC20 for IERC20;\n\n    enum ADR {\n        INDIVIDUAL,\n        ARBITRATOR\n    }\n\n    uint256 public constant NUM_RULING_OPTIONS = 5; // excludes options 0, 1 and 2\n\n    uint8[2][6] public RULINGS = [\n        [1, 1], // 0 = refused to arbitrate\n        [1, 0], // 1 = 100% to client\n        [3, 1], // 2 = 75% to client\n        [1, 1], // 3 = 50% to client\n        [1, 3], // 4 = 25% to client\n        [0, 1] // 5 = 0% to client\n    ];\n\n    uint256 public constant MAX_TERMINATION_TIME = 63113904; // 2-year limit on locker\n\n    address public wrappedNativeToken;\n\n    address public client;\n    address public provider;\n    ADR public resolverType;\n    address public resolver;\n    address public token;\n    uint256 public terminationTime;\n    uint256 public resolutionRate;\n    bytes32 public details;\n\n    uint256[] public amounts; // milestones split into amounts\n    uint256 public total = 0;\n    bool public locked;\n    uint256 public milestone = 0; // current milestone - starts from 0 to amounts.length\n    uint256 public released = 0;\n    uint256 public disputeId;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes the contract with the provided provider, amounts, and data.\n     * @param _provider The address of the provider\n     * @param _amounts The array of amounts associated with the provider\n     * @param _data The additional data needed for initialization\n     */\n    function init(\n        address _provider,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external virtual override initializer {\n        if (_provider == address(0)) revert InvalidProvider();\n\n        _handleData(_data);\n\n        provider = _provider;\n        amounts = _amounts;\n        uint256 _total = 0;\n        for (uint256 i = 0; i < amounts.length; i++) {\n            _total += amounts[i];\n        }\n        total = _total;\n    }\n\n    /**\n     * @dev Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded\n     */\n    function _handleData(bytes calldata _data) internal virtual {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address\n                )\n            );\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }\n\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_resolutionRate == 0) revert InvalidResolutionRate();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }\n\n    /**\n     * @dev Verifies the client and contract are paired\n     */\n    function verify() external override {\n        if (msg.sender != client) revert NotClient();\n        emit Verified(client, address(this));\n    }\n\n    /**\n     * @dev Adds milestones without extra details.\n     * @param _milestones The array of new milestones to be added\n     */\n    function addMilestones(uint256[] calldata _milestones) external override {\n        _addMilestones(_milestones, bytes32(0));\n    }\n\n    /**\n     * @dev Adds milestones with extra details.\n     * @param _milestones The array of new milestones to be added\n     * @param _details Additional details for the milestones\n     */\n    function addMilestones(\n        uint256[] calldata _milestones,\n        bytes32 _details\n    ) external override {\n        _addMilestones(_milestones, _details);\n    }\n\n    /**\n     * @dev Internal function to add milestones and update the contract state.\n     * @param _milestones The array of new milestones to be added\n     * @param _details Additional details for the milestones\n     */\n    function _addMilestones(\n        uint256[] calldata _milestones,\n        bytes32 _details\n    ) internal {\n        if (locked) revert Locked();\n        if (block.timestamp >= terminationTime) revert Terminated();\n        if (_msgSender() != client && _msgSender() != provider)\n            revert NotParty();\n        if (_milestones.length == 0) revert NoMilestones();\n        if (_milestones.length > 10) revert ExceedsMilestoneLimit();\n\n        uint256 newLength = amounts.length + _milestones.length;\n        uint256[] memory baseArray = new uint256[](newLength);\n        uint256 newTotal = total;\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            baseArray[i] = amounts[i];\n        }\n        for (uint256 i = amounts.length; i < newLength; i++) {\n            baseArray[i] = _milestones[i - amounts.length];\n            newTotal += _milestones[i - amounts.length];\n        }\n\n        total = newTotal;\n        amounts = baseArray;\n\n        if (_details != bytes32(0)) {\n            details = _details;\n            emit DetailsUpdated(msg.sender, _details);\n        }\n\n        emit MilestonesAdded(msg.sender, address(this), _milestones);\n    }\n\n    /**\n     * @dev Returns the amounts associated with the milestones.\n     * @return An array of amounts for each milestone\n     */\n    function getAmounts() public view returns (uint256[] memory) {\n        return amounts;\n    }\n\n    /**\n     * @dev Internal function to release funds from the contract to the provider.\n     */\n    function _release() internal virtual {\n        if (locked) revert Locked();\n        if (_msgSender() != client) revert NotClient();\n\n        uint256 currentMilestone = milestone;\n        uint256 balance = IERC20(token).balanceOf(address(this));\n\n        if (currentMilestone < amounts.length) {\n            uint256 amount = amounts[currentMilestone];\n            if (currentMilestone == amounts.length - 1 && amount < balance) {\n                amount = balance;\n            }\n            if (balance < amount) revert InsufficientBalance();\n\n            milestone = milestone + 1;\n            _transferPayment(token, amount);\n            released = released + amount;\n            emit Release(currentMilestone, amount);\n        } else {\n            if (balance == 0) revert BalanceIsZero();\n\n            _transferPayment(token, balance);\n            released = released + balance;\n            emit Release(currentMilestone, balance);\n        }\n    }\n\n    /**\n     * @dev External function to release funds from the contract to the provider.\n     * Uses the internal `_release` function to perform the actual release.\n     */\n    function release() external virtual override nonReentrant {\n        return _release();\n    }\n\n    /**\n     * @dev External function to release funds from the contract to the provider up to a certain milestone.\n     * @param _milestone The milestone to release funds to\n     */\n    function release(\n        uint256 _milestone\n    ) external virtual override nonReentrant {\n        if (locked) revert Locked();\n        if (_msgSender() != client) revert NotClient();\n        if (_milestone < milestone) revert InvalidMilestone();\n        if (_milestone >= amounts.length) revert InvalidMilestone();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        uint256 amount = 0;\n        for (uint256 j = milestone; j <= _milestone; j++) {\n            if (j == amounts.length - 1 && amount + amounts[j] < balance) {\n                emit Release(j, balance - amount);\n                amount = balance;\n            } else {\n                emit Release(j, amounts[j]);\n                amount = amount + amounts[j];\n            }\n        }\n        if (balance < amount) revert InsufficientBalance();\n\n        _transferPayment(token, amount);\n        released = released + amount;\n        milestone = _milestone + 1;\n    }\n\n    /**\n     * @dev External function to release tokens from the contract to the provider.\n     * Uses the internal `_release` function to perform the actual release.\n     * @param _token The token to release funds from\n     */\n    function releaseTokens(\n        address _token\n    ) external virtual override nonReentrant {\n        if (_token == token) {\n            _release();\n        } else {\n            if (_msgSender() != client) revert NotClient();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            _transferPayment(_token, balance);\n        }\n    }\n\n    /**\n     * @dev Internal function to withdraw funds from the contract to the client.\n     */\n    function _withdraw() internal {\n        if (locked) revert Locked();\n        if (block.timestamp <= terminationTime) revert Terminated();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n\n        _withdrawDeposit(token, balance);\n        milestone = amounts.length;\n\n        emit Withdraw(balance);\n    }\n\n    /**\n     * @dev External function to withdraw funds from the contract to the client.\n     * Uses the internal `_withdraw` function to perform the actual withdrawal.\n     */\n    function withdraw() external override nonReentrant {\n        return _withdraw();\n    }\n\n    /**\n     * @dev External function to withdraw tokens from the contract to the client.\n     * Uses the internal `_withdraw` function to perform the actual withdrawal.\n     * @param _token The token to withdraw\n     */\n    function withdrawTokens(address _token) external override nonReentrant {\n        if (_token == token) {\n            _withdraw();\n        } else {\n            if (block.timestamp <= terminationTime) revert Terminated();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n\n            _withdrawDeposit(_token, balance);\n        }\n    }\n\n    /**\n     * @dev External function to lock the contract.\n     * @param _details Details of the dispute\n     */\n    function lock(bytes32 _details) external payable override nonReentrant {\n        if (locked) revert Locked();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n        if (block.timestamp >= terminationTime) revert Terminated();\n        if (_msgSender() != client && _msgSender() != provider)\n            revert NotParty();\n\n        if (resolverType == ADR.ARBITRATOR) {\n            disputeId = IArbitrator(resolver).createDispute{value: msg.value}(\n                NUM_RULING_OPTIONS,\n                abi.encodePacked(details)\n            );\n        }\n        locked = true;\n\n        emit Lock(_msgSender(), _details);\n    }\n\n    /**\n     * @dev External function to resolve the contract.\n     * @param _clientAward The amount to award the client\n     * @param _providerAward The amount to award the provider\n     * @param _details Details of the dispute\n     */\n    function resolve(\n        uint256 _clientAward,\n        uint256 _providerAward,\n        bytes32 _details\n    ) external virtual override nonReentrant {\n        if (resolverType != ADR.INDIVIDUAL) revert InvalidIndividualResolver();\n        if (!locked) revert Locked();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n        if (_msgSender() != resolver) revert NotResolver();\n\n        uint256 resolutionFee = balance / resolutionRate;\n\n        if (_clientAward + _providerAward != balance - resolutionFee)\n            revert ResolutionMismatch();\n\n        if (_providerAward > 0) {\n            _transferPayment(token, _providerAward);\n        }\n        if (_clientAward > 0) {\n            _withdrawDeposit(token, _clientAward);\n        }\n        if (resolutionFee > 0) {\n            IERC20(token).safeTransfer(resolver, resolutionFee);\n        }\n\n        milestone = amounts.length;\n        locked = false;\n\n        emit Resolve(\n            _msgSender(),\n            _clientAward,\n            _providerAward,\n            resolutionFee,\n            _details\n        );\n    }\n\n    /**\n     * @dev External function to rule on a dispute.\n     * @param _disputeId The ID of the dispute\n     * @param _ruling The ruling of the arbitrator\n     */\n    function rule(\n        uint256 _disputeId,\n        uint256 _ruling\n    ) external virtual override nonReentrant {\n        if (resolverType != ADR.ARBITRATOR) revert InvalidArbitratorResolver();\n        if (!locked) revert Locked();\n        if (_msgSender() != resolver) revert NotResolver();\n        if (_disputeId != disputeId) revert IncorrectDisputeId();\n        if (_ruling > NUM_RULING_OPTIONS) revert InvalidRuling();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n\n        uint8[2] memory ruling = _getRuling(_ruling);\n        uint8 clientShare = ruling[0];\n        uint8 providerShare = ruling[1];\n        uint8 denom = clientShare + providerShare;\n        uint256 providerAward = (balance * providerShare) / denom;\n        uint256 clientAward = balance - providerAward;\n\n        if (providerAward > 0) {\n            _transferPayment(token, providerAward);\n        }\n        if (clientAward > 0) {\n            _withdrawDeposit(token, clientAward);\n        }\n\n        milestone = amounts.length;\n        locked = false;\n\n        emit Rule(resolver, clientAward, providerAward, _ruling);\n        emit Ruling(resolver, _disputeId, _ruling);\n    }\n\n    /**\n     * @dev Internal function to get the ruling of the arbitrator.\n     * @param _ruling The ruling of the arbitrator\n     */\n    function _getRuling(\n        uint256 _ruling\n    ) internal pure returns (uint8[2] memory ruling) {\n        uint8[2][6] memory rulings = [\n            [1, 1], // 0 = refused to arbitrate\n            [1, 0], // 1 = 100% to client\n            [3, 1], // 2 = 75% to client\n            [1, 1], // 3 = 50% to client\n            [1, 3], // 4 = 25% to client\n            [0, 1] // 5 = 0% to client\n        ];\n        ruling = rulings[_ruling];\n    }\n\n    /**\n     * @dev Internal function to transfer payment to the provider.\n     * @param _token The token to transfer\n     * @param _amount The amount to transfer\n     */\n    function _transferPayment(\n        address _token,\n        uint256 _amount\n    ) internal virtual {\n        IERC20(_token).safeTransfer(provider, _amount);\n    }\n\n    /**\n     * @dev Internal function to withdraw deposit to the client.\n     * @param _token The token to withdraw\n     * @param _amount The amount to withdraw\n     */\n    function _withdrawDeposit(\n        address _token,\n        uint256 _amount\n    ) internal virtual {\n        IERC20(_token).safeTransfer(client, _amount);\n    }\n\n    // receive eth transfers\n    // solhint-disable-next-line no-complex-fallback\n    receive() external payable {\n        if (locked) revert Locked();\n        if (token != wrappedNativeToken) revert InvalidWrappedNativeToken();\n        IWRAPPED(wrappedNativeToken).deposit{value: msg.value}();\n        emit Deposit(_msgSender(), msg.value);\n    }\n}");
insert Identifier(7290, 7289, "SmartInvoiceEscrow");
insert InheritanceSpecifier(7291, 7289, "ISmartInvoiceEscrow");
insert UserDefinedType(7292, 7291, "ISmartInvoiceEscrow");
insert Identifier(7293, 7292, "ISmartInvoiceEscrow");
insert InheritanceSpecifier(7294, 7289, "IArbitrable");
insert UserDefinedType(7295, 7294, "IArbitrable");
insert Identifier(7296, 7295, "IArbitrable");
insert InheritanceSpecifier(7297, 7289, "Initializable");
insert UserDefinedType(7298, 7297, "Initializable");
insert Identifier(7299, 7298, "Initializable");
insert InheritanceSpecifier(7300, 7289, "Context");
insert UserDefinedType(7301, 7300, "Context");
insert Identifier(7302, 7301, "Context");
insert InheritanceSpecifier(7303, 7289, "ReentrancyGuard");
insert UserDefinedType(7304, 7303, "ReentrancyGuard");
insert Identifier(7305, 7304, "ReentrancyGuard");
insert ContractBody(7306, 7289, "{\n    using SafeERC20 for IERC20;\n\n    enum ADR {\n        INDIVIDUAL,\n        ARBITRATOR\n    }\n\n    uint256 public constant NUM_RULING_OPTIONS = 5; // excludes options 0, 1 and 2\n\n    uint8[2][6] public RULINGS = [\n        [1, 1], // 0 = refused to arbitrate\n        [1, 0], // 1 = 100% to client\n        [3, 1], // 2 = 75% to client\n        [1, 1], // 3 = 50% to client\n        [1, 3], // 4 = 25% to client\n        [0, 1] // 5 = 0% to client\n    ];\n\n    uint256 public constant MAX_TERMINATION_TIME = 63113904; // 2-year limit on locker\n\n    address public wrappedNativeToken;\n\n    address public client;\n    address public provider;\n    ADR public resolverType;\n    address public resolver;\n    address public token;\n    uint256 public terminationTime;\n    uint256 public resolutionRate;\n    bytes32 public details;\n\n    uint256[] public amounts; // milestones split into amounts\n    uint256 public total = 0;\n    bool public locked;\n    uint256 public milestone = 0; // current milestone - starts from 0 to amounts.length\n    uint256 public released = 0;\n    uint256 public disputeId;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes the contract with the provided provider, amounts, and data.\n     * @param _provider The address of the provider\n     * @param _amounts The array of amounts associated with the provider\n     * @param _data The additional data needed for initialization\n     */\n    function init(\n        address _provider,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external virtual override initializer {\n        if (_provider == address(0)) revert InvalidProvider();\n\n        _handleData(_data);\n\n        provider = _provider;\n        amounts = _amounts;\n        uint256 _total = 0;\n        for (uint256 i = 0; i < amounts.length; i++) {\n            _total += amounts[i];\n        }\n        total = _total;\n    }\n\n    /**\n     * @dev Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded\n     */\n    function _handleData(bytes calldata _data) internal virtual {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address\n                )\n            );\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }\n\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_resolutionRate == 0) revert InvalidResolutionRate();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }\n\n    /**\n     * @dev Verifies the client and contract are paired\n     */\n    function verify() external override {\n        if (msg.sender != client) revert NotClient();\n        emit Verified(client, address(this));\n    }\n\n    /**\n     * @dev Adds milestones without extra details.\n     * @param _milestones The array of new milestones to be added\n     */\n    function addMilestones(uint256[] calldata _milestones) external override {\n        _addMilestones(_milestones, bytes32(0));\n    }\n\n    /**\n     * @dev Adds milestones with extra details.\n     * @param _milestones The array of new milestones to be added\n     * @param _details Additional details for the milestones\n     */\n    function addMilestones(\n        uint256[] calldata _milestones,\n        bytes32 _details\n    ) external override {\n        _addMilestones(_milestones, _details);\n    }\n\n    /**\n     * @dev Internal function to add milestones and update the contract state.\n     * @param _milestones The array of new milestones to be added\n     * @param _details Additional details for the milestones\n     */\n    function _addMilestones(\n        uint256[] calldata _milestones,\n        bytes32 _details\n    ) internal {\n        if (locked) revert Locked();\n        if (block.timestamp >= terminationTime) revert Terminated();\n        if (_msgSender() != client && _msgSender() != provider)\n            revert NotParty();\n        if (_milestones.length == 0) revert NoMilestones();\n        if (_milestones.length > 10) revert ExceedsMilestoneLimit();\n\n        uint256 newLength = amounts.length + _milestones.length;\n        uint256[] memory baseArray = new uint256[](newLength);\n        uint256 newTotal = total;\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            baseArray[i] = amounts[i];\n        }\n        for (uint256 i = amounts.length; i < newLength; i++) {\n            baseArray[i] = _milestones[i - amounts.length];\n            newTotal += _milestones[i - amounts.length];\n        }\n\n        total = newTotal;\n        amounts = baseArray;\n\n        if (_details != bytes32(0)) {\n            details = _details;\n            emit DetailsUpdated(msg.sender, _details);\n        }\n\n        emit MilestonesAdded(msg.sender, address(this), _milestones);\n    }\n\n    /**\n     * @dev Returns the amounts associated with the milestones.\n     * @return An array of amounts for each milestone\n     */\n    function getAmounts() public view returns (uint256[] memory) {\n        return amounts;\n    }\n\n    /**\n     * @dev Internal function to release funds from the contract to the provider.\n     */\n    function _release() internal virtual {\n        if (locked) revert Locked();\n        if (_msgSender() != client) revert NotClient();\n\n        uint256 currentMilestone = milestone;\n        uint256 balance = IERC20(token).balanceOf(address(this));\n\n        if (currentMilestone < amounts.length) {\n            uint256 amount = amounts[currentMilestone];\n            if (currentMilestone == amounts.length - 1 && amount < balance) {\n                amount = balance;\n            }\n            if (balance < amount) revert InsufficientBalance();\n\n            milestone = milestone + 1;\n            _transferPayment(token, amount);\n            released = released + amount;\n            emit Release(currentMilestone, amount);\n        } else {\n            if (balance == 0) revert BalanceIsZero();\n\n            _transferPayment(token, balance);\n            released = released + balance;\n            emit Release(currentMilestone, balance);\n        }\n    }\n\n    /**\n     * @dev External function to release funds from the contract to the provider.\n     * Uses the internal `_release` function to perform the actual release.\n     */\n    function release() external virtual override nonReentrant {\n        return _release();\n    }\n\n    /**\n     * @dev External function to release funds from the contract to the provider up to a certain milestone.\n     * @param _milestone The milestone to release funds to\n     */\n    function release(\n        uint256 _milestone\n    ) external virtual override nonReentrant {\n        if (locked) revert Locked();\n        if (_msgSender() != client) revert NotClient();\n        if (_milestone < milestone) revert InvalidMilestone();\n        if (_milestone >= amounts.length) revert InvalidMilestone();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        uint256 amount = 0;\n        for (uint256 j = milestone; j <= _milestone; j++) {\n            if (j == amounts.length - 1 && amount + amounts[j] < balance) {\n                emit Release(j, balance - amount);\n                amount = balance;\n            } else {\n                emit Release(j, amounts[j]);\n                amount = amount + amounts[j];\n            }\n        }\n        if (balance < amount) revert InsufficientBalance();\n\n        _transferPayment(token, amount);\n        released = released + amount;\n        milestone = _milestone + 1;\n    }\n\n    /**\n     * @dev External function to release tokens from the contract to the provider.\n     * Uses the internal `_release` function to perform the actual release.\n     * @param _token The token to release funds from\n     */\n    function releaseTokens(\n        address _token\n    ) external virtual override nonReentrant {\n        if (_token == token) {\n            _release();\n        } else {\n            if (_msgSender() != client) revert NotClient();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            _transferPayment(_token, balance);\n        }\n    }\n\n    /**\n     * @dev Internal function to withdraw funds from the contract to the client.\n     */\n    function _withdraw() internal {\n        if (locked) revert Locked();\n        if (block.timestamp <= terminationTime) revert Terminated();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n\n        _withdrawDeposit(token, balance);\n        milestone = amounts.length;\n\n        emit Withdraw(balance);\n    }\n\n    /**\n     * @dev External function to withdraw funds from the contract to the client.\n     * Uses the internal `_withdraw` function to perform the actual withdrawal.\n     */\n    function withdraw() external override nonReentrant {\n        return _withdraw();\n    }\n\n    /**\n     * @dev External function to withdraw tokens from the contract to the client.\n     * Uses the internal `_withdraw` function to perform the actual withdrawal.\n     * @param _token The token to withdraw\n     */\n    function withdrawTokens(address _token) external override nonReentrant {\n        if (_token == token) {\n            _withdraw();\n        } else {\n            if (block.timestamp <= terminationTime) revert Terminated();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n\n            _withdrawDeposit(_token, balance);\n        }\n    }\n\n    /**\n     * @dev External function to lock the contract.\n     * @param _details Details of the dispute\n     */\n    function lock(bytes32 _details) external payable override nonReentrant {\n        if (locked) revert Locked();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n        if (block.timestamp >= terminationTime) revert Terminated();\n        if (_msgSender() != client && _msgSender() != provider)\n            revert NotParty();\n\n        if (resolverType == ADR.ARBITRATOR) {\n            disputeId = IArbitrator(resolver).createDispute{value: msg.value}(\n                NUM_RULING_OPTIONS,\n                abi.encodePacked(details)\n            );\n        }\n        locked = true;\n\n        emit Lock(_msgSender(), _details);\n    }\n\n    /**\n     * @dev External function to resolve the contract.\n     * @param _clientAward The amount to award the client\n     * @param _providerAward The amount to award the provider\n     * @param _details Details of the dispute\n     */\n    function resolve(\n        uint256 _clientAward,\n        uint256 _providerAward,\n        bytes32 _details\n    ) external virtual override nonReentrant {\n        if (resolverType != ADR.INDIVIDUAL) revert InvalidIndividualResolver();\n        if (!locked) revert Locked();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n        if (_msgSender() != resolver) revert NotResolver();\n\n        uint256 resolutionFee = balance / resolutionRate;\n\n        if (_clientAward + _providerAward != balance - resolutionFee)\n            revert ResolutionMismatch();\n\n        if (_providerAward > 0) {\n            _transferPayment(token, _providerAward);\n        }\n        if (_clientAward > 0) {\n            _withdrawDeposit(token, _clientAward);\n        }\n        if (resolutionFee > 0) {\n            IERC20(token).safeTransfer(resolver, resolutionFee);\n        }\n\n        milestone = amounts.length;\n        locked = false;\n\n        emit Resolve(\n            _msgSender(),\n            _clientAward,\n            _providerAward,\n            resolutionFee,\n            _details\n        );\n    }\n\n    /**\n     * @dev External function to rule on a dispute.\n     * @param _disputeId The ID of the dispute\n     * @param _ruling The ruling of the arbitrator\n     */\n    function rule(\n        uint256 _disputeId,\n        uint256 _ruling\n    ) external virtual override nonReentrant {\n        if (resolverType != ADR.ARBITRATOR) revert InvalidArbitratorResolver();\n        if (!locked) revert Locked();\n        if (_msgSender() != resolver) revert NotResolver();\n        if (_disputeId != disputeId) revert IncorrectDisputeId();\n        if (_ruling > NUM_RULING_OPTIONS) revert InvalidRuling();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n\n        uint8[2] memory ruling = _getRuling(_ruling);\n        uint8 clientShare = ruling[0];\n        uint8 providerShare = ruling[1];\n        uint8 denom = clientShare + providerShare;\n        uint256 providerAward = (balance * providerShare) / denom;\n        uint256 clientAward = balance - providerAward;\n\n        if (providerAward > 0) {\n            _transferPayment(token, providerAward);\n        }\n        if (clientAward > 0) {\n            _withdrawDeposit(token, clientAward);\n        }\n\n        milestone = amounts.length;\n        locked = false;\n\n        emit Rule(resolver, clientAward, providerAward, _ruling);\n        emit Ruling(resolver, _disputeId, _ruling);\n    }\n\n    /**\n     * @dev Internal function to get the ruling of the arbitrator.\n     * @param _ruling The ruling of the arbitrator\n     */\n    function _getRuling(\n        uint256 _ruling\n    ) internal pure returns (uint8[2] memory ruling) {\n        uint8[2][6] memory rulings = [\n            [1, 1], // 0 = refused to arbitrate\n            [1, 0], // 1 = 100% to client\n            [3, 1], // 2 = 75% to client\n            [1, 1], // 3 = 50% to client\n            [1, 3], // 4 = 25% to client\n            [0, 1] // 5 = 0% to client\n        ];\n        ruling = rulings[_ruling];\n    }\n\n    /**\n     * @dev Internal function to transfer payment to the provider.\n     * @param _token The token to transfer\n     * @param _amount The amount to transfer\n     */\n    function _transferPayment(\n        address _token,\n        uint256 _amount\n    ) internal virtual {\n        IERC20(_token).safeTransfer(provider, _amount);\n    }\n\n    /**\n     * @dev Internal function to withdraw deposit to the client.\n     * @param _token The token to withdraw\n     * @param _amount The amount to withdraw\n     */\n    function _withdrawDeposit(\n        address _token,\n        uint256 _amount\n    ) internal virtual {\n        IERC20(_token).safeTransfer(client, _amount);\n    }\n\n    // receive eth transfers\n    // solhint-disable-next-line no-complex-fallback\n    receive() external payable {\n        if (locked) revert Locked();\n        if (token != wrappedNativeToken) revert InvalidWrappedNativeToken();\n        IWRAPPED(wrappedNativeToken).deposit{value: msg.value}();\n        emit Deposit(_msgSender(), msg.value);\n    }\n}");
insert UsingDirective(7307, 7306, "using SafeERC20 for IERC20;");
insert TypeAlias(7308, 7307, "SafeERC20");
insert Identifier(7309, 7308, "SafeERC20");
insert TypeName(7310, 7307, "IERC20");
insert UserDefinedType(7311, 7310, "IERC20");
insert Identifier(7312, 7311, "IERC20");
insert EnumDeclaration(7313, 7306, "enum ADR {\n        INDIVIDUAL,\n        ARBITRATOR\n    }");
insert Identifier(7314, 7313, "ADR");
insert EnumBody(7315, 7313, "{\n        INDIVIDUAL,\n        ARBITRATOR\n    }");
insert EnumValue(7316, 7315, "INDIVIDUAL");
insert EnumValue(7317, 7315, "ARBITRATOR");
insert StateVariableDeclaration(7318, 7306, "uint256 public constant NUM_RULING_OPTIONS = 5;");
insert TypeName(7319, 7318, "uint256");
insert PrimitiveType(7320, 7319, "uint256");
insert Visibility(7321, 7318, "public");
insert Identifier(7322, 7318, "NUM_RULING_OPTIONS");
insert Expression(7323, 7318, "5");
insert NumberLiteral(7324, 7323, "5");
insert Comment(7325, 7306, "// excludes options 0, 1 and 2");
insert StateVariableDeclaration(7326, 7306, "uint8[2][6] public RULINGS = [\n        [1, 1], // 0 = refused to arbitrate\n        [1, 0], // 1 = 100% to client\n        [3, 1], // 2 = 75% to client\n        [1, 1], // 3 = 50% to client\n        [1, 3], // 4 = 25% to client\n        [0, 1] // 5 = 0% to client\n    ];");
insert TypeName(7327, 7326, "uint8[2][6]");
insert TypeName(7328, 7327, "uint8[2]");
insert TypeName(7329, 7328, "uint8");
insert PrimitiveType(7330, 7329, "uint8");
insert Expression(7331, 7328, "2");
insert NumberLiteral(7332, 7331, "2");
insert Expression(7333, 7327, "6");
insert NumberLiteral(7334, 7333, "6");
insert Visibility(7335, 7326, "public");
insert Identifier(7336, 7326, "RULINGS");
insert Expression(7337, 7326, "[\n        [1, 1], // 0 = refused to arbitrate\n        [1, 0], // 1 = 100% to client\n        [3, 1], // 2 = 75% to client\n        [1, 1], // 3 = 50% to client\n        [1, 3], // 4 = 25% to client\n        [0, 1] // 5 = 0% to client\n    ]");
insert InlineArrayExpression(7338, 7337, "[\n        [1, 1], // 0 = refused to arbitrate\n        [1, 0], // 1 = 100% to client\n        [3, 1], // 2 = 75% to client\n        [1, 1], // 3 = 50% to client\n        [1, 3], // 4 = 25% to client\n        [0, 1] // 5 = 0% to client\n    ]");
insert Expression(7339, 7338, "[1, 1]");
insert InlineArrayExpression(7340, 7339, "[1, 1]");
insert Expression(7341, 7340, "1");
insert NumberLiteral(7342, 7341, "1");
insert Expression(7343, 7340, "1");
insert NumberLiteral(7344, 7343, "1");
insert Comment(7345, 7338, "// 0 = refused to arbitrate");
insert Expression(7346, 7338, "[1, 0]");
insert InlineArrayExpression(7347, 7346, "[1, 0]");
insert Expression(7348, 7347, "1");
insert NumberLiteral(7349, 7348, "1");
insert Expression(7350, 7347, "0");
insert NumberLiteral(7351, 7350, "0");
insert Comment(7352, 7338, "// 1 = 100% to client");
insert Expression(7353, 7338, "[3, 1]");
insert InlineArrayExpression(7354, 7353, "[3, 1]");
insert Expression(7355, 7354, "3");
insert NumberLiteral(7356, 7355, "3");
insert Expression(7357, 7354, "1");
insert NumberLiteral(7358, 7357, "1");
insert Comment(7359, 7338, "// 2 = 75% to client");
insert Expression(7360, 7338, "[1, 1]");
insert InlineArrayExpression(7361, 7360, "[1, 1]");
insert Expression(7362, 7361, "1");
insert NumberLiteral(7363, 7362, "1");
insert Expression(7364, 7361, "1");
insert NumberLiteral(7365, 7364, "1");
insert Comment(7366, 7338, "// 3 = 50% to client");
insert Expression(7367, 7338, "[1, 3]");
insert InlineArrayExpression(7368, 7367, "[1, 3]");
insert Expression(7369, 7368, "1");
insert NumberLiteral(7370, 7369, "1");
insert Expression(7371, 7368, "3");
insert NumberLiteral(7372, 7371, "3");
insert Comment(7373, 7338, "// 4 = 25% to client");
insert Expression(7374, 7338, "[0, 1]");
insert InlineArrayExpression(7375, 7374, "[0, 1]");
insert Expression(7376, 7375, "0");
insert NumberLiteral(7377, 7376, "0");
insert Expression(7378, 7375, "1");
insert NumberLiteral(7379, 7378, "1");
insert Comment(7380, 7338, "// 5 = 0% to client");
insert StateVariableDeclaration(7381, 7306, "uint256 public constant MAX_TERMINATION_TIME = 63113904;");
insert TypeName(7382, 7381, "uint256");
insert PrimitiveType(7383, 7382, "uint256");
insert Visibility(7384, 7381, "public");
insert Identifier(7385, 7381, "MAX_TERMINATION_TIME");
insert Expression(7386, 7381, "63113904");
insert NumberLiteral(7387, 7386, "63113904");
insert Comment(7388, 7306, "// 2-year limit on locker");
insert StateVariableDeclaration(7389, 7306, "address public wrappedNativeToken;");
insert TypeName(7390, 7389, "address");
insert PrimitiveType(7391, 7390, "address");
insert Visibility(7392, 7389, "public");
insert Identifier(7393, 7389, "wrappedNativeToken");
insert StateVariableDeclaration(7394, 7306, "address public client;");
insert TypeName(7395, 7394, "address");
insert PrimitiveType(7396, 7395, "address");
insert Visibility(7397, 7394, "public");
insert Identifier(7398, 7394, "client");
insert StateVariableDeclaration(7399, 7306, "address public provider;");
insert TypeName(7400, 7399, "address");
insert PrimitiveType(7401, 7400, "address");
insert Visibility(7402, 7399, "public");
insert Identifier(7403, 7399, "provider");
insert StateVariableDeclaration(7404, 7306, "ADR public resolverType;");
insert TypeName(7405, 7404, "ADR");
insert UserDefinedType(7406, 7405, "ADR");
insert Identifier(7407, 7406, "ADR");
insert Visibility(7408, 7404, "public");
insert Identifier(7409, 7404, "resolverType");
insert StateVariableDeclaration(7410, 7306, "address public resolver;");
insert TypeName(7411, 7410, "address");
insert PrimitiveType(7412, 7411, "address");
insert Visibility(7413, 7410, "public");
insert Identifier(7414, 7410, "resolver");
insert StateVariableDeclaration(7415, 7306, "address public token;");
insert TypeName(7416, 7415, "address");
insert PrimitiveType(7417, 7416, "address");
insert Visibility(7418, 7415, "public");
insert Identifier(7419, 7415, "token");
insert StateVariableDeclaration(7420, 7306, "uint256 public terminationTime;");
insert TypeName(7421, 7420, "uint256");
insert PrimitiveType(7422, 7421, "uint256");
insert Visibility(7423, 7420, "public");
insert Identifier(7424, 7420, "terminationTime");
insert StateVariableDeclaration(7425, 7306, "uint256 public resolutionRate;");
insert TypeName(7426, 7425, "uint256");
insert PrimitiveType(7427, 7426, "uint256");
insert Visibility(7428, 7425, "public");
insert Identifier(7429, 7425, "resolutionRate");
insert StateVariableDeclaration(7430, 7306, "bytes32 public details;");
insert TypeName(7431, 7430, "bytes32");
insert PrimitiveType(7432, 7431, "bytes32");
insert Visibility(7433, 7430, "public");
insert Identifier(7434, 7430, "details");
insert StateVariableDeclaration(7435, 7306, "uint256[] public amounts;");
insert TypeName(7436, 7435, "uint256[]");
insert TypeName(7437, 7436, "uint256");
insert PrimitiveType(7438, 7437, "uint256");
insert Visibility(7439, 7435, "public");
insert Identifier(7440, 7435, "amounts");
insert Comment(7441, 7306, "// milestones split into amounts");
insert StateVariableDeclaration(7442, 7306, "uint256 public total = 0;");
insert TypeName(7443, 7442, "uint256");
insert PrimitiveType(7444, 7443, "uint256");
insert Visibility(7445, 7442, "public");
insert Identifier(7446, 7442, "total");
insert Expression(7447, 7442, "0");
insert NumberLiteral(7448, 7447, "0");
insert StateVariableDeclaration(7449, 7306, "bool public locked;");
insert TypeName(7450, 7449, "bool");
insert PrimitiveType(7451, 7450, "bool");
insert Visibility(7452, 7449, "public");
insert Identifier(7453, 7449, "locked");
insert StateVariableDeclaration(7454, 7306, "uint256 public milestone = 0;");
insert TypeName(7455, 7454, "uint256");
insert PrimitiveType(7456, 7455, "uint256");
insert Visibility(7457, 7454, "public");
insert Identifier(7458, 7454, "milestone");
insert Expression(7459, 7454, "0");
insert NumberLiteral(7460, 7459, "0");
insert Comment(7461, 7306, "// current milestone - starts from 0 to amounts.length");
insert StateVariableDeclaration(7462, 7306, "uint256 public released = 0;");
insert TypeName(7463, 7462, "uint256");
insert PrimitiveType(7464, 7463, "uint256");
insert Visibility(7465, 7462, "public");
insert Identifier(7466, 7462, "released");
insert Expression(7467, 7462, "0");
insert NumberLiteral(7468, 7467, "0");
insert StateVariableDeclaration(7469, 7306, "uint256 public disputeId;");
insert TypeName(7470, 7469, "uint256");
insert PrimitiveType(7471, 7470, "uint256");
insert Visibility(7472, 7469, "public");
insert Identifier(7473, 7469, "disputeId");
insert ConstructorDefinition(7474, 7306, "constructor() {\n        _disableInitializers();\n    }");
insert FunctionBody(7475, 7474, "{\n        _disableInitializers();\n    }");
insert Statement(7476, 7475, "_disableInitializers();");
insert ExpressionStatement(7477, 7476, "_disableInitializers();");
insert Expression(7478, 7477, "_disableInitializers()");
insert CallExpression(7479, 7478, "_disableInitializers()");
insert Expression(7480, 7479, "_disableInitializers");
insert Identifier(7481, 7480, "_disableInitializers");
insert Comment(7482, 7306, "/**\n     * @dev Initializes the contract with the provided provider, amounts, and data.\n     * @param _provider The address of the provider\n     * @param _amounts The array of amounts associated with the provider\n     * @param _data The additional data needed for initialization\n     */");
insert FunctionDefinition(7483, 7306, "function init(\n        address _provider,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external virtual override initializer {\n        if (_provider == address(0)) revert InvalidProvider();\n\n        _handleData(_data);\n\n        provider = _provider;\n        amounts = _amounts;\n        uint256 _total = 0;\n        for (uint256 i = 0; i < amounts.length; i++) {\n            _total += amounts[i];\n        }\n        total = _total;\n    }");
insert Identifier(7484, 7483, "init");
insert Parameter(7485, 7483, "address _provider");
insert TypeName(7486, 7485, "address");
insert PrimitiveType(7487, 7486, "address");
insert Identifier(7488, 7485, "_provider");
insert Parameter(7489, 7483, "uint256[] calldata _amounts");
insert TypeName(7490, 7489, "uint256[]");
insert TypeName(7491, 7490, "uint256");
insert PrimitiveType(7492, 7491, "uint256");
insert Identifier(7493, 7489, "_amounts");
insert Parameter(7494, 7483, "bytes calldata _data");
insert TypeName(7495, 7494, "bytes");
insert PrimitiveType(7496, 7495, "bytes");
insert Identifier(7497, 7494, "_data");
insert Visibility(7498, 7483, "external");
insert Virtual(7499, 7483, "virtual");
insert OverrideSpecifier(7500, 7483, "override");
insert ModifierInvocation(7501, 7483, "initializer");
insert Identifier(7502, 7501, "initializer");
insert FunctionBody(7503, 7483, "{\n        if (_provider == address(0)) revert InvalidProvider();\n\n        _handleData(_data);\n\n        provider = _provider;\n        amounts = _amounts;\n        uint256 _total = 0;\n        for (uint256 i = 0; i < amounts.length; i++) {\n            _total += amounts[i];\n        }\n        total = _total;\n    }");
insert Statement(7504, 7503, "if (_provider == address(0)) revert InvalidProvider();");
insert IfStatement(7505, 7504, "if (_provider == address(0)) revert InvalidProvider();");
insert Expression(7506, 7505, "_provider == address(0)");
insert BinaryExpression(7507, 7506, "_provider == address(0)");
insert Expression(7508, 7507, "_provider");
insert Identifier(7509, 7508, "_provider");
insert Expression(7510, 7507, "address(0)");
insert TypeCastExpression(7511, 7510, "address(0)");
insert PrimitiveType(7512, 7511, "address");
insert CallArgument(7513, 7511, "0");
insert Expression(7514, 7513, "0");
insert NumberLiteral(7515, 7514, "0");
insert Statement(7516, 7505, "revert InvalidProvider();");
insert RevertStatement(7517, 7516, "revert InvalidProvider();");
insert Expression(7518, 7517, "InvalidProvider");
insert Identifier(7519, 7518, "InvalidProvider");
insert RevertArguments(7520, 7517, "()");
insert Statement(7521, 7503, "_handleData(_data);");
insert ExpressionStatement(7522, 7521, "_handleData(_data);");
insert Expression(7523, 7522, "_handleData(_data)");
insert CallExpression(7524, 7523, "_handleData(_data)");
insert Expression(7525, 7524, "_handleData");
insert Identifier(7526, 7525, "_handleData");
insert CallArgument(7527, 7524, "_data");
insert Expression(7528, 7527, "_data");
insert Identifier(7529, 7528, "_data");
insert Statement(7530, 7503, "provider = _provider;");
insert ExpressionStatement(7531, 7530, "provider = _provider;");
insert Expression(7532, 7531, "provider = _provider");
insert AssignmentExpression(7533, 7532, "provider = _provider");
insert Expression(7534, 7533, "provider");
insert Identifier(7535, 7534, "provider");
insert Expression(7536, 7533, "_provider");
insert Identifier(7537, 7536, "_provider");
insert Statement(7538, 7503, "amounts = _amounts;");
insert ExpressionStatement(7539, 7538, "amounts = _amounts;");
insert Expression(7540, 7539, "amounts = _amounts");
insert AssignmentExpression(7541, 7540, "amounts = _amounts");
insert Expression(7542, 7541, "amounts");
insert Identifier(7543, 7542, "amounts");
insert Expression(7544, 7541, "_amounts");
insert Identifier(7545, 7544, "_amounts");
insert Statement(7546, 7503, "uint256 _total = 0;");
insert VariableDeclarationStatement(7547, 7546, "uint256 _total = 0;");
insert VariableDeclaration(7548, 7547, "uint256 _total");
insert TypeName(7549, 7548, "uint256");
insert PrimitiveType(7550, 7549, "uint256");
insert Identifier(7551, 7548, "_total");
insert Expression(7552, 7547, "0");
insert NumberLiteral(7553, 7552, "0");
insert Statement(7554, 7503, "for (uint256 i = 0; i < amounts.length; i++) {\n            _total += amounts[i];\n        }");
insert ForStatement(7555, 7554, "for (uint256 i = 0; i < amounts.length; i++) {\n            _total += amounts[i];\n        }");
insert VariableDeclarationStatement(7556, 7555, "uint256 i = 0;");
insert VariableDeclaration(7557, 7556, "uint256 i");
insert TypeName(7558, 7557, "uint256");
insert PrimitiveType(7559, 7558, "uint256");
insert Identifier(7560, 7557, "i");
insert Expression(7561, 7556, "0");
insert NumberLiteral(7562, 7561, "0");
insert ExpressionStatement(7563, 7555, "i < amounts.length;");
insert Expression(7564, 7563, "i < amounts.length");
insert BinaryExpression(7565, 7564, "i < amounts.length");
insert Expression(7566, 7565, "i");
insert Identifier(7567, 7566, "i");
insert Expression(7568, 7565, "amounts.length");
insert MemberExpression(7569, 7568, "amounts.length");
insert Identifier(7570, 7569, "amounts");
insert Identifier(7571, 7569, "length");
insert Expression(7572, 7555, "i++");
insert UpdateExpression(7573, 7572, "i++");
insert Expression(7574, 7573, "i");
insert Identifier(7575, 7574, "i");
insert Statement(7576, 7555, "{\n            _total += amounts[i];\n        }");
insert BlockStatement(7577, 7576, "{\n            _total += amounts[i];\n        }");
insert Statement(7578, 7577, "_total += amounts[i];");
insert ExpressionStatement(7579, 7578, "_total += amounts[i];");
insert Expression(7580, 7579, "_total += amounts[i]");
insert AugmentedAssignmentExpression(7581, 7580, "_total += amounts[i]");
insert Expression(7582, 7581, "_total");
insert Identifier(7583, 7582, "_total");
insert Expression(7584, 7581, "amounts[i]");
insert ArrayAccess(7585, 7584, "amounts[i]");
insert Expression(7586, 7585, "amounts");
insert Identifier(7587, 7586, "amounts");
insert Expression(7588, 7585, "i");
insert Identifier(7589, 7588, "i");
insert Statement(7590, 7503, "total = _total;");
insert ExpressionStatement(7591, 7590, "total = _total;");
insert Expression(7592, 7591, "total = _total");
insert AssignmentExpression(7593, 7592, "total = _total");
insert Expression(7594, 7593, "total");
insert Identifier(7595, 7594, "total");
insert Expression(7596, 7593, "_total");
insert Identifier(7597, 7596, "_total");
insert Comment(7598, 7306, "/**\n     * @dev Handles the provided data, decodes it, and initializes necessary contract state variables.\n     * @param _data The data to be handled and decoded\n     */");
insert FunctionDefinition(7599, 7306, "function _handleData(bytes calldata _data) internal virtual {\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address\n                )\n            );\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }\n\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_resolutionRate == 0) revert InvalidResolutionRate();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }");
insert Identifier(7600, 7599, "_handleData");
insert Parameter(7601, 7599, "bytes calldata _data");
insert TypeName(7602, 7601, "bytes");
insert PrimitiveType(7603, 7602, "bytes");
insert Identifier(7604, 7601, "_data");
insert Visibility(7605, 7599, "internal");
insert Virtual(7606, 7599, "virtual");
insert FunctionBody(7607, 7599, "{\n        (\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address\n                )\n            );\n\n        uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);\n        if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }\n\n        if (_client == address(0)) revert InvalidClient();\n        if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();\n        if (_resolver == address(0)) revert InvalidResolver();\n        if (_token == address(0)) revert InvalidToken();\n        if (_terminationTime <= block.timestamp) revert DurationEnded();\n        if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();\n        if (_resolutionRate == 0) revert InvalidResolutionRate();\n        if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();\n\n        client = _client;\n        resolverType = ADR(_resolverType);\n        resolver = _resolver;\n        token = _token;\n        terminationTime = _terminationTime;\n        resolutionRate = _resolutionRate;\n        details = _details;\n        wrappedNativeToken = _wrappedNativeToken;\n\n        if (!_requireVerification) emit Verified(client, address(this));\n    }");
insert Statement(7608, 7607, "(\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address\n                )\n            );");
insert VariableDeclarationStatement(7609, 7608, "(\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory\n        ) = abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address\n                )\n            );");
insert VariableDeclarationTuple(7610, 7609, "(\n            address _client,\n            uint8 _resolverType,\n            address _resolver,\n            address _token,\n            uint256 _terminationTime,\n            bytes32 _details,\n            address _wrappedNativeToken,\n            bool _requireVerification,\n            address _factory\n        )");
insert VariableDeclaration(7611, 7610, "address _client");
insert TypeName(7612, 7611, "address");
insert PrimitiveType(7613, 7612, "address");
insert Identifier(7614, 7611, "_client");
insert VariableDeclaration(7615, 7610, "uint8 _resolverType");
insert TypeName(7616, 7615, "uint8");
insert PrimitiveType(7617, 7616, "uint8");
insert Identifier(7618, 7615, "_resolverType");
insert VariableDeclaration(7619, 7610, "address _resolver");
insert TypeName(7620, 7619, "address");
insert PrimitiveType(7621, 7620, "address");
insert Identifier(7622, 7619, "_resolver");
insert VariableDeclaration(7623, 7610, "address _token");
insert TypeName(7624, 7623, "address");
insert PrimitiveType(7625, 7624, "address");
insert Identifier(7626, 7623, "_token");
insert VariableDeclaration(7627, 7610, "uint256 _terminationTime");
insert TypeName(7628, 7627, "uint256");
insert PrimitiveType(7629, 7628, "uint256");
insert Identifier(7630, 7627, "_terminationTime");
insert VariableDeclaration(7631, 7610, "bytes32 _details");
insert TypeName(7632, 7631, "bytes32");
insert PrimitiveType(7633, 7632, "bytes32");
insert Identifier(7634, 7631, "_details");
insert VariableDeclaration(7635, 7610, "address _wrappedNativeToken");
insert TypeName(7636, 7635, "address");
insert PrimitiveType(7637, 7636, "address");
insert Identifier(7638, 7635, "_wrappedNativeToken");
insert VariableDeclaration(7639, 7610, "bool _requireVerification");
insert TypeName(7640, 7639, "bool");
insert PrimitiveType(7641, 7640, "bool");
insert Identifier(7642, 7639, "_requireVerification");
insert VariableDeclaration(7643, 7610, "address _factory");
insert TypeName(7644, 7643, "address");
insert PrimitiveType(7645, 7644, "address");
insert Identifier(7646, 7643, "_factory");
insert Expression(7647, 7609, "abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address\n                )\n            )");
insert CallExpression(7648, 7647, "abi.decode(\n                _data,\n                (\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address\n                )\n            )");
insert Expression(7649, 7648, "abi.decode");
insert MemberExpression(7650, 7649, "abi.decode");
insert Identifier(7651, 7650, "abi");
insert Identifier(7652, 7650, "decode");
insert CallArgument(7653, 7648, "_data");
insert Expression(7654, 7653, "_data");
insert Identifier(7655, 7654, "_data");
insert CallArgument(7656, 7648, "(\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address\n                )");
insert Expression(7657, 7656, "(\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address\n                )");
insert TupleExpression(7658, 7657, "(\n                    address,\n                    uint8,\n                    address,\n                    address,\n                    uint256,\n                    bytes32,\n                    address,\n                    bool,\n                    address\n                )");
insert Expression(7659, 7658, "address");
insert PrimitiveType(7660, 7659, "address");
insert Expression(7661, 7658, "uint8");
insert PrimitiveType(7662, 7661, "uint8");
insert Expression(7663, 7658, "address");
insert PrimitiveType(7664, 7663, "address");
insert Expression(7665, 7658, "address");
insert PrimitiveType(7666, 7665, "address");
insert Expression(7667, 7658, "uint256");
insert PrimitiveType(7668, 7667, "uint256");
insert Expression(7669, 7658, "bytes32");
insert PrimitiveType(7670, 7669, "bytes32");
insert Expression(7671, 7658, "address");
insert PrimitiveType(7672, 7671, "address");
insert Expression(7673, 7658, "bool");
insert PrimitiveType(7674, 7673, "bool");
insert Expression(7675, 7658, "address");
insert PrimitiveType(7676, 7675, "address");
insert Statement(7677, 7607, "uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);");
insert VariableDeclarationStatement(7678, 7677, "uint256 _resolutionRate = ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver);");
insert VariableDeclaration(7679, 7678, "uint256 _resolutionRate");
insert TypeName(7680, 7679, "uint256");
insert PrimitiveType(7681, 7680, "uint256");
insert Identifier(7682, 7679, "_resolutionRate");
insert Expression(7683, 7678, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver)");
insert CallExpression(7684, 7683, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf(_resolver)");
insert Expression(7685, 7684, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf");
insert MemberExpression(7686, 7685, "ISmartInvoiceFactory(_factory)\n            .resolutionRateOf");
insert Expression(7687, 7686, "ISmartInvoiceFactory(_factory)");
insert CallExpression(7688, 7687, "ISmartInvoiceFactory(_factory)");
insert Expression(7689, 7688, "ISmartInvoiceFactory");
insert Identifier(7690, 7689, "ISmartInvoiceFactory");
insert CallArgument(7691, 7688, "_factory");
insert Expression(7692, 7691, "_factory");
insert Identifier(7693, 7692, "_factory");
insert Identifier(7694, 7686, "resolutionRateOf");
insert CallArgument(7695, 7684, "_resolver");
insert Expression(7696, 7695, "_resolver");
insert Identifier(7697, 7696, "_resolver");
insert Statement(7698, 7607, "if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }");
insert IfStatement(7699, 7698, "if (_resolutionRate == 0) {\n            _resolutionRate = 20;\n        }");
insert Expression(7700, 7699, "_resolutionRate == 0");
insert BinaryExpression(7701, 7700, "_resolutionRate == 0");
insert Expression(7702, 7701, "_resolutionRate");
insert Identifier(7703, 7702, "_resolutionRate");
insert Expression(7704, 7701, "0");
insert NumberLiteral(7705, 7704, "0");
insert Statement(7706, 7699, "{\n            _resolutionRate = 20;\n        }");
insert BlockStatement(7707, 7706, "{\n            _resolutionRate = 20;\n        }");
insert Statement(7708, 7707, "_resolutionRate = 20;");
insert ExpressionStatement(7709, 7708, "_resolutionRate = 20;");
insert Expression(7710, 7709, "_resolutionRate = 20");
insert AssignmentExpression(7711, 7710, "_resolutionRate = 20");
insert Expression(7712, 7711, "_resolutionRate");
insert Identifier(7713, 7712, "_resolutionRate");
insert Expression(7714, 7711, "20");
insert NumberLiteral(7715, 7714, "20");
insert Statement(7716, 7607, "if (_client == address(0)) revert InvalidClient();");
insert IfStatement(7717, 7716, "if (_client == address(0)) revert InvalidClient();");
insert Expression(7718, 7717, "_client == address(0)");
insert BinaryExpression(7719, 7718, "_client == address(0)");
insert Expression(7720, 7719, "_client");
insert Identifier(7721, 7720, "_client");
insert Expression(7722, 7719, "address(0)");
insert TypeCastExpression(7723, 7722, "address(0)");
insert PrimitiveType(7724, 7723, "address");
insert CallArgument(7725, 7723, "0");
insert Expression(7726, 7725, "0");
insert NumberLiteral(7727, 7726, "0");
insert Statement(7728, 7717, "revert InvalidClient();");
insert RevertStatement(7729, 7728, "revert InvalidClient();");
insert Expression(7730, 7729, "InvalidClient");
insert Identifier(7731, 7730, "InvalidClient");
insert RevertArguments(7732, 7729, "()");
insert Statement(7733, 7607, "if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();");
insert IfStatement(7734, 7733, "if (_resolverType > uint8(ADR.ARBITRATOR)) revert InvalidResolverType();");
insert Expression(7735, 7734, "_resolverType > uint8(ADR.ARBITRATOR)");
insert BinaryExpression(7736, 7735, "_resolverType > uint8(ADR.ARBITRATOR)");
insert Expression(7737, 7736, "_resolverType");
insert Identifier(7738, 7737, "_resolverType");
insert Expression(7739, 7736, "uint8(ADR.ARBITRATOR)");
insert TypeCastExpression(7740, 7739, "uint8(ADR.ARBITRATOR)");
insert PrimitiveType(7741, 7740, "uint8");
insert CallArgument(7742, 7740, "ADR.ARBITRATOR");
insert Expression(7743, 7742, "ADR.ARBITRATOR");
insert MemberExpression(7744, 7743, "ADR.ARBITRATOR");
insert Identifier(7745, 7744, "ADR");
insert Identifier(7746, 7744, "ARBITRATOR");
insert Statement(7747, 7734, "revert InvalidResolverType();");
insert RevertStatement(7748, 7747, "revert InvalidResolverType();");
insert Expression(7749, 7748, "InvalidResolverType");
insert Identifier(7750, 7749, "InvalidResolverType");
insert RevertArguments(7751, 7748, "()");
insert Statement(7752, 7607, "if (_resolver == address(0)) revert InvalidResolver();");
insert IfStatement(7753, 7752, "if (_resolver == address(0)) revert InvalidResolver();");
insert Expression(7754, 7753, "_resolver == address(0)");
insert BinaryExpression(7755, 7754, "_resolver == address(0)");
insert Expression(7756, 7755, "_resolver");
insert Identifier(7757, 7756, "_resolver");
insert Expression(7758, 7755, "address(0)");
insert TypeCastExpression(7759, 7758, "address(0)");
insert PrimitiveType(7760, 7759, "address");
insert CallArgument(7761, 7759, "0");
insert Expression(7762, 7761, "0");
insert NumberLiteral(7763, 7762, "0");
insert Statement(7764, 7753, "revert InvalidResolver();");
insert RevertStatement(7765, 7764, "revert InvalidResolver();");
insert Expression(7766, 7765, "InvalidResolver");
insert Identifier(7767, 7766, "InvalidResolver");
insert RevertArguments(7768, 7765, "()");
insert Statement(7769, 7607, "if (_token == address(0)) revert InvalidToken();");
insert IfStatement(7770, 7769, "if (_token == address(0)) revert InvalidToken();");
insert Expression(7771, 7770, "_token == address(0)");
insert BinaryExpression(7772, 7771, "_token == address(0)");
insert Expression(7773, 7772, "_token");
insert Identifier(7774, 7773, "_token");
insert Expression(7775, 7772, "address(0)");
insert TypeCastExpression(7776, 7775, "address(0)");
insert PrimitiveType(7777, 7776, "address");
insert CallArgument(7778, 7776, "0");
insert Expression(7779, 7778, "0");
insert NumberLiteral(7780, 7779, "0");
insert Statement(7781, 7770, "revert InvalidToken();");
insert RevertStatement(7782, 7781, "revert InvalidToken();");
insert Expression(7783, 7782, "InvalidToken");
insert Identifier(7784, 7783, "InvalidToken");
insert RevertArguments(7785, 7782, "()");
insert Statement(7786, 7607, "if (_terminationTime <= block.timestamp) revert DurationEnded();");
insert IfStatement(7787, 7786, "if (_terminationTime <= block.timestamp) revert DurationEnded();");
insert Expression(7788, 7787, "_terminationTime <= block.timestamp");
insert BinaryExpression(7789, 7788, "_terminationTime <= block.timestamp");
insert Expression(7790, 7789, "_terminationTime");
insert Identifier(7791, 7790, "_terminationTime");
insert Expression(7792, 7789, "block.timestamp");
insert MemberExpression(7793, 7792, "block.timestamp");
insert Identifier(7794, 7793, "block");
insert Identifier(7795, 7793, "timestamp");
insert Statement(7796, 7787, "revert DurationEnded();");
insert RevertStatement(7797, 7796, "revert DurationEnded();");
insert Expression(7798, 7797, "DurationEnded");
insert Identifier(7799, 7798, "DurationEnded");
insert RevertArguments(7800, 7797, "()");
insert Statement(7801, 7607, "if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();");
insert IfStatement(7802, 7801, "if (_terminationTime > block.timestamp + MAX_TERMINATION_TIME)\n            revert DurationTooLong();");
insert Expression(7803, 7802, "_terminationTime > block.timestamp + MAX_TERMINATION_TIME");
insert BinaryExpression(7804, 7803, "_terminationTime > block.timestamp + MAX_TERMINATION_TIME");
insert Expression(7805, 7804, "_terminationTime > block.timestamp");
insert MemberExpression(7806, 7805, "_terminationTime > block.timestamp");
insert Expression(7807, 7806, "_terminationTime > block");
insert BinaryExpression(7808, 7807, "_terminationTime > block");
insert Expression(7809, 7808, "_terminationTime");
insert Identifier(7810, 7809, "_terminationTime");
insert Expression(7811, 7808, "block");
insert Identifier(7812, 7811, "block");
insert Identifier(7813, 7806, "timestamp");
insert Expression(7814, 7804, "MAX_TERMINATION_TIME");
insert Identifier(7815, 7814, "MAX_TERMINATION_TIME");
insert Statement(7816, 7802, "revert DurationTooLong();");
insert RevertStatement(7817, 7816, "revert DurationTooLong();");
insert Expression(7818, 7817, "DurationTooLong");
insert Identifier(7819, 7818, "DurationTooLong");
insert RevertArguments(7820, 7817, "()");
insert Statement(7821, 7607, "if (_resolutionRate == 0) revert InvalidResolutionRate();");
insert IfStatement(7822, 7821, "if (_resolutionRate == 0) revert InvalidResolutionRate();");
insert Expression(7823, 7822, "_resolutionRate == 0");
insert BinaryExpression(7824, 7823, "_resolutionRate == 0");
insert Expression(7825, 7824, "_resolutionRate");
insert Identifier(7826, 7825, "_resolutionRate");
insert Expression(7827, 7824, "0");
insert NumberLiteral(7828, 7827, "0");
insert Statement(7829, 7822, "revert InvalidResolutionRate();");
insert RevertStatement(7830, 7829, "revert InvalidResolutionRate();");
insert Expression(7831, 7830, "InvalidResolutionRate");
insert Identifier(7832, 7831, "InvalidResolutionRate");
insert RevertArguments(7833, 7830, "()");
insert Statement(7834, 7607, "if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();");
insert IfStatement(7835, 7834, "if (_wrappedNativeToken == address(0))\n            revert InvalidWrappedNativeToken();");
insert Expression(7836, 7835, "_wrappedNativeToken == address(0)");
insert BinaryExpression(7837, 7836, "_wrappedNativeToken == address(0)");
insert Expression(7838, 7837, "_wrappedNativeToken");
insert Identifier(7839, 7838, "_wrappedNativeToken");
insert Expression(7840, 7837, "address(0)");
insert TypeCastExpression(7841, 7840, "address(0)");
insert PrimitiveType(7842, 7841, "address");
insert CallArgument(7843, 7841, "0");
insert Expression(7844, 7843, "0");
insert NumberLiteral(7845, 7844, "0");
insert Statement(7846, 7835, "revert InvalidWrappedNativeToken();");
insert RevertStatement(7847, 7846, "revert InvalidWrappedNativeToken();");
insert Expression(7848, 7847, "InvalidWrappedNativeToken");
insert Identifier(7849, 7848, "InvalidWrappedNativeToken");
insert RevertArguments(7850, 7847, "()");
insert Statement(7851, 7607, "client = _client;");
insert ExpressionStatement(7852, 7851, "client = _client;");
insert Expression(7853, 7852, "client = _client");
insert AssignmentExpression(7854, 7853, "client = _client");
insert Expression(7855, 7854, "client");
insert Identifier(7856, 7855, "client");
insert Expression(7857, 7854, "_client");
insert Identifier(7858, 7857, "_client");
insert Statement(7859, 7607, "resolverType = ADR(_resolverType);");
insert ExpressionStatement(7860, 7859, "resolverType = ADR(_resolverType);");
insert Expression(7861, 7860, "resolverType = ADR(_resolverType)");
insert AssignmentExpression(7862, 7861, "resolverType = ADR(_resolverType)");
insert Expression(7863, 7862, "resolverType");
insert Identifier(7864, 7863, "resolverType");
insert Expression(7865, 7862, "ADR(_resolverType)");
insert CallExpression(7866, 7865, "ADR(_resolverType)");
insert Expression(7867, 7866, "ADR");
insert Identifier(7868, 7867, "ADR");
insert CallArgument(7869, 7866, "_resolverType");
insert Expression(7870, 7869, "_resolverType");
insert Identifier(7871, 7870, "_resolverType");
insert Statement(7872, 7607, "resolver = _resolver;");
insert ExpressionStatement(7873, 7872, "resolver = _resolver;");
insert Expression(7874, 7873, "resolver = _resolver");
insert AssignmentExpression(7875, 7874, "resolver = _resolver");
insert Expression(7876, 7875, "resolver");
insert Identifier(7877, 7876, "resolver");
insert Expression(7878, 7875, "_resolver");
insert Identifier(7879, 7878, "_resolver");
insert Statement(7880, 7607, "token = _token;");
insert ExpressionStatement(7881, 7880, "token = _token;");
insert Expression(7882, 7881, "token = _token");
insert AssignmentExpression(7883, 7882, "token = _token");
insert Expression(7884, 7883, "token");
insert Identifier(7885, 7884, "token");
insert Expression(7886, 7883, "_token");
insert Identifier(7887, 7886, "_token");
insert Statement(7888, 7607, "terminationTime = _terminationTime;");
insert ExpressionStatement(7889, 7888, "terminationTime = _terminationTime;");
insert Expression(7890, 7889, "terminationTime = _terminationTime");
insert AssignmentExpression(7891, 7890, "terminationTime = _terminationTime");
insert Expression(7892, 7891, "terminationTime");
insert Identifier(7893, 7892, "terminationTime");
insert Expression(7894, 7891, "_terminationTime");
insert Identifier(7895, 7894, "_terminationTime");
insert Statement(7896, 7607, "resolutionRate = _resolutionRate;");
insert ExpressionStatement(7897, 7896, "resolutionRate = _resolutionRate;");
insert Expression(7898, 7897, "resolutionRate = _resolutionRate");
insert AssignmentExpression(7899, 7898, "resolutionRate = _resolutionRate");
insert Expression(7900, 7899, "resolutionRate");
insert Identifier(7901, 7900, "resolutionRate");
insert Expression(7902, 7899, "_resolutionRate");
insert Identifier(7903, 7902, "_resolutionRate");
insert Statement(7904, 7607, "details = _details;");
insert ExpressionStatement(7905, 7904, "details = _details;");
insert Expression(7906, 7905, "details = _details");
insert AssignmentExpression(7907, 7906, "details = _details");
insert Expression(7908, 7907, "details");
insert Identifier(7909, 7908, "details");
insert Expression(7910, 7907, "_details");
insert Identifier(7911, 7910, "_details");
insert Statement(7912, 7607, "wrappedNativeToken = _wrappedNativeToken;");
insert ExpressionStatement(7913, 7912, "wrappedNativeToken = _wrappedNativeToken;");
insert Expression(7914, 7913, "wrappedNativeToken = _wrappedNativeToken");
insert AssignmentExpression(7915, 7914, "wrappedNativeToken = _wrappedNativeToken");
insert Expression(7916, 7915, "wrappedNativeToken");
insert Identifier(7917, 7916, "wrappedNativeToken");
insert Expression(7918, 7915, "_wrappedNativeToken");
insert Identifier(7919, 7918, "_wrappedNativeToken");
insert Statement(7920, 7607, "if (!_requireVerification) emit Verified(client, address(this));");
insert IfStatement(7921, 7920, "if (!_requireVerification) emit Verified(client, address(this));");
insert Expression(7922, 7921, "!_requireVerification");
insert UnaryExpression(7923, 7922, "!_requireVerification");
insert Expression(7924, 7923, "_requireVerification");
insert Identifier(7925, 7924, "_requireVerification");
insert Statement(7926, 7921, "emit Verified(client, address(this));");
insert EmitStatement(7927, 7926, "emit Verified(client, address(this));");
insert Expression(7928, 7927, "Verified");
insert Identifier(7929, 7928, "Verified");
insert CallArgument(7930, 7927, "client");
insert Expression(7931, 7930, "client");
insert Identifier(7932, 7931, "client");
insert CallArgument(7933, 7927, "address(this)");
insert Expression(7934, 7933, "address(this)");
insert TypeCastExpression(7935, 7934, "address(this)");
insert PrimitiveType(7936, 7935, "address");
insert CallArgument(7937, 7935, "this");
insert Expression(7938, 7937, "this");
insert Identifier(7939, 7938, "this");
insert Comment(7940, 7306, "/**\n     * @dev Verifies the client and contract are paired\n     */");
insert FunctionDefinition(7941, 7306, "function verify() external override {\n        if (msg.sender != client) revert NotClient();\n        emit Verified(client, address(this));\n    }");
insert Identifier(7942, 7941, "verify");
insert Visibility(7943, 7941, "external");
insert OverrideSpecifier(7944, 7941, "override");
insert FunctionBody(7945, 7941, "{\n        if (msg.sender != client) revert NotClient();\n        emit Verified(client, address(this));\n    }");
insert Statement(7946, 7945, "if (msg.sender != client) revert NotClient();");
insert IfStatement(7947, 7946, "if (msg.sender != client) revert NotClient();");
insert Expression(7948, 7947, "msg.sender != client");
insert BinaryExpression(7949, 7948, "msg.sender != client");
insert Expression(7950, 7949, "msg.sender");
insert MemberExpression(7951, 7950, "msg.sender");
insert Identifier(7952, 7951, "msg");
insert Identifier(7953, 7951, "sender");
insert Expression(7954, 7949, "client");
insert Identifier(7955, 7954, "client");
insert Statement(7956, 7947, "revert NotClient();");
insert RevertStatement(7957, 7956, "revert NotClient();");
insert Expression(7958, 7957, "NotClient");
insert Identifier(7959, 7958, "NotClient");
insert RevertArguments(7960, 7957, "()");
insert Statement(7961, 7945, "emit Verified(client, address(this));");
insert EmitStatement(7962, 7961, "emit Verified(client, address(this));");
insert Expression(7963, 7962, "Verified");
insert Identifier(7964, 7963, "Verified");
insert CallArgument(7965, 7962, "client");
insert Expression(7966, 7965, "client");
insert Identifier(7967, 7966, "client");
insert CallArgument(7968, 7962, "address(this)");
insert Expression(7969, 7968, "address(this)");
insert TypeCastExpression(7970, 7969, "address(this)");
insert PrimitiveType(7971, 7970, "address");
insert CallArgument(7972, 7970, "this");
insert Expression(7973, 7972, "this");
insert Identifier(7974, 7973, "this");
insert Comment(7975, 7306, "/**\n     * @dev Adds milestones without extra details.\n     * @param _milestones The array of new milestones to be added\n     */");
insert FunctionDefinition(7976, 7306, "function addMilestones(uint256[] calldata _milestones) external override {\n        _addMilestones(_milestones, bytes32(0));\n    }");
insert Identifier(7977, 7976, "addMilestones");
insert Parameter(7978, 7976, "uint256[] calldata _milestones");
insert TypeName(7979, 7978, "uint256[]");
insert TypeName(7980, 7979, "uint256");
insert PrimitiveType(7981, 7980, "uint256");
insert Identifier(7982, 7978, "_milestones");
insert Visibility(7983, 7976, "external");
insert OverrideSpecifier(7984, 7976, "override");
insert FunctionBody(7985, 7976, "{\n        _addMilestones(_milestones, bytes32(0));\n    }");
insert Statement(7986, 7985, "_addMilestones(_milestones, bytes32(0));");
insert ExpressionStatement(7987, 7986, "_addMilestones(_milestones, bytes32(0));");
insert Expression(7988, 7987, "_addMilestones(_milestones, bytes32(0))");
insert CallExpression(7989, 7988, "_addMilestones(_milestones, bytes32(0))");
insert Expression(7990, 7989, "_addMilestones");
insert Identifier(7991, 7990, "_addMilestones");
insert CallArgument(7992, 7989, "_milestones");
insert Expression(7993, 7992, "_milestones");
insert Identifier(7994, 7993, "_milestones");
insert CallArgument(7995, 7989, "bytes32(0)");
insert Expression(7996, 7995, "bytes32(0)");
insert TypeCastExpression(7997, 7996, "bytes32(0)");
insert PrimitiveType(7998, 7997, "bytes32");
insert CallArgument(7999, 7997, "0");
insert Expression(8000, 7999, "0");
insert NumberLiteral(8001, 8000, "0");
insert Comment(8002, 7306, "/**\n     * @dev Adds milestones with extra details.\n     * @param _milestones The array of new milestones to be added\n     * @param _details Additional details for the milestones\n     */");
insert FunctionDefinition(8003, 7306, "function addMilestones(\n        uint256[] calldata _milestones,\n        bytes32 _details\n    ) external override {\n        _addMilestones(_milestones, _details);\n    }");
insert Identifier(8004, 8003, "addMilestones");
insert Parameter(8005, 8003, "uint256[] calldata _milestones");
insert TypeName(8006, 8005, "uint256[]");
insert TypeName(8007, 8006, "uint256");
insert PrimitiveType(8008, 8007, "uint256");
insert Identifier(8009, 8005, "_milestones");
insert Parameter(8010, 8003, "bytes32 _details");
insert TypeName(8011, 8010, "bytes32");
insert PrimitiveType(8012, 8011, "bytes32");
insert Identifier(8013, 8010, "_details");
insert Visibility(8014, 8003, "external");
insert OverrideSpecifier(8015, 8003, "override");
insert FunctionBody(8016, 8003, "{\n        _addMilestones(_milestones, _details);\n    }");
insert Statement(8017, 8016, "_addMilestones(_milestones, _details);");
insert ExpressionStatement(8018, 8017, "_addMilestones(_milestones, _details);");
insert Expression(8019, 8018, "_addMilestones(_milestones, _details)");
insert CallExpression(8020, 8019, "_addMilestones(_milestones, _details)");
insert Expression(8021, 8020, "_addMilestones");
insert Identifier(8022, 8021, "_addMilestones");
insert CallArgument(8023, 8020, "_milestones");
insert Expression(8024, 8023, "_milestones");
insert Identifier(8025, 8024, "_milestones");
insert CallArgument(8026, 8020, "_details");
insert Expression(8027, 8026, "_details");
insert Identifier(8028, 8027, "_details");
insert Comment(8029, 7306, "/**\n     * @dev Internal function to add milestones and update the contract state.\n     * @param _milestones The array of new milestones to be added\n     * @param _details Additional details for the milestones\n     */");
insert FunctionDefinition(8030, 7306, "function _addMilestones(\n        uint256[] calldata _milestones,\n        bytes32 _details\n    ) internal {\n        if (locked) revert Locked();\n        if (block.timestamp >= terminationTime) revert Terminated();\n        if (_msgSender() != client && _msgSender() != provider)\n            revert NotParty();\n        if (_milestones.length == 0) revert NoMilestones();\n        if (_milestones.length > 10) revert ExceedsMilestoneLimit();\n\n        uint256 newLength = amounts.length + _milestones.length;\n        uint256[] memory baseArray = new uint256[](newLength);\n        uint256 newTotal = total;\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            baseArray[i] = amounts[i];\n        }\n        for (uint256 i = amounts.length; i < newLength; i++) {\n            baseArray[i] = _milestones[i - amounts.length];\n            newTotal += _milestones[i - amounts.length];\n        }\n\n        total = newTotal;\n        amounts = baseArray;\n\n        if (_details != bytes32(0)) {\n            details = _details;\n            emit DetailsUpdated(msg.sender, _details);\n        }\n\n        emit MilestonesAdded(msg.sender, address(this), _milestones);\n    }");
insert Identifier(8031, 8030, "_addMilestones");
insert Parameter(8032, 8030, "uint256[] calldata _milestones");
insert TypeName(8033, 8032, "uint256[]");
insert TypeName(8034, 8033, "uint256");
insert PrimitiveType(8035, 8034, "uint256");
insert Identifier(8036, 8032, "_milestones");
insert Parameter(8037, 8030, "bytes32 _details");
insert TypeName(8038, 8037, "bytes32");
insert PrimitiveType(8039, 8038, "bytes32");
insert Identifier(8040, 8037, "_details");
insert Visibility(8041, 8030, "internal");
insert FunctionBody(8042, 8030, "{\n        if (locked) revert Locked();\n        if (block.timestamp >= terminationTime) revert Terminated();\n        if (_msgSender() != client && _msgSender() != provider)\n            revert NotParty();\n        if (_milestones.length == 0) revert NoMilestones();\n        if (_milestones.length > 10) revert ExceedsMilestoneLimit();\n\n        uint256 newLength = amounts.length + _milestones.length;\n        uint256[] memory baseArray = new uint256[](newLength);\n        uint256 newTotal = total;\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            baseArray[i] = amounts[i];\n        }\n        for (uint256 i = amounts.length; i < newLength; i++) {\n            baseArray[i] = _milestones[i - amounts.length];\n            newTotal += _milestones[i - amounts.length];\n        }\n\n        total = newTotal;\n        amounts = baseArray;\n\n        if (_details != bytes32(0)) {\n            details = _details;\n            emit DetailsUpdated(msg.sender, _details);\n        }\n\n        emit MilestonesAdded(msg.sender, address(this), _milestones);\n    }");
insert Statement(8043, 8042, "if (locked) revert Locked();");
insert IfStatement(8044, 8043, "if (locked) revert Locked();");
insert Expression(8045, 8044, "locked");
insert Identifier(8046, 8045, "locked");
insert Statement(8047, 8044, "revert Locked();");
insert RevertStatement(8048, 8047, "revert Locked();");
insert Expression(8049, 8048, "Locked");
insert Identifier(8050, 8049, "Locked");
insert RevertArguments(8051, 8048, "()");
insert Statement(8052, 8042, "if (block.timestamp >= terminationTime) revert Terminated();");
insert IfStatement(8053, 8052, "if (block.timestamp >= terminationTime) revert Terminated();");
insert Expression(8054, 8053, "block.timestamp >= terminationTime");
insert BinaryExpression(8055, 8054, "block.timestamp >= terminationTime");
insert Expression(8056, 8055, "block.timestamp");
insert MemberExpression(8057, 8056, "block.timestamp");
insert Identifier(8058, 8057, "block");
insert Identifier(8059, 8057, "timestamp");
insert Expression(8060, 8055, "terminationTime");
insert Identifier(8061, 8060, "terminationTime");
insert Statement(8062, 8053, "revert Terminated();");
insert RevertStatement(8063, 8062, "revert Terminated();");
insert Expression(8064, 8063, "Terminated");
insert Identifier(8065, 8064, "Terminated");
insert RevertArguments(8066, 8063, "()");
insert Statement(8067, 8042, "if (_msgSender() != client && _msgSender() != provider)\n            revert NotParty();");
insert IfStatement(8068, 8067, "if (_msgSender() != client && _msgSender() != provider)\n            revert NotParty();");
insert Expression(8069, 8068, "_msgSender() != client && _msgSender() != provider");
insert BinaryExpression(8070, 8069, "_msgSender() != client && _msgSender() != provider");
insert Expression(8071, 8070, "_msgSender() != client");
insert BinaryExpression(8072, 8071, "_msgSender() != client");
insert Expression(8073, 8072, "_msgSender()");
insert CallExpression(8074, 8073, "_msgSender()");
insert Expression(8075, 8074, "_msgSender");
insert Identifier(8076, 8075, "_msgSender");
insert Expression(8077, 8072, "client");
insert Identifier(8078, 8077, "client");
insert Expression(8079, 8070, "_msgSender() != provider");
insert BinaryExpression(8080, 8079, "_msgSender() != provider");
insert Expression(8081, 8080, "_msgSender()");
insert CallExpression(8082, 8081, "_msgSender()");
insert Expression(8083, 8082, "_msgSender");
insert Identifier(8084, 8083, "_msgSender");
insert Expression(8085, 8080, "provider");
insert Identifier(8086, 8085, "provider");
insert Statement(8087, 8068, "revert NotParty();");
insert RevertStatement(8088, 8087, "revert NotParty();");
insert Expression(8089, 8088, "NotParty");
insert Identifier(8090, 8089, "NotParty");
insert RevertArguments(8091, 8088, "()");
insert Statement(8092, 8042, "if (_milestones.length == 0) revert NoMilestones();");
insert IfStatement(8093, 8092, "if (_milestones.length == 0) revert NoMilestones();");
insert Expression(8094, 8093, "_milestones.length == 0");
insert BinaryExpression(8095, 8094, "_milestones.length == 0");
insert Expression(8096, 8095, "_milestones.length");
insert MemberExpression(8097, 8096, "_milestones.length");
insert Identifier(8098, 8097, "_milestones");
insert Identifier(8099, 8097, "length");
insert Expression(8100, 8095, "0");
insert NumberLiteral(8101, 8100, "0");
insert Statement(8102, 8093, "revert NoMilestones();");
insert RevertStatement(8103, 8102, "revert NoMilestones();");
insert Expression(8104, 8103, "NoMilestones");
insert Identifier(8105, 8104, "NoMilestones");
insert RevertArguments(8106, 8103, "()");
insert Statement(8107, 8042, "if (_milestones.length > 10) revert ExceedsMilestoneLimit();");
insert IfStatement(8108, 8107, "if (_milestones.length > 10) revert ExceedsMilestoneLimit();");
insert Expression(8109, 8108, "_milestones.length > 10");
insert BinaryExpression(8110, 8109, "_milestones.length > 10");
insert Expression(8111, 8110, "_milestones.length");
insert MemberExpression(8112, 8111, "_milestones.length");
insert Identifier(8113, 8112, "_milestones");
insert Identifier(8114, 8112, "length");
insert Expression(8115, 8110, "10");
insert NumberLiteral(8116, 8115, "10");
insert Statement(8117, 8108, "revert ExceedsMilestoneLimit();");
insert RevertStatement(8118, 8117, "revert ExceedsMilestoneLimit();");
insert Expression(8119, 8118, "ExceedsMilestoneLimit");
insert Identifier(8120, 8119, "ExceedsMilestoneLimit");
insert RevertArguments(8121, 8118, "()");
insert Statement(8122, 8042, "uint256 newLength = amounts.length + _milestones.length;");
insert VariableDeclarationStatement(8123, 8122, "uint256 newLength = amounts.length + _milestones.length;");
insert VariableDeclaration(8124, 8123, "uint256 newLength");
insert TypeName(8125, 8124, "uint256");
insert PrimitiveType(8126, 8125, "uint256");
insert Identifier(8127, 8124, "newLength");
insert Expression(8128, 8123, "amounts.length + _milestones.length");
insert BinaryExpression(8129, 8128, "amounts.length + _milestones.length");
insert Expression(8130, 8129, "amounts.length");
insert MemberExpression(8131, 8130, "amounts.length");
insert Identifier(8132, 8131, "amounts");
insert Identifier(8133, 8131, "length");
insert Expression(8134, 8129, "_milestones.length");
insert MemberExpression(8135, 8134, "_milestones.length");
insert Identifier(8136, 8135, "_milestones");
insert Identifier(8137, 8135, "length");
insert Statement(8138, 8042, "uint256[] memory baseArray = new uint256[](newLength);");
insert VariableDeclarationStatement(8139, 8138, "uint256[] memory baseArray = new uint256[](newLength);");
insert VariableDeclaration(8140, 8139, "uint256[] memory baseArray");
insert TypeName(8141, 8140, "uint256[]");
insert TypeName(8142, 8141, "uint256");
insert PrimitiveType(8143, 8142, "uint256");
insert Identifier(8144, 8140, "baseArray");
insert Expression(8145, 8139, "new uint256[](newLength)");
insert CallExpression(8146, 8145, "new uint256[](newLength)");
insert Expression(8147, 8146, "new uint256[]");
insert NewExpression(8148, 8147, "new uint256[]");
insert TypeName(8149, 8148, "uint256[]");
insert TypeName(8150, 8149, "uint256");
insert PrimitiveType(8151, 8150, "uint256");
insert CallArgument(8152, 8146, "newLength");
insert Expression(8153, 8152, "newLength");
insert Identifier(8154, 8153, "newLength");
insert Statement(8155, 8042, "uint256 newTotal = total;");
insert VariableDeclarationStatement(8156, 8155, "uint256 newTotal = total;");
insert VariableDeclaration(8157, 8156, "uint256 newTotal");
insert TypeName(8158, 8157, "uint256");
insert PrimitiveType(8159, 8158, "uint256");
insert Identifier(8160, 8157, "newTotal");
insert Expression(8161, 8156, "total");
insert Identifier(8162, 8161, "total");
insert Statement(8163, 8042, "for (uint256 i = 0; i < amounts.length; i++) {\n            baseArray[i] = amounts[i];\n        }");
insert ForStatement(8164, 8163, "for (uint256 i = 0; i < amounts.length; i++) {\n            baseArray[i] = amounts[i];\n        }");
insert VariableDeclarationStatement(8165, 8164, "uint256 i = 0;");
insert VariableDeclaration(8166, 8165, "uint256 i");
insert TypeName(8167, 8166, "uint256");
insert PrimitiveType(8168, 8167, "uint256");
insert Identifier(8169, 8166, "i");
insert Expression(8170, 8165, "0");
insert NumberLiteral(8171, 8170, "0");
insert ExpressionStatement(8172, 8164, "i < amounts.length;");
insert Expression(8173, 8172, "i < amounts.length");
insert BinaryExpression(8174, 8173, "i < amounts.length");
insert Expression(8175, 8174, "i");
insert Identifier(8176, 8175, "i");
insert Expression(8177, 8174, "amounts.length");
insert MemberExpression(8178, 8177, "amounts.length");
insert Identifier(8179, 8178, "amounts");
insert Identifier(8180, 8178, "length");
insert Expression(8181, 8164, "i++");
insert UpdateExpression(8182, 8181, "i++");
insert Expression(8183, 8182, "i");
insert Identifier(8184, 8183, "i");
insert Statement(8185, 8164, "{\n            baseArray[i] = amounts[i];\n        }");
insert BlockStatement(8186, 8185, "{\n            baseArray[i] = amounts[i];\n        }");
insert Statement(8187, 8186, "baseArray[i] = amounts[i];");
insert ExpressionStatement(8188, 8187, "baseArray[i] = amounts[i];");
insert Expression(8189, 8188, "baseArray[i] = amounts[i]");
insert AssignmentExpression(8190, 8189, "baseArray[i] = amounts[i]");
insert Expression(8191, 8190, "baseArray[i]");
insert ArrayAccess(8192, 8191, "baseArray[i]");
insert Expression(8193, 8192, "baseArray");
insert Identifier(8194, 8193, "baseArray");
insert Expression(8195, 8192, "i");
insert Identifier(8196, 8195, "i");
insert Expression(8197, 8190, "amounts[i]");
insert ArrayAccess(8198, 8197, "amounts[i]");
insert Expression(8199, 8198, "amounts");
insert Identifier(8200, 8199, "amounts");
insert Expression(8201, 8198, "i");
insert Identifier(8202, 8201, "i");
insert Statement(8203, 8042, "for (uint256 i = amounts.length; i < newLength; i++) {\n            baseArray[i] = _milestones[i - amounts.length];\n            newTotal += _milestones[i - amounts.length];\n        }");
insert ForStatement(8204, 8203, "for (uint256 i = amounts.length; i < newLength; i++) {\n            baseArray[i] = _milestones[i - amounts.length];\n            newTotal += _milestones[i - amounts.length];\n        }");
insert VariableDeclarationStatement(8205, 8204, "uint256 i = amounts.length;");
insert VariableDeclaration(8206, 8205, "uint256 i");
insert TypeName(8207, 8206, "uint256");
insert PrimitiveType(8208, 8207, "uint256");
insert Identifier(8209, 8206, "i");
insert Expression(8210, 8205, "amounts.length");
insert MemberExpression(8211, 8210, "amounts.length");
insert Identifier(8212, 8211, "amounts");
insert Identifier(8213, 8211, "length");
insert ExpressionStatement(8214, 8204, "i < newLength;");
insert Expression(8215, 8214, "i < newLength");
insert BinaryExpression(8216, 8215, "i < newLength");
insert Expression(8217, 8216, "i");
insert Identifier(8218, 8217, "i");
insert Expression(8219, 8216, "newLength");
insert Identifier(8220, 8219, "newLength");
insert Expression(8221, 8204, "i++");
insert UpdateExpression(8222, 8221, "i++");
insert Expression(8223, 8222, "i");
insert Identifier(8224, 8223, "i");
insert Statement(8225, 8204, "{\n            baseArray[i] = _milestones[i - amounts.length];\n            newTotal += _milestones[i - amounts.length];\n        }");
insert BlockStatement(8226, 8225, "{\n            baseArray[i] = _milestones[i - amounts.length];\n            newTotal += _milestones[i - amounts.length];\n        }");
insert Statement(8227, 8226, "baseArray[i] = _milestones[i - amounts.length];");
insert ExpressionStatement(8228, 8227, "baseArray[i] = _milestones[i - amounts.length];");
insert Expression(8229, 8228, "baseArray[i] = _milestones[i - amounts.length]");
insert AssignmentExpression(8230, 8229, "baseArray[i] = _milestones[i - amounts.length]");
insert Expression(8231, 8230, "baseArray[i]");
insert ArrayAccess(8232, 8231, "baseArray[i]");
insert Expression(8233, 8232, "baseArray");
insert Identifier(8234, 8233, "baseArray");
insert Expression(8235, 8232, "i");
insert Identifier(8236, 8235, "i");
insert Expression(8237, 8230, "_milestones[i - amounts.length]");
insert ArrayAccess(8238, 8237, "_milestones[i - amounts.length]");
insert Expression(8239, 8238, "_milestones");
insert Identifier(8240, 8239, "_milestones");
insert Expression(8241, 8238, "i - amounts.length");
insert BinaryExpression(8242, 8241, "i - amounts.length");
insert Expression(8243, 8242, "i");
insert Identifier(8244, 8243, "i");
insert Expression(8245, 8242, "amounts.length");
insert MemberExpression(8246, 8245, "amounts.length");
insert Identifier(8247, 8246, "amounts");
insert Identifier(8248, 8246, "length");
insert Statement(8249, 8226, "newTotal += _milestones[i - amounts.length];");
insert ExpressionStatement(8250, 8249, "newTotal += _milestones[i - amounts.length];");
insert Expression(8251, 8250, "newTotal += _milestones[i - amounts.length]");
insert AugmentedAssignmentExpression(8252, 8251, "newTotal += _milestones[i - amounts.length]");
insert Expression(8253, 8252, "newTotal");
insert Identifier(8254, 8253, "newTotal");
insert Expression(8255, 8252, "_milestones[i - amounts.length]");
insert ArrayAccess(8256, 8255, "_milestones[i - amounts.length]");
insert Expression(8257, 8256, "_milestones");
insert Identifier(8258, 8257, "_milestones");
insert Expression(8259, 8256, "i - amounts.length");
insert BinaryExpression(8260, 8259, "i - amounts.length");
insert Expression(8261, 8260, "i");
insert Identifier(8262, 8261, "i");
insert Expression(8263, 8260, "amounts.length");
insert MemberExpression(8264, 8263, "amounts.length");
insert Identifier(8265, 8264, "amounts");
insert Identifier(8266, 8264, "length");
insert Statement(8267, 8042, "total = newTotal;");
insert ExpressionStatement(8268, 8267, "total = newTotal;");
insert Expression(8269, 8268, "total = newTotal");
insert AssignmentExpression(8270, 8269, "total = newTotal");
insert Expression(8271, 8270, "total");
insert Identifier(8272, 8271, "total");
insert Expression(8273, 8270, "newTotal");
insert Identifier(8274, 8273, "newTotal");
insert Statement(8275, 8042, "amounts = baseArray;");
insert ExpressionStatement(8276, 8275, "amounts = baseArray;");
insert Expression(8277, 8276, "amounts = baseArray");
insert AssignmentExpression(8278, 8277, "amounts = baseArray");
insert Expression(8279, 8278, "amounts");
insert Identifier(8280, 8279, "amounts");
insert Expression(8281, 8278, "baseArray");
insert Identifier(8282, 8281, "baseArray");
insert Statement(8283, 8042, "if (_details != bytes32(0)) {\n            details = _details;\n            emit DetailsUpdated(msg.sender, _details);\n        }");
insert IfStatement(8284, 8283, "if (_details != bytes32(0)) {\n            details = _details;\n            emit DetailsUpdated(msg.sender, _details);\n        }");
insert Expression(8285, 8284, "_details != bytes32(0)");
insert BinaryExpression(8286, 8285, "_details != bytes32(0)");
insert Expression(8287, 8286, "_details");
insert Identifier(8288, 8287, "_details");
insert Expression(8289, 8286, "bytes32(0)");
insert TypeCastExpression(8290, 8289, "bytes32(0)");
insert PrimitiveType(8291, 8290, "bytes32");
insert CallArgument(8292, 8290, "0");
insert Expression(8293, 8292, "0");
insert NumberLiteral(8294, 8293, "0");
insert Statement(8295, 8284, "{\n            details = _details;\n            emit DetailsUpdated(msg.sender, _details);\n        }");
insert BlockStatement(8296, 8295, "{\n            details = _details;\n            emit DetailsUpdated(msg.sender, _details);\n        }");
insert Statement(8297, 8296, "details = _details;");
insert ExpressionStatement(8298, 8297, "details = _details;");
insert Expression(8299, 8298, "details = _details");
insert AssignmentExpression(8300, 8299, "details = _details");
insert Expression(8301, 8300, "details");
insert Identifier(8302, 8301, "details");
insert Expression(8303, 8300, "_details");
insert Identifier(8304, 8303, "_details");
insert Statement(8305, 8296, "emit DetailsUpdated(msg.sender, _details);");
insert EmitStatement(8306, 8305, "emit DetailsUpdated(msg.sender, _details);");
insert Expression(8307, 8306, "DetailsUpdated");
insert Identifier(8308, 8307, "DetailsUpdated");
insert CallArgument(8309, 8306, "msg.sender");
insert Expression(8310, 8309, "msg.sender");
insert MemberExpression(8311, 8310, "msg.sender");
insert Identifier(8312, 8311, "msg");
insert Identifier(8313, 8311, "sender");
insert CallArgument(8314, 8306, "_details");
insert Expression(8315, 8314, "_details");
insert Identifier(8316, 8315, "_details");
insert Statement(8317, 8042, "emit MilestonesAdded(msg.sender, address(this), _milestones);");
insert EmitStatement(8318, 8317, "emit MilestonesAdded(msg.sender, address(this), _milestones);");
insert Expression(8319, 8318, "MilestonesAdded");
insert Identifier(8320, 8319, "MilestonesAdded");
insert CallArgument(8321, 8318, "msg.sender");
insert Expression(8322, 8321, "msg.sender");
insert MemberExpression(8323, 8322, "msg.sender");
insert Identifier(8324, 8323, "msg");
insert Identifier(8325, 8323, "sender");
insert CallArgument(8326, 8318, "address(this)");
insert Expression(8327, 8326, "address(this)");
insert TypeCastExpression(8328, 8327, "address(this)");
insert PrimitiveType(8329, 8328, "address");
insert CallArgument(8330, 8328, "this");
insert Expression(8331, 8330, "this");
insert Identifier(8332, 8331, "this");
insert CallArgument(8333, 8318, "_milestones");
insert Expression(8334, 8333, "_milestones");
insert Identifier(8335, 8334, "_milestones");
insert Comment(8336, 7306, "/**\n     * @dev Returns the amounts associated with the milestones.\n     * @return An array of amounts for each milestone\n     */");
insert FunctionDefinition(8337, 7306, "function getAmounts() public view returns (uint256[] memory) {\n        return amounts;\n    }");
insert Identifier(8338, 8337, "getAmounts");
insert Visibility(8339, 8337, "public");
insert StateMutability(8340, 8337, "view");
insert ReturnTypeDefinition(8341, 8337, "returns (uint256[] memory)");
insert Parameter(8342, 8341, "uint256[] memory");
insert TypeName(8343, 8342, "uint256[]");
insert TypeName(8344, 8343, "uint256");
insert PrimitiveType(8345, 8344, "uint256");
insert FunctionBody(8346, 8337, "{\n        return amounts;\n    }");
insert Statement(8347, 8346, "return amounts;");
insert ReturnStatement(8348, 8347, "return amounts;");
insert Expression(8349, 8348, "amounts");
insert Identifier(8350, 8349, "amounts");
insert Comment(8351, 7306, "/**\n     * @dev Internal function to release funds from the contract to the provider.\n     */");
insert FunctionDefinition(8352, 7306, "function _release() internal virtual {\n        if (locked) revert Locked();\n        if (_msgSender() != client) revert NotClient();\n\n        uint256 currentMilestone = milestone;\n        uint256 balance = IERC20(token).balanceOf(address(this));\n\n        if (currentMilestone < amounts.length) {\n            uint256 amount = amounts[currentMilestone];\n            if (currentMilestone == amounts.length - 1 && amount < balance) {\n                amount = balance;\n            }\n            if (balance < amount) revert InsufficientBalance();\n\n            milestone = milestone + 1;\n            _transferPayment(token, amount);\n            released = released + amount;\n            emit Release(currentMilestone, amount);\n        } else {\n            if (balance == 0) revert BalanceIsZero();\n\n            _transferPayment(token, balance);\n            released = released + balance;\n            emit Release(currentMilestone, balance);\n        }\n    }");
insert Identifier(8353, 8352, "_release");
insert Visibility(8354, 8352, "internal");
insert Virtual(8355, 8352, "virtual");
insert FunctionBody(8356, 8352, "{\n        if (locked) revert Locked();\n        if (_msgSender() != client) revert NotClient();\n\n        uint256 currentMilestone = milestone;\n        uint256 balance = IERC20(token).balanceOf(address(this));\n\n        if (currentMilestone < amounts.length) {\n            uint256 amount = amounts[currentMilestone];\n            if (currentMilestone == amounts.length - 1 && amount < balance) {\n                amount = balance;\n            }\n            if (balance < amount) revert InsufficientBalance();\n\n            milestone = milestone + 1;\n            _transferPayment(token, amount);\n            released = released + amount;\n            emit Release(currentMilestone, amount);\n        } else {\n            if (balance == 0) revert BalanceIsZero();\n\n            _transferPayment(token, balance);\n            released = released + balance;\n            emit Release(currentMilestone, balance);\n        }\n    }");
insert Statement(8357, 8356, "if (locked) revert Locked();");
insert IfStatement(8358, 8357, "if (locked) revert Locked();");
insert Expression(8359, 8358, "locked");
insert Identifier(8360, 8359, "locked");
insert Statement(8361, 8358, "revert Locked();");
insert RevertStatement(8362, 8361, "revert Locked();");
insert Expression(8363, 8362, "Locked");
insert Identifier(8364, 8363, "Locked");
insert RevertArguments(8365, 8362, "()");
insert Statement(8366, 8356, "if (_msgSender() != client) revert NotClient();");
insert IfStatement(8367, 8366, "if (_msgSender() != client) revert NotClient();");
insert Expression(8368, 8367, "_msgSender() != client");
insert BinaryExpression(8369, 8368, "_msgSender() != client");
insert Expression(8370, 8369, "_msgSender()");
insert CallExpression(8371, 8370, "_msgSender()");
insert Expression(8372, 8371, "_msgSender");
insert Identifier(8373, 8372, "_msgSender");
insert Expression(8374, 8369, "client");
insert Identifier(8375, 8374, "client");
insert Statement(8376, 8367, "revert NotClient();");
insert RevertStatement(8377, 8376, "revert NotClient();");
insert Expression(8378, 8377, "NotClient");
insert Identifier(8379, 8378, "NotClient");
insert RevertArguments(8380, 8377, "()");
insert Statement(8381, 8356, "uint256 currentMilestone = milestone;");
insert VariableDeclarationStatement(8382, 8381, "uint256 currentMilestone = milestone;");
insert VariableDeclaration(8383, 8382, "uint256 currentMilestone");
insert TypeName(8384, 8383, "uint256");
insert PrimitiveType(8385, 8384, "uint256");
insert Identifier(8386, 8383, "currentMilestone");
insert Expression(8387, 8382, "milestone");
insert Identifier(8388, 8387, "milestone");
insert Statement(8389, 8356, "uint256 balance = IERC20(token).balanceOf(address(this));");
insert VariableDeclarationStatement(8390, 8389, "uint256 balance = IERC20(token).balanceOf(address(this));");
insert VariableDeclaration(8391, 8390, "uint256 balance");
insert TypeName(8392, 8391, "uint256");
insert PrimitiveType(8393, 8392, "uint256");
insert Identifier(8394, 8391, "balance");
insert Expression(8395, 8390, "IERC20(token).balanceOf(address(this))");
insert CallExpression(8396, 8395, "IERC20(token).balanceOf(address(this))");
insert Expression(8397, 8396, "IERC20(token).balanceOf");
insert MemberExpression(8398, 8397, "IERC20(token).balanceOf");
insert Expression(8399, 8398, "IERC20(token)");
insert CallExpression(8400, 8399, "IERC20(token)");
insert Expression(8401, 8400, "IERC20");
insert Identifier(8402, 8401, "IERC20");
insert CallArgument(8403, 8400, "token");
insert Expression(8404, 8403, "token");
insert Identifier(8405, 8404, "token");
insert Identifier(8406, 8398, "balanceOf");
insert CallArgument(8407, 8396, "address(this)");
insert Expression(8408, 8407, "address(this)");
insert TypeCastExpression(8409, 8408, "address(this)");
insert PrimitiveType(8410, 8409, "address");
insert CallArgument(8411, 8409, "this");
insert Expression(8412, 8411, "this");
insert Identifier(8413, 8412, "this");
insert Statement(8414, 8356, "if (currentMilestone < amounts.length) {\n            uint256 amount = amounts[currentMilestone];\n            if (currentMilestone == amounts.length - 1 && amount < balance) {\n                amount = balance;\n            }\n            if (balance < amount) revert InsufficientBalance();\n\n            milestone = milestone + 1;\n            _transferPayment(token, amount);\n            released = released + amount;\n            emit Release(currentMilestone, amount);\n        } else {\n            if (balance == 0) revert BalanceIsZero();\n\n            _transferPayment(token, balance);\n            released = released + balance;\n            emit Release(currentMilestone, balance);\n        }");
insert IfStatement(8415, 8414, "if (currentMilestone < amounts.length) {\n            uint256 amount = amounts[currentMilestone];\n            if (currentMilestone == amounts.length - 1 && amount < balance) {\n                amount = balance;\n            }\n            if (balance < amount) revert InsufficientBalance();\n\n            milestone = milestone + 1;\n            _transferPayment(token, amount);\n            released = released + amount;\n            emit Release(currentMilestone, amount);\n        } else {\n            if (balance == 0) revert BalanceIsZero();\n\n            _transferPayment(token, balance);\n            released = released + balance;\n            emit Release(currentMilestone, balance);\n        }");
insert Expression(8416, 8415, "currentMilestone < amounts.length");
insert BinaryExpression(8417, 8416, "currentMilestone < amounts.length");
insert Expression(8418, 8417, "currentMilestone");
insert Identifier(8419, 8418, "currentMilestone");
insert Expression(8420, 8417, "amounts.length");
insert MemberExpression(8421, 8420, "amounts.length");
insert Identifier(8422, 8421, "amounts");
insert Identifier(8423, 8421, "length");
insert Statement(8424, 8415, "{\n            uint256 amount = amounts[currentMilestone];\n            if (currentMilestone == amounts.length - 1 && amount < balance) {\n                amount = balance;\n            }\n            if (balance < amount) revert InsufficientBalance();\n\n            milestone = milestone + 1;\n            _transferPayment(token, amount);\n            released = released + amount;\n            emit Release(currentMilestone, amount);\n        }");
insert BlockStatement(8425, 8424, "{\n            uint256 amount = amounts[currentMilestone];\n            if (currentMilestone == amounts.length - 1 && amount < balance) {\n                amount = balance;\n            }\n            if (balance < amount) revert InsufficientBalance();\n\n            milestone = milestone + 1;\n            _transferPayment(token, amount);\n            released = released + amount;\n            emit Release(currentMilestone, amount);\n        }");
insert Statement(8426, 8425, "uint256 amount = amounts[currentMilestone];");
insert VariableDeclarationStatement(8427, 8426, "uint256 amount = amounts[currentMilestone];");
insert VariableDeclaration(8428, 8427, "uint256 amount");
insert TypeName(8429, 8428, "uint256");
insert PrimitiveType(8430, 8429, "uint256");
insert Identifier(8431, 8428, "amount");
insert Expression(8432, 8427, "amounts[currentMilestone]");
insert ArrayAccess(8433, 8432, "amounts[currentMilestone]");
insert Expression(8434, 8433, "amounts");
insert Identifier(8435, 8434, "amounts");
insert Expression(8436, 8433, "currentMilestone");
insert Identifier(8437, 8436, "currentMilestone");
insert Statement(8438, 8425, "if (currentMilestone == amounts.length - 1 && amount < balance) {\n                amount = balance;\n            }");
insert IfStatement(8439, 8438, "if (currentMilestone == amounts.length - 1 && amount < balance) {\n                amount = balance;\n            }");
insert Expression(8440, 8439, "currentMilestone == amounts.length - 1 && amount < balance");
insert BinaryExpression(8441, 8440, "currentMilestone == amounts.length - 1 && amount < balance");
insert Expression(8442, 8441, "currentMilestone == amounts.length - 1");
insert BinaryExpression(8443, 8442, "currentMilestone == amounts.length - 1");
insert Expression(8444, 8443, "currentMilestone == amounts.length");
insert MemberExpression(8445, 8444, "currentMilestone == amounts.length");
insert Expression(8446, 8445, "currentMilestone == amounts");
insert BinaryExpression(8447, 8446, "currentMilestone == amounts");
insert Expression(8448, 8447, "currentMilestone");
insert Identifier(8449, 8448, "currentMilestone");
insert Expression(8450, 8447, "amounts");
insert Identifier(8451, 8450, "amounts");
insert Identifier(8452, 8445, "length");
insert Expression(8453, 8443, "1");
insert NumberLiteral(8454, 8453, "1");
insert Expression(8455, 8441, "amount < balance");
insert BinaryExpression(8456, 8455, "amount < balance");
insert Expression(8457, 8456, "amount");
insert Identifier(8458, 8457, "amount");
insert Expression(8459, 8456, "balance");
insert Identifier(8460, 8459, "balance");
insert Statement(8461, 8439, "{\n                amount = balance;\n            }");
insert BlockStatement(8462, 8461, "{\n                amount = balance;\n            }");
insert Statement(8463, 8462, "amount = balance;");
insert ExpressionStatement(8464, 8463, "amount = balance;");
insert Expression(8465, 8464, "amount = balance");
insert AssignmentExpression(8466, 8465, "amount = balance");
insert Expression(8467, 8466, "amount");
insert Identifier(8468, 8467, "amount");
insert Expression(8469, 8466, "balance");
insert Identifier(8470, 8469, "balance");
insert Statement(8471, 8425, "if (balance < amount) revert InsufficientBalance();");
insert IfStatement(8472, 8471, "if (balance < amount) revert InsufficientBalance();");
insert Expression(8473, 8472, "balance < amount");
insert BinaryExpression(8474, 8473, "balance < amount");
insert Expression(8475, 8474, "balance");
insert Identifier(8476, 8475, "balance");
insert Expression(8477, 8474, "amount");
insert Identifier(8478, 8477, "amount");
insert Statement(8479, 8472, "revert InsufficientBalance();");
insert RevertStatement(8480, 8479, "revert InsufficientBalance();");
insert Expression(8481, 8480, "InsufficientBalance");
insert Identifier(8482, 8481, "InsufficientBalance");
insert RevertArguments(8483, 8480, "()");
insert Statement(8484, 8425, "milestone = milestone + 1;");
insert ExpressionStatement(8485, 8484, "milestone = milestone + 1;");
insert Expression(8486, 8485, "milestone = milestone + 1");
insert AssignmentExpression(8487, 8486, "milestone = milestone + 1");
insert Expression(8488, 8487, "milestone");
insert Identifier(8489, 8488, "milestone");
insert Expression(8490, 8487, "milestone + 1");
insert BinaryExpression(8491, 8490, "milestone + 1");
insert Expression(8492, 8491, "milestone");
insert Identifier(8493, 8492, "milestone");
insert Expression(8494, 8491, "1");
insert NumberLiteral(8495, 8494, "1");
insert Statement(8496, 8425, "_transferPayment(token, amount);");
insert ExpressionStatement(8497, 8496, "_transferPayment(token, amount);");
insert Expression(8498, 8497, "_transferPayment(token, amount)");
insert CallExpression(8499, 8498, "_transferPayment(token, amount)");
insert Expression(8500, 8499, "_transferPayment");
insert Identifier(8501, 8500, "_transferPayment");
insert CallArgument(8502, 8499, "token");
insert Expression(8503, 8502, "token");
insert Identifier(8504, 8503, "token");
insert CallArgument(8505, 8499, "amount");
insert Expression(8506, 8505, "amount");
insert Identifier(8507, 8506, "amount");
insert Statement(8508, 8425, "released = released + amount;");
insert ExpressionStatement(8509, 8508, "released = released + amount;");
insert Expression(8510, 8509, "released = released + amount");
insert AssignmentExpression(8511, 8510, "released = released + amount");
insert Expression(8512, 8511, "released");
insert Identifier(8513, 8512, "released");
insert Expression(8514, 8511, "released + amount");
insert BinaryExpression(8515, 8514, "released + amount");
insert Expression(8516, 8515, "released");
insert Identifier(8517, 8516, "released");
insert Expression(8518, 8515, "amount");
insert Identifier(8519, 8518, "amount");
insert Statement(8520, 8425, "emit Release(currentMilestone, amount);");
insert EmitStatement(8521, 8520, "emit Release(currentMilestone, amount);");
insert Expression(8522, 8521, "Release");
insert Identifier(8523, 8522, "Release");
insert CallArgument(8524, 8521, "currentMilestone");
insert Expression(8525, 8524, "currentMilestone");
insert Identifier(8526, 8525, "currentMilestone");
insert CallArgument(8527, 8521, "amount");
insert Expression(8528, 8527, "amount");
insert Identifier(8529, 8528, "amount");
insert Statement(8530, 8415, "{\n            if (balance == 0) revert BalanceIsZero();\n\n            _transferPayment(token, balance);\n            released = released + balance;\n            emit Release(currentMilestone, balance);\n        }");
insert BlockStatement(8531, 8530, "{\n            if (balance == 0) revert BalanceIsZero();\n\n            _transferPayment(token, balance);\n            released = released + balance;\n            emit Release(currentMilestone, balance);\n        }");
insert Statement(8532, 8531, "if (balance == 0) revert BalanceIsZero();");
insert IfStatement(8533, 8532, "if (balance == 0) revert BalanceIsZero();");
insert Expression(8534, 8533, "balance == 0");
insert BinaryExpression(8535, 8534, "balance == 0");
insert Expression(8536, 8535, "balance");
insert Identifier(8537, 8536, "balance");
insert Expression(8538, 8535, "0");
insert NumberLiteral(8539, 8538, "0");
insert Statement(8540, 8533, "revert BalanceIsZero();");
insert RevertStatement(8541, 8540, "revert BalanceIsZero();");
insert Expression(8542, 8541, "BalanceIsZero");
insert Identifier(8543, 8542, "BalanceIsZero");
insert RevertArguments(8544, 8541, "()");
insert Statement(8545, 8531, "_transferPayment(token, balance);");
insert ExpressionStatement(8546, 8545, "_transferPayment(token, balance);");
insert Expression(8547, 8546, "_transferPayment(token, balance)");
insert CallExpression(8548, 8547, "_transferPayment(token, balance)");
insert Expression(8549, 8548, "_transferPayment");
insert Identifier(8550, 8549, "_transferPayment");
insert CallArgument(8551, 8548, "token");
insert Expression(8552, 8551, "token");
insert Identifier(8553, 8552, "token");
insert CallArgument(8554, 8548, "balance");
insert Expression(8555, 8554, "balance");
insert Identifier(8556, 8555, "balance");
insert Statement(8557, 8531, "released = released + balance;");
insert ExpressionStatement(8558, 8557, "released = released + balance;");
insert Expression(8559, 8558, "released = released + balance");
insert AssignmentExpression(8560, 8559, "released = released + balance");
insert Expression(8561, 8560, "released");
insert Identifier(8562, 8561, "released");
insert Expression(8563, 8560, "released + balance");
insert BinaryExpression(8564, 8563, "released + balance");
insert Expression(8565, 8564, "released");
insert Identifier(8566, 8565, "released");
insert Expression(8567, 8564, "balance");
insert Identifier(8568, 8567, "balance");
insert Statement(8569, 8531, "emit Release(currentMilestone, balance);");
insert EmitStatement(8570, 8569, "emit Release(currentMilestone, balance);");
insert Expression(8571, 8570, "Release");
insert Identifier(8572, 8571, "Release");
insert CallArgument(8573, 8570, "currentMilestone");
insert Expression(8574, 8573, "currentMilestone");
insert Identifier(8575, 8574, "currentMilestone");
insert CallArgument(8576, 8570, "balance");
insert Expression(8577, 8576, "balance");
insert Identifier(8578, 8577, "balance");
insert Comment(8579, 7306, "/**\n     * @dev External function to release funds from the contract to the provider.\n     * Uses the internal `_release` function to perform the actual release.\n     */");
insert FunctionDefinition(8580, 7306, "function release() external virtual override nonReentrant {\n        return _release();\n    }");
insert Identifier(8581, 8580, "release");
insert Visibility(8582, 8580, "external");
insert Virtual(8583, 8580, "virtual");
insert OverrideSpecifier(8584, 8580, "override");
insert ModifierInvocation(8585, 8580, "nonReentrant");
insert Identifier(8586, 8585, "nonReentrant");
insert FunctionBody(8587, 8580, "{\n        return _release();\n    }");
insert Statement(8588, 8587, "return _release();");
insert ReturnStatement(8589, 8588, "return _release();");
insert Expression(8590, 8589, "_release()");
insert CallExpression(8591, 8590, "_release()");
insert Expression(8592, 8591, "_release");
insert Identifier(8593, 8592, "_release");
insert Comment(8594, 7306, "/**\n     * @dev External function to release funds from the contract to the provider up to a certain milestone.\n     * @param _milestone The milestone to release funds to\n     */");
insert FunctionDefinition(8595, 7306, "function release(\n        uint256 _milestone\n    ) external virtual override nonReentrant {\n        if (locked) revert Locked();\n        if (_msgSender() != client) revert NotClient();\n        if (_milestone < milestone) revert InvalidMilestone();\n        if (_milestone >= amounts.length) revert InvalidMilestone();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        uint256 amount = 0;\n        for (uint256 j = milestone; j <= _milestone; j++) {\n            if (j == amounts.length - 1 && amount + amounts[j] < balance) {\n                emit Release(j, balance - amount);\n                amount = balance;\n            } else {\n                emit Release(j, amounts[j]);\n                amount = amount + amounts[j];\n            }\n        }\n        if (balance < amount) revert InsufficientBalance();\n\n        _transferPayment(token, amount);\n        released = released + amount;\n        milestone = _milestone + 1;\n    }");
insert Identifier(8596, 8595, "release");
insert Parameter(8597, 8595, "uint256 _milestone");
insert TypeName(8598, 8597, "uint256");
insert PrimitiveType(8599, 8598, "uint256");
insert Identifier(8600, 8597, "_milestone");
insert Visibility(8601, 8595, "external");
insert Virtual(8602, 8595, "virtual");
insert OverrideSpecifier(8603, 8595, "override");
insert ModifierInvocation(8604, 8595, "nonReentrant");
insert Identifier(8605, 8604, "nonReentrant");
insert FunctionBody(8606, 8595, "{\n        if (locked) revert Locked();\n        if (_msgSender() != client) revert NotClient();\n        if (_milestone < milestone) revert InvalidMilestone();\n        if (_milestone >= amounts.length) revert InvalidMilestone();\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        uint256 amount = 0;\n        for (uint256 j = milestone; j <= _milestone; j++) {\n            if (j == amounts.length - 1 && amount + amounts[j] < balance) {\n                emit Release(j, balance - amount);\n                amount = balance;\n            } else {\n                emit Release(j, amounts[j]);\n                amount = amount + amounts[j];\n            }\n        }\n        if (balance < amount) revert InsufficientBalance();\n\n        _transferPayment(token, amount);\n        released = released + amount;\n        milestone = _milestone + 1;\n    }");
insert Statement(8607, 8606, "if (locked) revert Locked();");
insert IfStatement(8608, 8607, "if (locked) revert Locked();");
insert Expression(8609, 8608, "locked");
insert Identifier(8610, 8609, "locked");
insert Statement(8611, 8608, "revert Locked();");
insert RevertStatement(8612, 8611, "revert Locked();");
insert Expression(8613, 8612, "Locked");
insert Identifier(8614, 8613, "Locked");
insert RevertArguments(8615, 8612, "()");
insert Statement(8616, 8606, "if (_msgSender() != client) revert NotClient();");
insert IfStatement(8617, 8616, "if (_msgSender() != client) revert NotClient();");
insert Expression(8618, 8617, "_msgSender() != client");
insert BinaryExpression(8619, 8618, "_msgSender() != client");
insert Expression(8620, 8619, "_msgSender()");
insert CallExpression(8621, 8620, "_msgSender()");
insert Expression(8622, 8621, "_msgSender");
insert Identifier(8623, 8622, "_msgSender");
insert Expression(8624, 8619, "client");
insert Identifier(8625, 8624, "client");
insert Statement(8626, 8617, "revert NotClient();");
insert RevertStatement(8627, 8626, "revert NotClient();");
insert Expression(8628, 8627, "NotClient");
insert Identifier(8629, 8628, "NotClient");
insert RevertArguments(8630, 8627, "()");
insert Statement(8631, 8606, "if (_milestone < milestone) revert InvalidMilestone();");
insert IfStatement(8632, 8631, "if (_milestone < milestone) revert InvalidMilestone();");
insert Expression(8633, 8632, "_milestone < milestone");
insert BinaryExpression(8634, 8633, "_milestone < milestone");
insert Expression(8635, 8634, "_milestone");
insert Identifier(8636, 8635, "_milestone");
insert Expression(8637, 8634, "milestone");
insert Identifier(8638, 8637, "milestone");
insert Statement(8639, 8632, "revert InvalidMilestone();");
insert RevertStatement(8640, 8639, "revert InvalidMilestone();");
insert Expression(8641, 8640, "InvalidMilestone");
insert Identifier(8642, 8641, "InvalidMilestone");
insert RevertArguments(8643, 8640, "()");
insert Statement(8644, 8606, "if (_milestone >= amounts.length) revert InvalidMilestone();");
insert IfStatement(8645, 8644, "if (_milestone >= amounts.length) revert InvalidMilestone();");
insert Expression(8646, 8645, "_milestone >= amounts.length");
insert BinaryExpression(8647, 8646, "_milestone >= amounts.length");
insert Expression(8648, 8647, "_milestone");
insert Identifier(8649, 8648, "_milestone");
insert Expression(8650, 8647, "amounts.length");
insert MemberExpression(8651, 8650, "amounts.length");
insert Identifier(8652, 8651, "amounts");
insert Identifier(8653, 8651, "length");
insert Statement(8654, 8645, "revert InvalidMilestone();");
insert RevertStatement(8655, 8654, "revert InvalidMilestone();");
insert Expression(8656, 8655, "InvalidMilestone");
insert Identifier(8657, 8656, "InvalidMilestone");
insert RevertArguments(8658, 8655, "()");
insert Statement(8659, 8606, "uint256 balance = IERC20(token).balanceOf(address(this));");
insert VariableDeclarationStatement(8660, 8659, "uint256 balance = IERC20(token).balanceOf(address(this));");
insert VariableDeclaration(8661, 8660, "uint256 balance");
insert TypeName(8662, 8661, "uint256");
insert PrimitiveType(8663, 8662, "uint256");
insert Identifier(8664, 8661, "balance");
insert Expression(8665, 8660, "IERC20(token).balanceOf(address(this))");
insert CallExpression(8666, 8665, "IERC20(token).balanceOf(address(this))");
insert Expression(8667, 8666, "IERC20(token).balanceOf");
insert MemberExpression(8668, 8667, "IERC20(token).balanceOf");
insert Expression(8669, 8668, "IERC20(token)");
insert CallExpression(8670, 8669, "IERC20(token)");
insert Expression(8671, 8670, "IERC20");
insert Identifier(8672, 8671, "IERC20");
insert CallArgument(8673, 8670, "token");
insert Expression(8674, 8673, "token");
insert Identifier(8675, 8674, "token");
insert Identifier(8676, 8668, "balanceOf");
insert CallArgument(8677, 8666, "address(this)");
insert Expression(8678, 8677, "address(this)");
insert TypeCastExpression(8679, 8678, "address(this)");
insert PrimitiveType(8680, 8679, "address");
insert CallArgument(8681, 8679, "this");
insert Expression(8682, 8681, "this");
insert Identifier(8683, 8682, "this");
insert Statement(8684, 8606, "uint256 amount = 0;");
insert VariableDeclarationStatement(8685, 8684, "uint256 amount = 0;");
insert VariableDeclaration(8686, 8685, "uint256 amount");
insert TypeName(8687, 8686, "uint256");
insert PrimitiveType(8688, 8687, "uint256");
insert Identifier(8689, 8686, "amount");
insert Expression(8690, 8685, "0");
insert NumberLiteral(8691, 8690, "0");
insert Statement(8692, 8606, "for (uint256 j = milestone; j <= _milestone; j++) {\n            if (j == amounts.length - 1 && amount + amounts[j] < balance) {\n                emit Release(j, balance - amount);\n                amount = balance;\n            } else {\n                emit Release(j, amounts[j]);\n                amount = amount + amounts[j];\n            }\n        }");
insert ForStatement(8693, 8692, "for (uint256 j = milestone; j <= _milestone; j++) {\n            if (j == amounts.length - 1 && amount + amounts[j] < balance) {\n                emit Release(j, balance - amount);\n                amount = balance;\n            } else {\n                emit Release(j, amounts[j]);\n                amount = amount + amounts[j];\n            }\n        }");
insert VariableDeclarationStatement(8694, 8693, "uint256 j = milestone;");
insert VariableDeclaration(8695, 8694, "uint256 j");
insert TypeName(8696, 8695, "uint256");
insert PrimitiveType(8697, 8696, "uint256");
insert Identifier(8698, 8695, "j");
insert Expression(8699, 8694, "milestone");
insert Identifier(8700, 8699, "milestone");
insert ExpressionStatement(8701, 8693, "j <= _milestone;");
insert Expression(8702, 8701, "j <= _milestone");
insert BinaryExpression(8703, 8702, "j <= _milestone");
insert Expression(8704, 8703, "j");
insert Identifier(8705, 8704, "j");
insert Expression(8706, 8703, "_milestone");
insert Identifier(8707, 8706, "_milestone");
insert Expression(8708, 8693, "j++");
insert UpdateExpression(8709, 8708, "j++");
insert Expression(8710, 8709, "j");
insert Identifier(8711, 8710, "j");
insert Statement(8712, 8693, "{\n            if (j == amounts.length - 1 && amount + amounts[j] < balance) {\n                emit Release(j, balance - amount);\n                amount = balance;\n            } else {\n                emit Release(j, amounts[j]);\n                amount = amount + amounts[j];\n            }\n        }");
insert BlockStatement(8713, 8712, "{\n            if (j == amounts.length - 1 && amount + amounts[j] < balance) {\n                emit Release(j, balance - amount);\n                amount = balance;\n            } else {\n                emit Release(j, amounts[j]);\n                amount = amount + amounts[j];\n            }\n        }");
insert Statement(8714, 8713, "if (j == amounts.length - 1 && amount + amounts[j] < balance) {\n                emit Release(j, balance - amount);\n                amount = balance;\n            } else {\n                emit Release(j, amounts[j]);\n                amount = amount + amounts[j];\n            }");
insert IfStatement(8715, 8714, "if (j == amounts.length - 1 && amount + amounts[j] < balance) {\n                emit Release(j, balance - amount);\n                amount = balance;\n            } else {\n                emit Release(j, amounts[j]);\n                amount = amount + amounts[j];\n            }");
insert Expression(8716, 8715, "j == amounts.length - 1 && amount + amounts[j] < balance");
insert BinaryExpression(8717, 8716, "j == amounts.length - 1 && amount + amounts[j] < balance");
insert Expression(8718, 8717, "j == amounts.length - 1 && amount + amounts[j]");
insert ArrayAccess(8719, 8718, "j == amounts.length - 1 && amount + amounts[j]");
insert Expression(8720, 8719, "j == amounts.length - 1 && amount + amounts");
insert BinaryExpression(8721, 8720, "j == amounts.length - 1 && amount + amounts");
insert Expression(8722, 8721, "j == amounts.length - 1");
insert BinaryExpression(8723, 8722, "j == amounts.length - 1");
insert Expression(8724, 8723, "j == amounts.length");
insert MemberExpression(8725, 8724, "j == amounts.length");
insert Expression(8726, 8725, "j == amounts");
insert BinaryExpression(8727, 8726, "j == amounts");
insert Expression(8728, 8727, "j");
insert Identifier(8729, 8728, "j");
insert Expression(8730, 8727, "amounts");
insert Identifier(8731, 8730, "amounts");
insert Identifier(8732, 8725, "length");
insert Expression(8733, 8723, "1");
insert NumberLiteral(8734, 8733, "1");
insert Expression(8735, 8721, "amount + amounts");
insert BinaryExpression(8736, 8735, "amount + amounts");
insert Expression(8737, 8736, "amount");
insert Identifier(8738, 8737, "amount");
insert Expression(8739, 8736, "amounts");
insert Identifier(8740, 8739, "amounts");
insert Expression(8741, 8719, "j");
insert Identifier(8742, 8741, "j");
insert Expression(8743, 8717, "balance");
insert Identifier(8744, 8743, "balance");
insert Statement(8745, 8715, "{\n                emit Release(j, balance - amount);\n                amount = balance;\n            }");
insert BlockStatement(8746, 8745, "{\n                emit Release(j, balance - amount);\n                amount = balance;\n            }");
insert Statement(8747, 8746, "emit Release(j, balance - amount);");
insert EmitStatement(8748, 8747, "emit Release(j, balance - amount);");
insert Expression(8749, 8748, "Release");
insert Identifier(8750, 8749, "Release");
insert CallArgument(8751, 8748, "j");
insert Expression(8752, 8751, "j");
insert Identifier(8753, 8752, "j");
insert CallArgument(8754, 8748, "balance - amount");
insert Expression(8755, 8754, "balance - amount");
insert BinaryExpression(8756, 8755, "balance - amount");
insert Expression(8757, 8756, "balance");
insert Identifier(8758, 8757, "balance");
insert Expression(8759, 8756, "amount");
insert Identifier(8760, 8759, "amount");
insert Statement(8761, 8746, "amount = balance;");
insert ExpressionStatement(8762, 8761, "amount = balance;");
insert Expression(8763, 8762, "amount = balance");
insert AssignmentExpression(8764, 8763, "amount = balance");
insert Expression(8765, 8764, "amount");
insert Identifier(8766, 8765, "amount");
insert Expression(8767, 8764, "balance");
insert Identifier(8768, 8767, "balance");
insert Statement(8769, 8715, "{\n                emit Release(j, amounts[j]);\n                amount = amount + amounts[j];\n            }");
insert BlockStatement(8770, 8769, "{\n                emit Release(j, amounts[j]);\n                amount = amount + amounts[j];\n            }");
insert Statement(8771, 8770, "emit Release(j, amounts[j]);");
insert EmitStatement(8772, 8771, "emit Release(j, amounts[j]);");
insert Expression(8773, 8772, "Release");
insert Identifier(8774, 8773, "Release");
insert CallArgument(8775, 8772, "j");
insert Expression(8776, 8775, "j");
insert Identifier(8777, 8776, "j");
insert CallArgument(8778, 8772, "amounts[j]");
insert Expression(8779, 8778, "amounts[j]");
insert ArrayAccess(8780, 8779, "amounts[j]");
insert Expression(8781, 8780, "amounts");
insert Identifier(8782, 8781, "amounts");
insert Expression(8783, 8780, "j");
insert Identifier(8784, 8783, "j");
insert Statement(8785, 8770, "amount = amount + amounts[j];");
insert ExpressionStatement(8786, 8785, "amount = amount + amounts[j];");
insert Expression(8787, 8786, "amount = amount + amounts[j]");
insert AssignmentExpression(8788, 8787, "amount = amount + amounts[j]");
insert Expression(8789, 8788, "amount");
insert Identifier(8790, 8789, "amount");
insert Expression(8791, 8788, "amount + amounts[j]");
insert ArrayAccess(8792, 8791, "amount + amounts[j]");
insert Expression(8793, 8792, "amount + amounts");
insert BinaryExpression(8794, 8793, "amount + amounts");
insert Expression(8795, 8794, "amount");
insert Identifier(8796, 8795, "amount");
insert Expression(8797, 8794, "amounts");
insert Identifier(8798, 8797, "amounts");
insert Expression(8799, 8792, "j");
insert Identifier(8800, 8799, "j");
insert Statement(8801, 8606, "if (balance < amount) revert InsufficientBalance();");
insert IfStatement(8802, 8801, "if (balance < amount) revert InsufficientBalance();");
insert Expression(8803, 8802, "balance < amount");
insert BinaryExpression(8804, 8803, "balance < amount");
insert Expression(8805, 8804, "balance");
insert Identifier(8806, 8805, "balance");
insert Expression(8807, 8804, "amount");
insert Identifier(8808, 8807, "amount");
insert Statement(8809, 8802, "revert InsufficientBalance();");
insert RevertStatement(8810, 8809, "revert InsufficientBalance();");
insert Expression(8811, 8810, "InsufficientBalance");
insert Identifier(8812, 8811, "InsufficientBalance");
insert RevertArguments(8813, 8810, "()");
insert Statement(8814, 8606, "_transferPayment(token, amount);");
insert ExpressionStatement(8815, 8814, "_transferPayment(token, amount);");
insert Expression(8816, 8815, "_transferPayment(token, amount)");
insert CallExpression(8817, 8816, "_transferPayment(token, amount)");
insert Expression(8818, 8817, "_transferPayment");
insert Identifier(8819, 8818, "_transferPayment");
insert CallArgument(8820, 8817, "token");
insert Expression(8821, 8820, "token");
insert Identifier(8822, 8821, "token");
insert CallArgument(8823, 8817, "amount");
insert Expression(8824, 8823, "amount");
insert Identifier(8825, 8824, "amount");
insert Statement(8826, 8606, "released = released + amount;");
insert ExpressionStatement(8827, 8826, "released = released + amount;");
insert Expression(8828, 8827, "released = released + amount");
insert AssignmentExpression(8829, 8828, "released = released + amount");
insert Expression(8830, 8829, "released");
insert Identifier(8831, 8830, "released");
insert Expression(8832, 8829, "released + amount");
insert BinaryExpression(8833, 8832, "released + amount");
insert Expression(8834, 8833, "released");
insert Identifier(8835, 8834, "released");
insert Expression(8836, 8833, "amount");
insert Identifier(8837, 8836, "amount");
insert Statement(8838, 8606, "milestone = _milestone + 1;");
insert ExpressionStatement(8839, 8838, "milestone = _milestone + 1;");
insert Expression(8840, 8839, "milestone = _milestone + 1");
insert AssignmentExpression(8841, 8840, "milestone = _milestone + 1");
insert Expression(8842, 8841, "milestone");
insert Identifier(8843, 8842, "milestone");
insert Expression(8844, 8841, "_milestone + 1");
insert BinaryExpression(8845, 8844, "_milestone + 1");
insert Expression(8846, 8845, "_milestone");
insert Identifier(8847, 8846, "_milestone");
insert Expression(8848, 8845, "1");
insert NumberLiteral(8849, 8848, "1");
insert Comment(8850, 7306, "/**\n     * @dev External function to release tokens from the contract to the provider.\n     * Uses the internal `_release` function to perform the actual release.\n     * @param _token The token to release funds from\n     */");
insert FunctionDefinition(8851, 7306, "function releaseTokens(\n        address _token\n    ) external virtual override nonReentrant {\n        if (_token == token) {\n            _release();\n        } else {\n            if (_msgSender() != client) revert NotClient();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            _transferPayment(_token, balance);\n        }\n    }");
insert Identifier(8852, 8851, "releaseTokens");
insert Parameter(8853, 8851, "address _token");
insert TypeName(8854, 8853, "address");
insert PrimitiveType(8855, 8854, "address");
insert Identifier(8856, 8853, "_token");
insert Visibility(8857, 8851, "external");
insert Virtual(8858, 8851, "virtual");
insert OverrideSpecifier(8859, 8851, "override");
insert ModifierInvocation(8860, 8851, "nonReentrant");
insert Identifier(8861, 8860, "nonReentrant");
insert FunctionBody(8862, 8851, "{\n        if (_token == token) {\n            _release();\n        } else {\n            if (_msgSender() != client) revert NotClient();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            _transferPayment(_token, balance);\n        }\n    }");
insert Statement(8863, 8862, "if (_token == token) {\n            _release();\n        } else {\n            if (_msgSender() != client) revert NotClient();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            _transferPayment(_token, balance);\n        }");
insert IfStatement(8864, 8863, "if (_token == token) {\n            _release();\n        } else {\n            if (_msgSender() != client) revert NotClient();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            _transferPayment(_token, balance);\n        }");
insert Expression(8865, 8864, "_token == token");
insert BinaryExpression(8866, 8865, "_token == token");
insert Expression(8867, 8866, "_token");
insert Identifier(8868, 8867, "_token");
insert Expression(8869, 8866, "token");
insert Identifier(8870, 8869, "token");
insert Statement(8871, 8864, "{\n            _release();\n        }");
insert BlockStatement(8872, 8871, "{\n            _release();\n        }");
insert Statement(8873, 8872, "_release();");
insert ExpressionStatement(8874, 8873, "_release();");
insert Expression(8875, 8874, "_release()");
insert CallExpression(8876, 8875, "_release()");
insert Expression(8877, 8876, "_release");
insert Identifier(8878, 8877, "_release");
insert Statement(8879, 8864, "{\n            if (_msgSender() != client) revert NotClient();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            _transferPayment(_token, balance);\n        }");
insert BlockStatement(8880, 8879, "{\n            if (_msgSender() != client) revert NotClient();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            _transferPayment(_token, balance);\n        }");
insert Statement(8881, 8880, "if (_msgSender() != client) revert NotClient();");
insert IfStatement(8882, 8881, "if (_msgSender() != client) revert NotClient();");
insert Expression(8883, 8882, "_msgSender() != client");
insert BinaryExpression(8884, 8883, "_msgSender() != client");
insert Expression(8885, 8884, "_msgSender()");
insert CallExpression(8886, 8885, "_msgSender()");
insert Expression(8887, 8886, "_msgSender");
insert Identifier(8888, 8887, "_msgSender");
insert Expression(8889, 8884, "client");
insert Identifier(8890, 8889, "client");
insert Statement(8891, 8882, "revert NotClient();");
insert RevertStatement(8892, 8891, "revert NotClient();");
insert Expression(8893, 8892, "NotClient");
insert Identifier(8894, 8893, "NotClient");
insert RevertArguments(8895, 8892, "()");
insert Statement(8896, 8880, "uint256 balance = IERC20(_token).balanceOf(address(this));");
insert VariableDeclarationStatement(8897, 8896, "uint256 balance = IERC20(_token).balanceOf(address(this));");
insert VariableDeclaration(8898, 8897, "uint256 balance");
insert TypeName(8899, 8898, "uint256");
insert PrimitiveType(8900, 8899, "uint256");
insert Identifier(8901, 8898, "balance");
insert Expression(8902, 8897, "IERC20(_token).balanceOf(address(this))");
insert CallExpression(8903, 8902, "IERC20(_token).balanceOf(address(this))");
insert Expression(8904, 8903, "IERC20(_token).balanceOf");
insert MemberExpression(8905, 8904, "IERC20(_token).balanceOf");
insert Expression(8906, 8905, "IERC20(_token)");
insert CallExpression(8907, 8906, "IERC20(_token)");
insert Expression(8908, 8907, "IERC20");
insert Identifier(8909, 8908, "IERC20");
insert CallArgument(8910, 8907, "_token");
insert Expression(8911, 8910, "_token");
insert Identifier(8912, 8911, "_token");
insert Identifier(8913, 8905, "balanceOf");
insert CallArgument(8914, 8903, "address(this)");
insert Expression(8915, 8914, "address(this)");
insert TypeCastExpression(8916, 8915, "address(this)");
insert PrimitiveType(8917, 8916, "address");
insert CallArgument(8918, 8916, "this");
insert Expression(8919, 8918, "this");
insert Identifier(8920, 8919, "this");
insert Statement(8921, 8880, "_transferPayment(_token, balance);");
insert ExpressionStatement(8922, 8921, "_transferPayment(_token, balance);");
insert Expression(8923, 8922, "_transferPayment(_token, balance)");
insert CallExpression(8924, 8923, "_transferPayment(_token, balance)");
insert Expression(8925, 8924, "_transferPayment");
insert Identifier(8926, 8925, "_transferPayment");
insert CallArgument(8927, 8924, "_token");
insert Expression(8928, 8927, "_token");
insert Identifier(8929, 8928, "_token");
insert CallArgument(8930, 8924, "balance");
insert Expression(8931, 8930, "balance");
insert Identifier(8932, 8931, "balance");
insert Comment(8933, 7306, "/**\n     * @dev Internal function to withdraw funds from the contract to the client.\n     */");
insert FunctionDefinition(8934, 7306, "function _withdraw() internal {\n        if (locked) revert Locked();\n        if (block.timestamp <= terminationTime) revert Terminated();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n\n        _withdrawDeposit(token, balance);\n        milestone = amounts.length;\n\n        emit Withdraw(balance);\n    }");
insert Identifier(8935, 8934, "_withdraw");
insert Visibility(8936, 8934, "internal");
insert FunctionBody(8937, 8934, "{\n        if (locked) revert Locked();\n        if (block.timestamp <= terminationTime) revert Terminated();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n\n        _withdrawDeposit(token, balance);\n        milestone = amounts.length;\n\n        emit Withdraw(balance);\n    }");
insert Statement(8938, 8937, "if (locked) revert Locked();");
insert IfStatement(8939, 8938, "if (locked) revert Locked();");
insert Expression(8940, 8939, "locked");
insert Identifier(8941, 8940, "locked");
insert Statement(8942, 8939, "revert Locked();");
insert RevertStatement(8943, 8942, "revert Locked();");
insert Expression(8944, 8943, "Locked");
insert Identifier(8945, 8944, "Locked");
insert RevertArguments(8946, 8943, "()");
insert Statement(8947, 8937, "if (block.timestamp <= terminationTime) revert Terminated();");
insert IfStatement(8948, 8947, "if (block.timestamp <= terminationTime) revert Terminated();");
insert Expression(8949, 8948, "block.timestamp <= terminationTime");
insert BinaryExpression(8950, 8949, "block.timestamp <= terminationTime");
insert Expression(8951, 8950, "block.timestamp");
insert MemberExpression(8952, 8951, "block.timestamp");
insert Identifier(8953, 8952, "block");
insert Identifier(8954, 8952, "timestamp");
insert Expression(8955, 8950, "terminationTime");
insert Identifier(8956, 8955, "terminationTime");
insert Statement(8957, 8948, "revert Terminated();");
insert RevertStatement(8958, 8957, "revert Terminated();");
insert Expression(8959, 8958, "Terminated");
insert Identifier(8960, 8959, "Terminated");
insert RevertArguments(8961, 8958, "()");
insert Statement(8962, 8937, "uint256 balance = IERC20(token).balanceOf(address(this));");
insert VariableDeclarationStatement(8963, 8962, "uint256 balance = IERC20(token).balanceOf(address(this));");
insert VariableDeclaration(8964, 8963, "uint256 balance");
insert TypeName(8965, 8964, "uint256");
insert PrimitiveType(8966, 8965, "uint256");
insert Identifier(8967, 8964, "balance");
insert Expression(8968, 8963, "IERC20(token).balanceOf(address(this))");
insert CallExpression(8969, 8968, "IERC20(token).balanceOf(address(this))");
insert Expression(8970, 8969, "IERC20(token).balanceOf");
insert MemberExpression(8971, 8970, "IERC20(token).balanceOf");
insert Expression(8972, 8971, "IERC20(token)");
insert CallExpression(8973, 8972, "IERC20(token)");
insert Expression(8974, 8973, "IERC20");
insert Identifier(8975, 8974, "IERC20");
insert CallArgument(8976, 8973, "token");
insert Expression(8977, 8976, "token");
insert Identifier(8978, 8977, "token");
insert Identifier(8979, 8971, "balanceOf");
insert CallArgument(8980, 8969, "address(this)");
insert Expression(8981, 8980, "address(this)");
insert TypeCastExpression(8982, 8981, "address(this)");
insert PrimitiveType(8983, 8982, "address");
insert CallArgument(8984, 8982, "this");
insert Expression(8985, 8984, "this");
insert Identifier(8986, 8985, "this");
insert Statement(8987, 8937, "if (balance == 0) revert BalanceIsZero();");
insert IfStatement(8988, 8987, "if (balance == 0) revert BalanceIsZero();");
insert Expression(8989, 8988, "balance == 0");
insert BinaryExpression(8990, 8989, "balance == 0");
insert Expression(8991, 8990, "balance");
insert Identifier(8992, 8991, "balance");
insert Expression(8993, 8990, "0");
insert NumberLiteral(8994, 8993, "0");
insert Statement(8995, 8988, "revert BalanceIsZero();");
insert RevertStatement(8996, 8995, "revert BalanceIsZero();");
insert Expression(8997, 8996, "BalanceIsZero");
insert Identifier(8998, 8997, "BalanceIsZero");
insert RevertArguments(8999, 8996, "()");
insert Statement(9000, 8937, "_withdrawDeposit(token, balance);");
insert ExpressionStatement(9001, 9000, "_withdrawDeposit(token, balance);");
insert Expression(9002, 9001, "_withdrawDeposit(token, balance)");
insert CallExpression(9003, 9002, "_withdrawDeposit(token, balance)");
insert Expression(9004, 9003, "_withdrawDeposit");
insert Identifier(9005, 9004, "_withdrawDeposit");
insert CallArgument(9006, 9003, "token");
insert Expression(9007, 9006, "token");
insert Identifier(9008, 9007, "token");
insert CallArgument(9009, 9003, "balance");
insert Expression(9010, 9009, "balance");
insert Identifier(9011, 9010, "balance");
insert Statement(9012, 8937, "milestone = amounts.length;");
insert ExpressionStatement(9013, 9012, "milestone = amounts.length;");
insert Expression(9014, 9013, "milestone = amounts.length");
insert AssignmentExpression(9015, 9014, "milestone = amounts.length");
insert Expression(9016, 9015, "milestone");
insert Identifier(9017, 9016, "milestone");
insert Expression(9018, 9015, "amounts.length");
insert MemberExpression(9019, 9018, "amounts.length");
insert Identifier(9020, 9019, "amounts");
insert Identifier(9021, 9019, "length");
insert Statement(9022, 8937, "emit Withdraw(balance);");
insert EmitStatement(9023, 9022, "emit Withdraw(balance);");
insert Expression(9024, 9023, "Withdraw");
insert Identifier(9025, 9024, "Withdraw");
insert CallArgument(9026, 9023, "balance");
insert Expression(9027, 9026, "balance");
insert Identifier(9028, 9027, "balance");
insert Comment(9029, 7306, "/**\n     * @dev External function to withdraw funds from the contract to the client.\n     * Uses the internal `_withdraw` function to perform the actual withdrawal.\n     */");
insert FunctionDefinition(9030, 7306, "function withdraw() external override nonReentrant {\n        return _withdraw();\n    }");
insert Identifier(9031, 9030, "withdraw");
insert Visibility(9032, 9030, "external");
insert OverrideSpecifier(9033, 9030, "override");
insert ModifierInvocation(9034, 9030, "nonReentrant");
insert Identifier(9035, 9034, "nonReentrant");
insert FunctionBody(9036, 9030, "{\n        return _withdraw();\n    }");
insert Statement(9037, 9036, "return _withdraw();");
insert ReturnStatement(9038, 9037, "return _withdraw();");
insert Expression(9039, 9038, "_withdraw()");
insert CallExpression(9040, 9039, "_withdraw()");
insert Expression(9041, 9040, "_withdraw");
insert Identifier(9042, 9041, "_withdraw");
insert Comment(9043, 7306, "/**\n     * @dev External function to withdraw tokens from the contract to the client.\n     * Uses the internal `_withdraw` function to perform the actual withdrawal.\n     * @param _token The token to withdraw\n     */");
insert FunctionDefinition(9044, 7306, "function withdrawTokens(address _token) external override nonReentrant {\n        if (_token == token) {\n            _withdraw();\n        } else {\n            if (block.timestamp <= terminationTime) revert Terminated();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n\n            _withdrawDeposit(_token, balance);\n        }\n    }");
insert Identifier(9045, 9044, "withdrawTokens");
insert Parameter(9046, 9044, "address _token");
insert TypeName(9047, 9046, "address");
insert PrimitiveType(9048, 9047, "address");
insert Identifier(9049, 9046, "_token");
insert Visibility(9050, 9044, "external");
insert OverrideSpecifier(9051, 9044, "override");
insert ModifierInvocation(9052, 9044, "nonReentrant");
insert Identifier(9053, 9052, "nonReentrant");
insert FunctionBody(9054, 9044, "{\n        if (_token == token) {\n            _withdraw();\n        } else {\n            if (block.timestamp <= terminationTime) revert Terminated();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n\n            _withdrawDeposit(_token, balance);\n        }\n    }");
insert Statement(9055, 9054, "if (_token == token) {\n            _withdraw();\n        } else {\n            if (block.timestamp <= terminationTime) revert Terminated();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n\n            _withdrawDeposit(_token, balance);\n        }");
insert IfStatement(9056, 9055, "if (_token == token) {\n            _withdraw();\n        } else {\n            if (block.timestamp <= terminationTime) revert Terminated();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n\n            _withdrawDeposit(_token, balance);\n        }");
insert Expression(9057, 9056, "_token == token");
insert BinaryExpression(9058, 9057, "_token == token");
insert Expression(9059, 9058, "_token");
insert Identifier(9060, 9059, "_token");
insert Expression(9061, 9058, "token");
insert Identifier(9062, 9061, "token");
insert Statement(9063, 9056, "{\n            _withdraw();\n        }");
insert BlockStatement(9064, 9063, "{\n            _withdraw();\n        }");
insert Statement(9065, 9064, "_withdraw();");
insert ExpressionStatement(9066, 9065, "_withdraw();");
insert Expression(9067, 9066, "_withdraw()");
insert CallExpression(9068, 9067, "_withdraw()");
insert Expression(9069, 9068, "_withdraw");
insert Identifier(9070, 9069, "_withdraw");
insert Statement(9071, 9056, "{\n            if (block.timestamp <= terminationTime) revert Terminated();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n\n            _withdrawDeposit(_token, balance);\n        }");
insert BlockStatement(9072, 9071, "{\n            if (block.timestamp <= terminationTime) revert Terminated();\n            uint256 balance = IERC20(_token).balanceOf(address(this));\n            if (balance == 0) revert BalanceIsZero();\n\n            _withdrawDeposit(_token, balance);\n        }");
insert Statement(9073, 9072, "if (block.timestamp <= terminationTime) revert Terminated();");
insert IfStatement(9074, 9073, "if (block.timestamp <= terminationTime) revert Terminated();");
insert Expression(9075, 9074, "block.timestamp <= terminationTime");
insert BinaryExpression(9076, 9075, "block.timestamp <= terminationTime");
insert Expression(9077, 9076, "block.timestamp");
insert MemberExpression(9078, 9077, "block.timestamp");
insert Identifier(9079, 9078, "block");
insert Identifier(9080, 9078, "timestamp");
insert Expression(9081, 9076, "terminationTime");
insert Identifier(9082, 9081, "terminationTime");
insert Statement(9083, 9074, "revert Terminated();");
insert RevertStatement(9084, 9083, "revert Terminated();");
insert Expression(9085, 9084, "Terminated");
insert Identifier(9086, 9085, "Terminated");
insert RevertArguments(9087, 9084, "()");
insert Statement(9088, 9072, "uint256 balance = IERC20(_token).balanceOf(address(this));");
insert VariableDeclarationStatement(9089, 9088, "uint256 balance = IERC20(_token).balanceOf(address(this));");
insert VariableDeclaration(9090, 9089, "uint256 balance");
insert TypeName(9091, 9090, "uint256");
insert PrimitiveType(9092, 9091, "uint256");
insert Identifier(9093, 9090, "balance");
insert Expression(9094, 9089, "IERC20(_token).balanceOf(address(this))");
insert CallExpression(9095, 9094, "IERC20(_token).balanceOf(address(this))");
insert Expression(9096, 9095, "IERC20(_token).balanceOf");
insert MemberExpression(9097, 9096, "IERC20(_token).balanceOf");
insert Expression(9098, 9097, "IERC20(_token)");
insert CallExpression(9099, 9098, "IERC20(_token)");
insert Expression(9100, 9099, "IERC20");
insert Identifier(9101, 9100, "IERC20");
insert CallArgument(9102, 9099, "_token");
insert Expression(9103, 9102, "_token");
insert Identifier(9104, 9103, "_token");
insert Identifier(9105, 9097, "balanceOf");
insert CallArgument(9106, 9095, "address(this)");
insert Expression(9107, 9106, "address(this)");
insert TypeCastExpression(9108, 9107, "address(this)");
insert PrimitiveType(9109, 9108, "address");
insert CallArgument(9110, 9108, "this");
insert Expression(9111, 9110, "this");
insert Identifier(9112, 9111, "this");
insert Statement(9113, 9072, "if (balance == 0) revert BalanceIsZero();");
insert IfStatement(9114, 9113, "if (balance == 0) revert BalanceIsZero();");
insert Expression(9115, 9114, "balance == 0");
insert BinaryExpression(9116, 9115, "balance == 0");
insert Expression(9117, 9116, "balance");
insert Identifier(9118, 9117, "balance");
insert Expression(9119, 9116, "0");
insert NumberLiteral(9120, 9119, "0");
insert Statement(9121, 9114, "revert BalanceIsZero();");
insert RevertStatement(9122, 9121, "revert BalanceIsZero();");
insert Expression(9123, 9122, "BalanceIsZero");
insert Identifier(9124, 9123, "BalanceIsZero");
insert RevertArguments(9125, 9122, "()");
insert Statement(9126, 9072, "_withdrawDeposit(_token, balance);");
insert ExpressionStatement(9127, 9126, "_withdrawDeposit(_token, balance);");
insert Expression(9128, 9127, "_withdrawDeposit(_token, balance)");
insert CallExpression(9129, 9128, "_withdrawDeposit(_token, balance)");
insert Expression(9130, 9129, "_withdrawDeposit");
insert Identifier(9131, 9130, "_withdrawDeposit");
insert CallArgument(9132, 9129, "_token");
insert Expression(9133, 9132, "_token");
insert Identifier(9134, 9133, "_token");
insert CallArgument(9135, 9129, "balance");
insert Expression(9136, 9135, "balance");
insert Identifier(9137, 9136, "balance");
insert Comment(9138, 7306, "/**\n     * @dev External function to lock the contract.\n     * @param _details Details of the dispute\n     */");
insert FunctionDefinition(9139, 7306, "function lock(bytes32 _details) external payable override nonReentrant {\n        if (locked) revert Locked();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n        if (block.timestamp >= terminationTime) revert Terminated();\n        if (_msgSender() != client && _msgSender() != provider)\n            revert NotParty();\n\n        if (resolverType == ADR.ARBITRATOR) {\n            disputeId = IArbitrator(resolver).createDispute{value: msg.value}(\n                NUM_RULING_OPTIONS,\n                abi.encodePacked(details)\n            );\n        }\n        locked = true;\n\n        emit Lock(_msgSender(), _details);\n    }");
insert Identifier(9140, 9139, "lock");
insert Parameter(9141, 9139, "bytes32 _details");
insert TypeName(9142, 9141, "bytes32");
insert PrimitiveType(9143, 9142, "bytes32");
insert Identifier(9144, 9141, "_details");
insert Visibility(9145, 9139, "external");
insert StateMutability(9146, 9139, "payable");
insert OverrideSpecifier(9147, 9139, "override");
insert ModifierInvocation(9148, 9139, "nonReentrant");
insert Identifier(9149, 9148, "nonReentrant");
insert FunctionBody(9150, 9139, "{\n        if (locked) revert Locked();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n        if (block.timestamp >= terminationTime) revert Terminated();\n        if (_msgSender() != client && _msgSender() != provider)\n            revert NotParty();\n\n        if (resolverType == ADR.ARBITRATOR) {\n            disputeId = IArbitrator(resolver).createDispute{value: msg.value}(\n                NUM_RULING_OPTIONS,\n                abi.encodePacked(details)\n            );\n        }\n        locked = true;\n\n        emit Lock(_msgSender(), _details);\n    }");
insert Statement(9151, 9150, "if (locked) revert Locked();");
insert IfStatement(9152, 9151, "if (locked) revert Locked();");
insert Expression(9153, 9152, "locked");
insert Identifier(9154, 9153, "locked");
insert Statement(9155, 9152, "revert Locked();");
insert RevertStatement(9156, 9155, "revert Locked();");
insert Expression(9157, 9156, "Locked");
insert Identifier(9158, 9157, "Locked");
insert RevertArguments(9159, 9156, "()");
insert Statement(9160, 9150, "uint256 balance = IERC20(token).balanceOf(address(this));");
insert VariableDeclarationStatement(9161, 9160, "uint256 balance = IERC20(token).balanceOf(address(this));");
insert VariableDeclaration(9162, 9161, "uint256 balance");
insert TypeName(9163, 9162, "uint256");
insert PrimitiveType(9164, 9163, "uint256");
insert Identifier(9165, 9162, "balance");
insert Expression(9166, 9161, "IERC20(token).balanceOf(address(this))");
insert CallExpression(9167, 9166, "IERC20(token).balanceOf(address(this))");
insert Expression(9168, 9167, "IERC20(token).balanceOf");
insert MemberExpression(9169, 9168, "IERC20(token).balanceOf");
insert Expression(9170, 9169, "IERC20(token)");
insert CallExpression(9171, 9170, "IERC20(token)");
insert Expression(9172, 9171, "IERC20");
insert Identifier(9173, 9172, "IERC20");
insert CallArgument(9174, 9171, "token");
insert Expression(9175, 9174, "token");
insert Identifier(9176, 9175, "token");
insert Identifier(9177, 9169, "balanceOf");
insert CallArgument(9178, 9167, "address(this)");
insert Expression(9179, 9178, "address(this)");
insert TypeCastExpression(9180, 9179, "address(this)");
insert PrimitiveType(9181, 9180, "address");
insert CallArgument(9182, 9180, "this");
insert Expression(9183, 9182, "this");
insert Identifier(9184, 9183, "this");
insert Statement(9185, 9150, "if (balance == 0) revert BalanceIsZero();");
insert IfStatement(9186, 9185, "if (balance == 0) revert BalanceIsZero();");
insert Expression(9187, 9186, "balance == 0");
insert BinaryExpression(9188, 9187, "balance == 0");
insert Expression(9189, 9188, "balance");
insert Identifier(9190, 9189, "balance");
insert Expression(9191, 9188, "0");
insert NumberLiteral(9192, 9191, "0");
insert Statement(9193, 9186, "revert BalanceIsZero();");
insert RevertStatement(9194, 9193, "revert BalanceIsZero();");
insert Expression(9195, 9194, "BalanceIsZero");
insert Identifier(9196, 9195, "BalanceIsZero");
insert RevertArguments(9197, 9194, "()");
insert Statement(9198, 9150, "if (block.timestamp >= terminationTime) revert Terminated();");
insert IfStatement(9199, 9198, "if (block.timestamp >= terminationTime) revert Terminated();");
insert Expression(9200, 9199, "block.timestamp >= terminationTime");
insert BinaryExpression(9201, 9200, "block.timestamp >= terminationTime");
insert Expression(9202, 9201, "block.timestamp");
insert MemberExpression(9203, 9202, "block.timestamp");
insert Identifier(9204, 9203, "block");
insert Identifier(9205, 9203, "timestamp");
insert Expression(9206, 9201, "terminationTime");
insert Identifier(9207, 9206, "terminationTime");
insert Statement(9208, 9199, "revert Terminated();");
insert RevertStatement(9209, 9208, "revert Terminated();");
insert Expression(9210, 9209, "Terminated");
insert Identifier(9211, 9210, "Terminated");
insert RevertArguments(9212, 9209, "()");
insert Statement(9213, 9150, "if (_msgSender() != client && _msgSender() != provider)\n            revert NotParty();");
insert IfStatement(9214, 9213, "if (_msgSender() != client && _msgSender() != provider)\n            revert NotParty();");
insert Expression(9215, 9214, "_msgSender() != client && _msgSender() != provider");
insert BinaryExpression(9216, 9215, "_msgSender() != client && _msgSender() != provider");
insert Expression(9217, 9216, "_msgSender() != client");
insert BinaryExpression(9218, 9217, "_msgSender() != client");
insert Expression(9219, 9218, "_msgSender()");
insert CallExpression(9220, 9219, "_msgSender()");
insert Expression(9221, 9220, "_msgSender");
insert Identifier(9222, 9221, "_msgSender");
insert Expression(9223, 9218, "client");
insert Identifier(9224, 9223, "client");
insert Expression(9225, 9216, "_msgSender() != provider");
insert BinaryExpression(9226, 9225, "_msgSender() != provider");
insert Expression(9227, 9226, "_msgSender()");
insert CallExpression(9228, 9227, "_msgSender()");
insert Expression(9229, 9228, "_msgSender");
insert Identifier(9230, 9229, "_msgSender");
insert Expression(9231, 9226, "provider");
insert Identifier(9232, 9231, "provider");
insert Statement(9233, 9214, "revert NotParty();");
insert RevertStatement(9234, 9233, "revert NotParty();");
insert Expression(9235, 9234, "NotParty");
insert Identifier(9236, 9235, "NotParty");
insert RevertArguments(9237, 9234, "()");
insert Statement(9238, 9150, "if (resolverType == ADR.ARBITRATOR) {\n            disputeId = IArbitrator(resolver).createDispute{value: msg.value}(\n                NUM_RULING_OPTIONS,\n                abi.encodePacked(details)\n            );\n        }");
insert IfStatement(9239, 9238, "if (resolverType == ADR.ARBITRATOR) {\n            disputeId = IArbitrator(resolver).createDispute{value: msg.value}(\n                NUM_RULING_OPTIONS,\n                abi.encodePacked(details)\n            );\n        }");
insert Expression(9240, 9239, "resolverType == ADR.ARBITRATOR");
insert BinaryExpression(9241, 9240, "resolverType == ADR.ARBITRATOR");
insert Expression(9242, 9241, "resolverType");
insert Identifier(9243, 9242, "resolverType");
insert Expression(9244, 9241, "ADR.ARBITRATOR");
insert MemberExpression(9245, 9244, "ADR.ARBITRATOR");
insert Identifier(9246, 9245, "ADR");
insert Identifier(9247, 9245, "ARBITRATOR");
insert Statement(9248, 9239, "{\n            disputeId = IArbitrator(resolver).createDispute{value: msg.value}(\n                NUM_RULING_OPTIONS,\n                abi.encodePacked(details)\n            );\n        }");
insert BlockStatement(9249, 9248, "{\n            disputeId = IArbitrator(resolver).createDispute{value: msg.value}(\n                NUM_RULING_OPTIONS,\n                abi.encodePacked(details)\n            );\n        }");
insert Statement(9250, 9249, "disputeId = IArbitrator(resolver).createDispute{value: msg.value}(\n                NUM_RULING_OPTIONS,\n                abi.encodePacked(details)\n            );");
insert ExpressionStatement(9251, 9250, "disputeId = IArbitrator(resolver).createDispute{value: msg.value}(\n                NUM_RULING_OPTIONS,\n                abi.encodePacked(details)\n            );");
insert Expression(9252, 9251, "disputeId = IArbitrator(resolver).createDispute{value: msg.value}(\n                NUM_RULING_OPTIONS,\n                abi.encodePacked(details)\n            )");
insert AssignmentExpression(9253, 9252, "disputeId = IArbitrator(resolver).createDispute{value: msg.value}(\n                NUM_RULING_OPTIONS,\n                abi.encodePacked(details)\n            )");
insert Expression(9254, 9253, "disputeId");
insert Identifier(9255, 9254, "disputeId");
insert Expression(9256, 9253, "IArbitrator(resolver).createDispute{value: msg.value}(\n                NUM_RULING_OPTIONS,\n                abi.encodePacked(details)\n            )");
insert CallExpression(9257, 9256, "IArbitrator(resolver).createDispute{value: msg.value}(\n                NUM_RULING_OPTIONS,\n                abi.encodePacked(details)\n            )");
insert Expression(9258, 9257, "IArbitrator(resolver).createDispute{value: msg.value}");
insert StructExpression(9259, 9258, "IArbitrator(resolver).createDispute{value: msg.value}");
insert Expression(9260, 9259, "IArbitrator(resolver).createDispute");
insert MemberExpression(9261, 9260, "IArbitrator(resolver).createDispute");
insert Expression(9262, 9261, "IArbitrator(resolver)");
insert CallExpression(9263, 9262, "IArbitrator(resolver)");
insert Expression(9264, 9263, "IArbitrator");
insert Identifier(9265, 9264, "IArbitrator");
insert CallArgument(9266, 9263, "resolver");
insert Expression(9267, 9266, "resolver");
insert Identifier(9268, 9267, "resolver");
insert Identifier(9269, 9261, "createDispute");
insert StructFieldAssignment(9270, 9259, "value: msg.value");
insert Identifier(9271, 9270, "value");
insert Expression(9272, 9270, "msg.value");
insert MemberExpression(9273, 9272, "msg.value");
insert Identifier(9274, 9273, "msg");
insert Identifier(9275, 9273, "value");
insert CallArgument(9276, 9257, "NUM_RULING_OPTIONS");
insert Expression(9277, 9276, "NUM_RULING_OPTIONS");
insert Identifier(9278, 9277, "NUM_RULING_OPTIONS");
insert CallArgument(9279, 9257, "abi.encodePacked(details)");
insert Expression(9280, 9279, "abi.encodePacked(details)");
insert CallExpression(9281, 9280, "abi.encodePacked(details)");
insert Expression(9282, 9281, "abi.encodePacked");
insert MemberExpression(9283, 9282, "abi.encodePacked");
insert Identifier(9284, 9283, "abi");
insert Identifier(9285, 9283, "encodePacked");
insert CallArgument(9286, 9281, "details");
insert Expression(9287, 9286, "details");
insert Identifier(9288, 9287, "details");
insert Statement(9289, 9150, "locked = true;");
insert ExpressionStatement(9290, 9289, "locked = true;");
insert Expression(9291, 9290, "locked = true");
insert AssignmentExpression(9292, 9291, "locked = true");
insert Expression(9293, 9292, "locked");
insert Identifier(9294, 9293, "locked");
insert Expression(9295, 9292, "true");
insert BooleanLiteral(9296, 9295, "true");
insert True(9297, 9296, "true");
insert Statement(9298, 9150, "emit Lock(_msgSender(), _details);");
insert EmitStatement(9299, 9298, "emit Lock(_msgSender(), _details);");
insert Expression(9300, 9299, "Lock");
insert Identifier(9301, 9300, "Lock");
insert CallArgument(9302, 9299, "_msgSender()");
insert Expression(9303, 9302, "_msgSender()");
insert CallExpression(9304, 9303, "_msgSender()");
insert Expression(9305, 9304, "_msgSender");
insert Identifier(9306, 9305, "_msgSender");
insert CallArgument(9307, 9299, "_details");
insert Expression(9308, 9307, "_details");
insert Identifier(9309, 9308, "_details");
insert Comment(9310, 7306, "/**\n     * @dev External function to resolve the contract.\n     * @param _clientAward The amount to award the client\n     * @param _providerAward The amount to award the provider\n     * @param _details Details of the dispute\n     */");
insert FunctionDefinition(9311, 7306, "function resolve(\n        uint256 _clientAward,\n        uint256 _providerAward,\n        bytes32 _details\n    ) external virtual override nonReentrant {\n        if (resolverType != ADR.INDIVIDUAL) revert InvalidIndividualResolver();\n        if (!locked) revert Locked();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n        if (_msgSender() != resolver) revert NotResolver();\n\n        uint256 resolutionFee = balance / resolutionRate;\n\n        if (_clientAward + _providerAward != balance - resolutionFee)\n            revert ResolutionMismatch();\n\n        if (_providerAward > 0) {\n            _transferPayment(token, _providerAward);\n        }\n        if (_clientAward > 0) {\n            _withdrawDeposit(token, _clientAward);\n        }\n        if (resolutionFee > 0) {\n            IERC20(token).safeTransfer(resolver, resolutionFee);\n        }\n\n        milestone = amounts.length;\n        locked = false;\n\n        emit Resolve(\n            _msgSender(),\n            _clientAward,\n            _providerAward,\n            resolutionFee,\n            _details\n        );\n    }");
insert Identifier(9312, 9311, "resolve");
insert Parameter(9313, 9311, "uint256 _clientAward");
insert TypeName(9314, 9313, "uint256");
insert PrimitiveType(9315, 9314, "uint256");
insert Identifier(9316, 9313, "_clientAward");
insert Parameter(9317, 9311, "uint256 _providerAward");
insert TypeName(9318, 9317, "uint256");
insert PrimitiveType(9319, 9318, "uint256");
insert Identifier(9320, 9317, "_providerAward");
insert Parameter(9321, 9311, "bytes32 _details");
insert TypeName(9322, 9321, "bytes32");
insert PrimitiveType(9323, 9322, "bytes32");
insert Identifier(9324, 9321, "_details");
insert Visibility(9325, 9311, "external");
insert Virtual(9326, 9311, "virtual");
insert OverrideSpecifier(9327, 9311, "override");
insert ModifierInvocation(9328, 9311, "nonReentrant");
insert Identifier(9329, 9328, "nonReentrant");
insert FunctionBody(9330, 9311, "{\n        if (resolverType != ADR.INDIVIDUAL) revert InvalidIndividualResolver();\n        if (!locked) revert Locked();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n        if (_msgSender() != resolver) revert NotResolver();\n\n        uint256 resolutionFee = balance / resolutionRate;\n\n        if (_clientAward + _providerAward != balance - resolutionFee)\n            revert ResolutionMismatch();\n\n        if (_providerAward > 0) {\n            _transferPayment(token, _providerAward);\n        }\n        if (_clientAward > 0) {\n            _withdrawDeposit(token, _clientAward);\n        }\n        if (resolutionFee > 0) {\n            IERC20(token).safeTransfer(resolver, resolutionFee);\n        }\n\n        milestone = amounts.length;\n        locked = false;\n\n        emit Resolve(\n            _msgSender(),\n            _clientAward,\n            _providerAward,\n            resolutionFee,\n            _details\n        );\n    }");
insert Statement(9331, 9330, "if (resolverType != ADR.INDIVIDUAL) revert InvalidIndividualResolver();");
insert IfStatement(9332, 9331, "if (resolverType != ADR.INDIVIDUAL) revert InvalidIndividualResolver();");
insert Expression(9333, 9332, "resolverType != ADR.INDIVIDUAL");
insert BinaryExpression(9334, 9333, "resolverType != ADR.INDIVIDUAL");
insert Expression(9335, 9334, "resolverType");
insert Identifier(9336, 9335, "resolverType");
insert Expression(9337, 9334, "ADR.INDIVIDUAL");
insert MemberExpression(9338, 9337, "ADR.INDIVIDUAL");
insert Identifier(9339, 9338, "ADR");
insert Identifier(9340, 9338, "INDIVIDUAL");
insert Statement(9341, 9332, "revert InvalidIndividualResolver();");
insert RevertStatement(9342, 9341, "revert InvalidIndividualResolver();");
insert Expression(9343, 9342, "InvalidIndividualResolver");
insert Identifier(9344, 9343, "InvalidIndividualResolver");
insert RevertArguments(9345, 9342, "()");
insert Statement(9346, 9330, "if (!locked) revert Locked();");
insert IfStatement(9347, 9346, "if (!locked) revert Locked();");
insert Expression(9348, 9347, "!locked");
insert UnaryExpression(9349, 9348, "!locked");
insert Expression(9350, 9349, "locked");
insert Identifier(9351, 9350, "locked");
insert Statement(9352, 9347, "revert Locked();");
insert RevertStatement(9353, 9352, "revert Locked();");
insert Expression(9354, 9353, "Locked");
insert Identifier(9355, 9354, "Locked");
insert RevertArguments(9356, 9353, "()");
insert Statement(9357, 9330, "uint256 balance = IERC20(token).balanceOf(address(this));");
insert VariableDeclarationStatement(9358, 9357, "uint256 balance = IERC20(token).balanceOf(address(this));");
insert VariableDeclaration(9359, 9358, "uint256 balance");
insert TypeName(9360, 9359, "uint256");
insert PrimitiveType(9361, 9360, "uint256");
insert Identifier(9362, 9359, "balance");
insert Expression(9363, 9358, "IERC20(token).balanceOf(address(this))");
insert CallExpression(9364, 9363, "IERC20(token).balanceOf(address(this))");
insert Expression(9365, 9364, "IERC20(token).balanceOf");
insert MemberExpression(9366, 9365, "IERC20(token).balanceOf");
insert Expression(9367, 9366, "IERC20(token)");
insert CallExpression(9368, 9367, "IERC20(token)");
insert Expression(9369, 9368, "IERC20");
insert Identifier(9370, 9369, "IERC20");
insert CallArgument(9371, 9368, "token");
insert Expression(9372, 9371, "token");
insert Identifier(9373, 9372, "token");
insert Identifier(9374, 9366, "balanceOf");
insert CallArgument(9375, 9364, "address(this)");
insert Expression(9376, 9375, "address(this)");
insert TypeCastExpression(9377, 9376, "address(this)");
insert PrimitiveType(9378, 9377, "address");
insert CallArgument(9379, 9377, "this");
insert Expression(9380, 9379, "this");
insert Identifier(9381, 9380, "this");
insert Statement(9382, 9330, "if (balance == 0) revert BalanceIsZero();");
insert IfStatement(9383, 9382, "if (balance == 0) revert BalanceIsZero();");
insert Expression(9384, 9383, "balance == 0");
insert BinaryExpression(9385, 9384, "balance == 0");
insert Expression(9386, 9385, "balance");
insert Identifier(9387, 9386, "balance");
insert Expression(9388, 9385, "0");
insert NumberLiteral(9389, 9388, "0");
insert Statement(9390, 9383, "revert BalanceIsZero();");
insert RevertStatement(9391, 9390, "revert BalanceIsZero();");
insert Expression(9392, 9391, "BalanceIsZero");
insert Identifier(9393, 9392, "BalanceIsZero");
insert RevertArguments(9394, 9391, "()");
insert Statement(9395, 9330, "if (_msgSender() != resolver) revert NotResolver();");
insert IfStatement(9396, 9395, "if (_msgSender() != resolver) revert NotResolver();");
insert Expression(9397, 9396, "_msgSender() != resolver");
insert BinaryExpression(9398, 9397, "_msgSender() != resolver");
insert Expression(9399, 9398, "_msgSender()");
insert CallExpression(9400, 9399, "_msgSender()");
insert Expression(9401, 9400, "_msgSender");
insert Identifier(9402, 9401, "_msgSender");
insert Expression(9403, 9398, "resolver");
insert Identifier(9404, 9403, "resolver");
insert Statement(9405, 9396, "revert NotResolver();");
insert RevertStatement(9406, 9405, "revert NotResolver();");
insert Expression(9407, 9406, "NotResolver");
insert Identifier(9408, 9407, "NotResolver");
insert RevertArguments(9409, 9406, "()");
insert Statement(9410, 9330, "uint256 resolutionFee = balance / resolutionRate;");
insert VariableDeclarationStatement(9411, 9410, "uint256 resolutionFee = balance / resolutionRate;");
insert VariableDeclaration(9412, 9411, "uint256 resolutionFee");
insert TypeName(9413, 9412, "uint256");
insert PrimitiveType(9414, 9413, "uint256");
insert Identifier(9415, 9412, "resolutionFee");
insert Expression(9416, 9411, "balance / resolutionRate");
insert BinaryExpression(9417, 9416, "balance / resolutionRate");
insert Expression(9418, 9417, "balance");
insert Identifier(9419, 9418, "balance");
insert Expression(9420, 9417, "resolutionRate");
insert Identifier(9421, 9420, "resolutionRate");
insert Statement(9422, 9330, "if (_clientAward + _providerAward != balance - resolutionFee)\n            revert ResolutionMismatch();");
insert IfStatement(9423, 9422, "if (_clientAward + _providerAward != balance - resolutionFee)\n            revert ResolutionMismatch();");
insert Expression(9424, 9423, "_clientAward + _providerAward != balance - resolutionFee");
insert BinaryExpression(9425, 9424, "_clientAward + _providerAward != balance - resolutionFee");
insert Expression(9426, 9425, "_clientAward + _providerAward");
insert BinaryExpression(9427, 9426, "_clientAward + _providerAward");
insert Expression(9428, 9427, "_clientAward");
insert Identifier(9429, 9428, "_clientAward");
insert Expression(9430, 9427, "_providerAward");
insert Identifier(9431, 9430, "_providerAward");
insert Expression(9432, 9425, "balance - resolutionFee");
insert BinaryExpression(9433, 9432, "balance - resolutionFee");
insert Expression(9434, 9433, "balance");
insert Identifier(9435, 9434, "balance");
insert Expression(9436, 9433, "resolutionFee");
insert Identifier(9437, 9436, "resolutionFee");
insert Statement(9438, 9423, "revert ResolutionMismatch();");
insert RevertStatement(9439, 9438, "revert ResolutionMismatch();");
insert Expression(9440, 9439, "ResolutionMismatch");
insert Identifier(9441, 9440, "ResolutionMismatch");
insert RevertArguments(9442, 9439, "()");
insert Statement(9443, 9330, "if (_providerAward > 0) {\n            _transferPayment(token, _providerAward);\n        }");
insert IfStatement(9444, 9443, "if (_providerAward > 0) {\n            _transferPayment(token, _providerAward);\n        }");
insert Expression(9445, 9444, "_providerAward > 0");
insert BinaryExpression(9446, 9445, "_providerAward > 0");
insert Expression(9447, 9446, "_providerAward");
insert Identifier(9448, 9447, "_providerAward");
insert Expression(9449, 9446, "0");
insert NumberLiteral(9450, 9449, "0");
insert Statement(9451, 9444, "{\n            _transferPayment(token, _providerAward);\n        }");
insert BlockStatement(9452, 9451, "{\n            _transferPayment(token, _providerAward);\n        }");
insert Statement(9453, 9452, "_transferPayment(token, _providerAward);");
insert ExpressionStatement(9454, 9453, "_transferPayment(token, _providerAward);");
insert Expression(9455, 9454, "_transferPayment(token, _providerAward)");
insert CallExpression(9456, 9455, "_transferPayment(token, _providerAward)");
insert Expression(9457, 9456, "_transferPayment");
insert Identifier(9458, 9457, "_transferPayment");
insert CallArgument(9459, 9456, "token");
insert Expression(9460, 9459, "token");
insert Identifier(9461, 9460, "token");
insert CallArgument(9462, 9456, "_providerAward");
insert Expression(9463, 9462, "_providerAward");
insert Identifier(9464, 9463, "_providerAward");
insert Statement(9465, 9330, "if (_clientAward > 0) {\n            _withdrawDeposit(token, _clientAward);\n        }");
insert IfStatement(9466, 9465, "if (_clientAward > 0) {\n            _withdrawDeposit(token, _clientAward);\n        }");
insert Expression(9467, 9466, "_clientAward > 0");
insert BinaryExpression(9468, 9467, "_clientAward > 0");
insert Expression(9469, 9468, "_clientAward");
insert Identifier(9470, 9469, "_clientAward");
insert Expression(9471, 9468, "0");
insert NumberLiteral(9472, 9471, "0");
insert Statement(9473, 9466, "{\n            _withdrawDeposit(token, _clientAward);\n        }");
insert BlockStatement(9474, 9473, "{\n            _withdrawDeposit(token, _clientAward);\n        }");
insert Statement(9475, 9474, "_withdrawDeposit(token, _clientAward);");
insert ExpressionStatement(9476, 9475, "_withdrawDeposit(token, _clientAward);");
insert Expression(9477, 9476, "_withdrawDeposit(token, _clientAward)");
insert CallExpression(9478, 9477, "_withdrawDeposit(token, _clientAward)");
insert Expression(9479, 9478, "_withdrawDeposit");
insert Identifier(9480, 9479, "_withdrawDeposit");
insert CallArgument(9481, 9478, "token");
insert Expression(9482, 9481, "token");
insert Identifier(9483, 9482, "token");
insert CallArgument(9484, 9478, "_clientAward");
insert Expression(9485, 9484, "_clientAward");
insert Identifier(9486, 9485, "_clientAward");
insert Statement(9487, 9330, "if (resolutionFee > 0) {\n            IERC20(token).safeTransfer(resolver, resolutionFee);\n        }");
insert IfStatement(9488, 9487, "if (resolutionFee > 0) {\n            IERC20(token).safeTransfer(resolver, resolutionFee);\n        }");
insert Expression(9489, 9488, "resolutionFee > 0");
insert BinaryExpression(9490, 9489, "resolutionFee > 0");
insert Expression(9491, 9490, "resolutionFee");
insert Identifier(9492, 9491, "resolutionFee");
insert Expression(9493, 9490, "0");
insert NumberLiteral(9494, 9493, "0");
insert Statement(9495, 9488, "{\n            IERC20(token).safeTransfer(resolver, resolutionFee);\n        }");
insert BlockStatement(9496, 9495, "{\n            IERC20(token).safeTransfer(resolver, resolutionFee);\n        }");
insert Statement(9497, 9496, "IERC20(token).safeTransfer(resolver, resolutionFee);");
insert ExpressionStatement(9498, 9497, "IERC20(token).safeTransfer(resolver, resolutionFee);");
insert Expression(9499, 9498, "IERC20(token).safeTransfer(resolver, resolutionFee)");
insert CallExpression(9500, 9499, "IERC20(token).safeTransfer(resolver, resolutionFee)");
insert Expression(9501, 9500, "IERC20(token).safeTransfer");
insert MemberExpression(9502, 9501, "IERC20(token).safeTransfer");
insert Expression(9503, 9502, "IERC20(token)");
insert CallExpression(9504, 9503, "IERC20(token)");
insert Expression(9505, 9504, "IERC20");
insert Identifier(9506, 9505, "IERC20");
insert CallArgument(9507, 9504, "token");
insert Expression(9508, 9507, "token");
insert Identifier(9509, 9508, "token");
insert Identifier(9510, 9502, "safeTransfer");
insert CallArgument(9511, 9500, "resolver");
insert Expression(9512, 9511, "resolver");
insert Identifier(9513, 9512, "resolver");
insert CallArgument(9514, 9500, "resolutionFee");
insert Expression(9515, 9514, "resolutionFee");
insert Identifier(9516, 9515, "resolutionFee");
insert Statement(9517, 9330, "milestone = amounts.length;");
insert ExpressionStatement(9518, 9517, "milestone = amounts.length;");
insert Expression(9519, 9518, "milestone = amounts.length");
insert AssignmentExpression(9520, 9519, "milestone = amounts.length");
insert Expression(9521, 9520, "milestone");
insert Identifier(9522, 9521, "milestone");
insert Expression(9523, 9520, "amounts.length");
insert MemberExpression(9524, 9523, "amounts.length");
insert Identifier(9525, 9524, "amounts");
insert Identifier(9526, 9524, "length");
insert Statement(9527, 9330, "locked = false;");
insert ExpressionStatement(9528, 9527, "locked = false;");
insert Expression(9529, 9528, "locked = false");
insert AssignmentExpression(9530, 9529, "locked = false");
insert Expression(9531, 9530, "locked");
insert Identifier(9532, 9531, "locked");
insert Expression(9533, 9530, "false");
insert BooleanLiteral(9534, 9533, "false");
insert False(9535, 9534, "false");
insert Statement(9536, 9330, "emit Resolve(\n            _msgSender(),\n            _clientAward,\n            _providerAward,\n            resolutionFee,\n            _details\n        );");
insert EmitStatement(9537, 9536, "emit Resolve(\n            _msgSender(),\n            _clientAward,\n            _providerAward,\n            resolutionFee,\n            _details\n        );");
insert Expression(9538, 9537, "Resolve");
insert Identifier(9539, 9538, "Resolve");
insert CallArgument(9540, 9537, "_msgSender()");
insert Expression(9541, 9540, "_msgSender()");
insert CallExpression(9542, 9541, "_msgSender()");
insert Expression(9543, 9542, "_msgSender");
insert Identifier(9544, 9543, "_msgSender");
insert CallArgument(9545, 9537, "_clientAward");
insert Expression(9546, 9545, "_clientAward");
insert Identifier(9547, 9546, "_clientAward");
insert CallArgument(9548, 9537, "_providerAward");
insert Expression(9549, 9548, "_providerAward");
insert Identifier(9550, 9549, "_providerAward");
insert CallArgument(9551, 9537, "resolutionFee");
insert Expression(9552, 9551, "resolutionFee");
insert Identifier(9553, 9552, "resolutionFee");
insert CallArgument(9554, 9537, "_details");
insert Expression(9555, 9554, "_details");
insert Identifier(9556, 9555, "_details");
insert Comment(9557, 7306, "/**\n     * @dev External function to rule on a dispute.\n     * @param _disputeId The ID of the dispute\n     * @param _ruling The ruling of the arbitrator\n     */");
insert FunctionDefinition(9558, 7306, "function rule(\n        uint256 _disputeId,\n        uint256 _ruling\n    ) external virtual override nonReentrant {\n        if (resolverType != ADR.ARBITRATOR) revert InvalidArbitratorResolver();\n        if (!locked) revert Locked();\n        if (_msgSender() != resolver) revert NotResolver();\n        if (_disputeId != disputeId) revert IncorrectDisputeId();\n        if (_ruling > NUM_RULING_OPTIONS) revert InvalidRuling();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n\n        uint8[2] memory ruling = _getRuling(_ruling);\n        uint8 clientShare = ruling[0];\n        uint8 providerShare = ruling[1];\n        uint8 denom = clientShare + providerShare;\n        uint256 providerAward = (balance * providerShare) / denom;\n        uint256 clientAward = balance - providerAward;\n\n        if (providerAward > 0) {\n            _transferPayment(token, providerAward);\n        }\n        if (clientAward > 0) {\n            _withdrawDeposit(token, clientAward);\n        }\n\n        milestone = amounts.length;\n        locked = false;\n\n        emit Rule(resolver, clientAward, providerAward, _ruling);\n        emit Ruling(resolver, _disputeId, _ruling);\n    }");
insert Identifier(9559, 9558, "rule");
insert Parameter(9560, 9558, "uint256 _disputeId");
insert TypeName(9561, 9560, "uint256");
insert PrimitiveType(9562, 9561, "uint256");
insert Identifier(9563, 9560, "_disputeId");
insert Parameter(9564, 9558, "uint256 _ruling");
insert TypeName(9565, 9564, "uint256");
insert PrimitiveType(9566, 9565, "uint256");
insert Identifier(9567, 9564, "_ruling");
insert Visibility(9568, 9558, "external");
insert Virtual(9569, 9558, "virtual");
insert OverrideSpecifier(9570, 9558, "override");
insert ModifierInvocation(9571, 9558, "nonReentrant");
insert Identifier(9572, 9571, "nonReentrant");
insert FunctionBody(9573, 9558, "{\n        if (resolverType != ADR.ARBITRATOR) revert InvalidArbitratorResolver();\n        if (!locked) revert Locked();\n        if (_msgSender() != resolver) revert NotResolver();\n        if (_disputeId != disputeId) revert IncorrectDisputeId();\n        if (_ruling > NUM_RULING_OPTIONS) revert InvalidRuling();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance == 0) revert BalanceIsZero();\n\n        uint8[2] memory ruling = _getRuling(_ruling);\n        uint8 clientShare = ruling[0];\n        uint8 providerShare = ruling[1];\n        uint8 denom = clientShare + providerShare;\n        uint256 providerAward = (balance * providerShare) / denom;\n        uint256 clientAward = balance - providerAward;\n\n        if (providerAward > 0) {\n            _transferPayment(token, providerAward);\n        }\n        if (clientAward > 0) {\n            _withdrawDeposit(token, clientAward);\n        }\n\n        milestone = amounts.length;\n        locked = false;\n\n        emit Rule(resolver, clientAward, providerAward, _ruling);\n        emit Ruling(resolver, _disputeId, _ruling);\n    }");
insert Statement(9574, 9573, "if (resolverType != ADR.ARBITRATOR) revert InvalidArbitratorResolver();");
insert IfStatement(9575, 9574, "if (resolverType != ADR.ARBITRATOR) revert InvalidArbitratorResolver();");
insert Expression(9576, 9575, "resolverType != ADR.ARBITRATOR");
insert BinaryExpression(9577, 9576, "resolverType != ADR.ARBITRATOR");
insert Expression(9578, 9577, "resolverType");
insert Identifier(9579, 9578, "resolverType");
insert Expression(9580, 9577, "ADR.ARBITRATOR");
insert MemberExpression(9581, 9580, "ADR.ARBITRATOR");
insert Identifier(9582, 9581, "ADR");
insert Identifier(9583, 9581, "ARBITRATOR");
insert Statement(9584, 9575, "revert InvalidArbitratorResolver();");
insert RevertStatement(9585, 9584, "revert InvalidArbitratorResolver();");
insert Expression(9586, 9585, "InvalidArbitratorResolver");
insert Identifier(9587, 9586, "InvalidArbitratorResolver");
insert RevertArguments(9588, 9585, "()");
insert Statement(9589, 9573, "if (!locked) revert Locked();");
insert IfStatement(9590, 9589, "if (!locked) revert Locked();");
insert Expression(9591, 9590, "!locked");
insert UnaryExpression(9592, 9591, "!locked");
insert Expression(9593, 9592, "locked");
insert Identifier(9594, 9593, "locked");
insert Statement(9595, 9590, "revert Locked();");
insert RevertStatement(9596, 9595, "revert Locked();");
insert Expression(9597, 9596, "Locked");
insert Identifier(9598, 9597, "Locked");
insert RevertArguments(9599, 9596, "()");
insert Statement(9600, 9573, "if (_msgSender() != resolver) revert NotResolver();");
insert IfStatement(9601, 9600, "if (_msgSender() != resolver) revert NotResolver();");
insert Expression(9602, 9601, "_msgSender() != resolver");
insert BinaryExpression(9603, 9602, "_msgSender() != resolver");
insert Expression(9604, 9603, "_msgSender()");
insert CallExpression(9605, 9604, "_msgSender()");
insert Expression(9606, 9605, "_msgSender");
insert Identifier(9607, 9606, "_msgSender");
insert Expression(9608, 9603, "resolver");
insert Identifier(9609, 9608, "resolver");
insert Statement(9610, 9601, "revert NotResolver();");
insert RevertStatement(9611, 9610, "revert NotResolver();");
insert Expression(9612, 9611, "NotResolver");
insert Identifier(9613, 9612, "NotResolver");
insert RevertArguments(9614, 9611, "()");
insert Statement(9615, 9573, "if (_disputeId != disputeId) revert IncorrectDisputeId();");
insert IfStatement(9616, 9615, "if (_disputeId != disputeId) revert IncorrectDisputeId();");
insert Expression(9617, 9616, "_disputeId != disputeId");
insert BinaryExpression(9618, 9617, "_disputeId != disputeId");
insert Expression(9619, 9618, "_disputeId");
insert Identifier(9620, 9619, "_disputeId");
insert Expression(9621, 9618, "disputeId");
insert Identifier(9622, 9621, "disputeId");
insert Statement(9623, 9616, "revert IncorrectDisputeId();");
insert RevertStatement(9624, 9623, "revert IncorrectDisputeId();");
insert Expression(9625, 9624, "IncorrectDisputeId");
insert Identifier(9626, 9625, "IncorrectDisputeId");
insert RevertArguments(9627, 9624, "()");
insert Statement(9628, 9573, "if (_ruling > NUM_RULING_OPTIONS) revert InvalidRuling();");
insert IfStatement(9629, 9628, "if (_ruling > NUM_RULING_OPTIONS) revert InvalidRuling();");
insert Expression(9630, 9629, "_ruling > NUM_RULING_OPTIONS");
insert BinaryExpression(9631, 9630, "_ruling > NUM_RULING_OPTIONS");
insert Expression(9632, 9631, "_ruling");
insert Identifier(9633, 9632, "_ruling");
insert Expression(9634, 9631, "NUM_RULING_OPTIONS");
insert Identifier(9635, 9634, "NUM_RULING_OPTIONS");
insert Statement(9636, 9629, "revert InvalidRuling();");
insert RevertStatement(9637, 9636, "revert InvalidRuling();");
insert Expression(9638, 9637, "InvalidRuling");
insert Identifier(9639, 9638, "InvalidRuling");
insert RevertArguments(9640, 9637, "()");
insert Statement(9641, 9573, "uint256 balance = IERC20(token).balanceOf(address(this));");
insert VariableDeclarationStatement(9642, 9641, "uint256 balance = IERC20(token).balanceOf(address(this));");
insert VariableDeclaration(9643, 9642, "uint256 balance");
insert TypeName(9644, 9643, "uint256");
insert PrimitiveType(9645, 9644, "uint256");
insert Identifier(9646, 9643, "balance");
insert Expression(9647, 9642, "IERC20(token).balanceOf(address(this))");
insert CallExpression(9648, 9647, "IERC20(token).balanceOf(address(this))");
insert Expression(9649, 9648, "IERC20(token).balanceOf");
insert MemberExpression(9650, 9649, "IERC20(token).balanceOf");
insert Expression(9651, 9650, "IERC20(token)");
insert CallExpression(9652, 9651, "IERC20(token)");
insert Expression(9653, 9652, "IERC20");
insert Identifier(9654, 9653, "IERC20");
insert CallArgument(9655, 9652, "token");
insert Expression(9656, 9655, "token");
insert Identifier(9657, 9656, "token");
insert Identifier(9658, 9650, "balanceOf");
insert CallArgument(9659, 9648, "address(this)");
insert Expression(9660, 9659, "address(this)");
insert TypeCastExpression(9661, 9660, "address(this)");
insert PrimitiveType(9662, 9661, "address");
insert CallArgument(9663, 9661, "this");
insert Expression(9664, 9663, "this");
insert Identifier(9665, 9664, "this");
insert Statement(9666, 9573, "if (balance == 0) revert BalanceIsZero();");
insert IfStatement(9667, 9666, "if (balance == 0) revert BalanceIsZero();");
insert Expression(9668, 9667, "balance == 0");
insert BinaryExpression(9669, 9668, "balance == 0");
insert Expression(9670, 9669, "balance");
insert Identifier(9671, 9670, "balance");
insert Expression(9672, 9669, "0");
insert NumberLiteral(9673, 9672, "0");
insert Statement(9674, 9667, "revert BalanceIsZero();");
insert RevertStatement(9675, 9674, "revert BalanceIsZero();");
insert Expression(9676, 9675, "BalanceIsZero");
insert Identifier(9677, 9676, "BalanceIsZero");
insert RevertArguments(9678, 9675, "()");
insert Statement(9679, 9573, "uint8[2] memory ruling = _getRuling(_ruling);");
insert VariableDeclarationStatement(9680, 9679, "uint8[2] memory ruling = _getRuling(_ruling);");
insert VariableDeclaration(9681, 9680, "uint8[2] memory ruling");
insert TypeName(9682, 9681, "uint8[2]");
insert TypeName(9683, 9682, "uint8");
insert PrimitiveType(9684, 9683, "uint8");
insert Expression(9685, 9682, "2");
insert NumberLiteral(9686, 9685, "2");
insert Identifier(9687, 9681, "ruling");
insert Expression(9688, 9680, "_getRuling(_ruling)");
insert CallExpression(9689, 9688, "_getRuling(_ruling)");
insert Expression(9690, 9689, "_getRuling");
insert Identifier(9691, 9690, "_getRuling");
insert CallArgument(9692, 9689, "_ruling");
insert Expression(9693, 9692, "_ruling");
insert Identifier(9694, 9693, "_ruling");
insert Statement(9695, 9573, "uint8 clientShare = ruling[0];");
insert VariableDeclarationStatement(9696, 9695, "uint8 clientShare = ruling[0];");
insert VariableDeclaration(9697, 9696, "uint8 clientShare");
insert TypeName(9698, 9697, "uint8");
insert PrimitiveType(9699, 9698, "uint8");
insert Identifier(9700, 9697, "clientShare");
insert Expression(9701, 9696, "ruling[0]");
insert ArrayAccess(9702, 9701, "ruling[0]");
insert Expression(9703, 9702, "ruling");
insert Identifier(9704, 9703, "ruling");
insert Expression(9705, 9702, "0");
insert NumberLiteral(9706, 9705, "0");
insert Statement(9707, 9573, "uint8 providerShare = ruling[1];");
insert VariableDeclarationStatement(9708, 9707, "uint8 providerShare = ruling[1];");
insert VariableDeclaration(9709, 9708, "uint8 providerShare");
insert TypeName(9710, 9709, "uint8");
insert PrimitiveType(9711, 9710, "uint8");
insert Identifier(9712, 9709, "providerShare");
insert Expression(9713, 9708, "ruling[1]");
insert ArrayAccess(9714, 9713, "ruling[1]");
insert Expression(9715, 9714, "ruling");
insert Identifier(9716, 9715, "ruling");
insert Expression(9717, 9714, "1");
insert NumberLiteral(9718, 9717, "1");
insert Statement(9719, 9573, "uint8 denom = clientShare + providerShare;");
insert VariableDeclarationStatement(9720, 9719, "uint8 denom = clientShare + providerShare;");
insert VariableDeclaration(9721, 9720, "uint8 denom");
insert TypeName(9722, 9721, "uint8");
insert PrimitiveType(9723, 9722, "uint8");
insert Identifier(9724, 9721, "denom");
insert Expression(9725, 9720, "clientShare + providerShare");
insert BinaryExpression(9726, 9725, "clientShare + providerShare");
insert Expression(9727, 9726, "clientShare");
insert Identifier(9728, 9727, "clientShare");
insert Expression(9729, 9726, "providerShare");
insert Identifier(9730, 9729, "providerShare");
insert Statement(9731, 9573, "uint256 providerAward = (balance * providerShare) / denom;");
insert VariableDeclarationStatement(9732, 9731, "uint256 providerAward = (balance * providerShare) / denom;");
insert VariableDeclaration(9733, 9732, "uint256 providerAward");
insert TypeName(9734, 9733, "uint256");
insert PrimitiveType(9735, 9734, "uint256");
insert Identifier(9736, 9733, "providerAward");
insert Expression(9737, 9732, "(balance * providerShare) / denom");
insert BinaryExpression(9738, 9737, "(balance * providerShare) / denom");
insert Expression(9739, 9738, "(balance * providerShare)");
insert ParenthesizedExpression(9740, 9739, "(balance * providerShare)");
insert Expression(9741, 9740, "balance * providerShare");
insert BinaryExpression(9742, 9741, "balance * providerShare");
insert Expression(9743, 9742, "balance");
insert Identifier(9744, 9743, "balance");
insert Expression(9745, 9742, "providerShare");
insert Identifier(9746, 9745, "providerShare");
insert Expression(9747, 9738, "denom");
insert Identifier(9748, 9747, "denom");
insert Statement(9749, 9573, "uint256 clientAward = balance - providerAward;");
insert VariableDeclarationStatement(9750, 9749, "uint256 clientAward = balance - providerAward;");
insert VariableDeclaration(9751, 9750, "uint256 clientAward");
insert TypeName(9752, 9751, "uint256");
insert PrimitiveType(9753, 9752, "uint256");
insert Identifier(9754, 9751, "clientAward");
insert Expression(9755, 9750, "balance - providerAward");
insert BinaryExpression(9756, 9755, "balance - providerAward");
insert Expression(9757, 9756, "balance");
insert Identifier(9758, 9757, "balance");
insert Expression(9759, 9756, "providerAward");
insert Identifier(9760, 9759, "providerAward");
insert Statement(9761, 9573, "if (providerAward > 0) {\n            _transferPayment(token, providerAward);\n        }");
insert IfStatement(9762, 9761, "if (providerAward > 0) {\n            _transferPayment(token, providerAward);\n        }");
insert Expression(9763, 9762, "providerAward > 0");
insert BinaryExpression(9764, 9763, "providerAward > 0");
insert Expression(9765, 9764, "providerAward");
insert Identifier(9766, 9765, "providerAward");
insert Expression(9767, 9764, "0");
insert NumberLiteral(9768, 9767, "0");
insert Statement(9769, 9762, "{\n            _transferPayment(token, providerAward);\n        }");
insert BlockStatement(9770, 9769, "{\n            _transferPayment(token, providerAward);\n        }");
insert Statement(9771, 9770, "_transferPayment(token, providerAward);");
insert ExpressionStatement(9772, 9771, "_transferPayment(token, providerAward);");
insert Expression(9773, 9772, "_transferPayment(token, providerAward)");
insert CallExpression(9774, 9773, "_transferPayment(token, providerAward)");
insert Expression(9775, 9774, "_transferPayment");
insert Identifier(9776, 9775, "_transferPayment");
insert CallArgument(9777, 9774, "token");
insert Expression(9778, 9777, "token");
insert Identifier(9779, 9778, "token");
insert CallArgument(9780, 9774, "providerAward");
insert Expression(9781, 9780, "providerAward");
insert Identifier(9782, 9781, "providerAward");
insert Statement(9783, 9573, "if (clientAward > 0) {\n            _withdrawDeposit(token, clientAward);\n        }");
insert IfStatement(9784, 9783, "if (clientAward > 0) {\n            _withdrawDeposit(token, clientAward);\n        }");
insert Expression(9785, 9784, "clientAward > 0");
insert BinaryExpression(9786, 9785, "clientAward > 0");
insert Expression(9787, 9786, "clientAward");
insert Identifier(9788, 9787, "clientAward");
insert Expression(9789, 9786, "0");
insert NumberLiteral(9790, 9789, "0");
insert Statement(9791, 9784, "{\n            _withdrawDeposit(token, clientAward);\n        }");
insert BlockStatement(9792, 9791, "{\n            _withdrawDeposit(token, clientAward);\n        }");
insert Statement(9793, 9792, "_withdrawDeposit(token, clientAward);");
insert ExpressionStatement(9794, 9793, "_withdrawDeposit(token, clientAward);");
insert Expression(9795, 9794, "_withdrawDeposit(token, clientAward)");
insert CallExpression(9796, 9795, "_withdrawDeposit(token, clientAward)");
insert Expression(9797, 9796, "_withdrawDeposit");
insert Identifier(9798, 9797, "_withdrawDeposit");
insert CallArgument(9799, 9796, "token");
insert Expression(9800, 9799, "token");
insert Identifier(9801, 9800, "token");
insert CallArgument(9802, 9796, "clientAward");
insert Expression(9803, 9802, "clientAward");
insert Identifier(9804, 9803, "clientAward");
insert Statement(9805, 9573, "milestone = amounts.length;");
insert ExpressionStatement(9806, 9805, "milestone = amounts.length;");
insert Expression(9807, 9806, "milestone = amounts.length");
insert AssignmentExpression(9808, 9807, "milestone = amounts.length");
insert Expression(9809, 9808, "milestone");
insert Identifier(9810, 9809, "milestone");
insert Expression(9811, 9808, "amounts.length");
insert MemberExpression(9812, 9811, "amounts.length");
insert Identifier(9813, 9812, "amounts");
insert Identifier(9814, 9812, "length");
insert Statement(9815, 9573, "locked = false;");
insert ExpressionStatement(9816, 9815, "locked = false;");
insert Expression(9817, 9816, "locked = false");
insert AssignmentExpression(9818, 9817, "locked = false");
insert Expression(9819, 9818, "locked");
insert Identifier(9820, 9819, "locked");
insert Expression(9821, 9818, "false");
insert BooleanLiteral(9822, 9821, "false");
insert False(9823, 9822, "false");
insert Statement(9824, 9573, "emit Rule(resolver, clientAward, providerAward, _ruling);");
insert EmitStatement(9825, 9824, "emit Rule(resolver, clientAward, providerAward, _ruling);");
insert Expression(9826, 9825, "Rule");
insert Identifier(9827, 9826, "Rule");
insert CallArgument(9828, 9825, "resolver");
insert Expression(9829, 9828, "resolver");
insert Identifier(9830, 9829, "resolver");
insert CallArgument(9831, 9825, "clientAward");
insert Expression(9832, 9831, "clientAward");
insert Identifier(9833, 9832, "clientAward");
insert CallArgument(9834, 9825, "providerAward");
insert Expression(9835, 9834, "providerAward");
insert Identifier(9836, 9835, "providerAward");
insert CallArgument(9837, 9825, "_ruling");
insert Expression(9838, 9837, "_ruling");
insert Identifier(9839, 9838, "_ruling");
insert Statement(9840, 9573, "emit Ruling(resolver, _disputeId, _ruling);");
insert EmitStatement(9841, 9840, "emit Ruling(resolver, _disputeId, _ruling);");
insert Expression(9842, 9841, "Ruling");
insert Identifier(9843, 9842, "Ruling");
insert CallArgument(9844, 9841, "resolver");
insert Expression(9845, 9844, "resolver");
insert Identifier(9846, 9845, "resolver");
insert CallArgument(9847, 9841, "_disputeId");
insert Expression(9848, 9847, "_disputeId");
insert Identifier(9849, 9848, "_disputeId");
insert CallArgument(9850, 9841, "_ruling");
insert Expression(9851, 9850, "_ruling");
insert Identifier(9852, 9851, "_ruling");
insert Comment(9853, 7306, "/**\n     * @dev Internal function to get the ruling of the arbitrator.\n     * @param _ruling The ruling of the arbitrator\n     */");
insert FunctionDefinition(9854, 7306, "function _getRuling(\n        uint256 _ruling\n    ) internal pure returns (uint8[2] memory ruling) {\n        uint8[2][6] memory rulings = [\n            [1, 1], // 0 = refused to arbitrate\n            [1, 0], // 1 = 100% to client\n            [3, 1], // 2 = 75% to client\n            [1, 1], // 3 = 50% to client\n            [1, 3], // 4 = 25% to client\n            [0, 1] // 5 = 0% to client\n        ];\n        ruling = rulings[_ruling];\n    }");
insert Identifier(9855, 9854, "_getRuling");
insert Parameter(9856, 9854, "uint256 _ruling");
insert TypeName(9857, 9856, "uint256");
insert PrimitiveType(9858, 9857, "uint256");
insert Identifier(9859, 9856, "_ruling");
insert Visibility(9860, 9854, "internal");
insert StateMutability(9861, 9854, "pure");
insert ReturnTypeDefinition(9862, 9854, "returns (uint8[2] memory ruling)");
insert Parameter(9863, 9862, "uint8[2] memory ruling");
insert TypeName(9864, 9863, "uint8[2]");
insert TypeName(9865, 9864, "uint8");
insert PrimitiveType(9866, 9865, "uint8");
insert Expression(9867, 9864, "2");
insert NumberLiteral(9868, 9867, "2");
insert Identifier(9869, 9863, "ruling");
insert FunctionBody(9870, 9854, "{\n        uint8[2][6] memory rulings = [\n            [1, 1], // 0 = refused to arbitrate\n            [1, 0], // 1 = 100% to client\n            [3, 1], // 2 = 75% to client\n            [1, 1], // 3 = 50% to client\n            [1, 3], // 4 = 25% to client\n            [0, 1] // 5 = 0% to client\n        ];\n        ruling = rulings[_ruling];\n    }");
insert Statement(9871, 9870, "uint8[2][6] memory rulings = [\n            [1, 1], // 0 = refused to arbitrate\n            [1, 0], // 1 = 100% to client\n            [3, 1], // 2 = 75% to client\n            [1, 1], // 3 = 50% to client\n            [1, 3], // 4 = 25% to client\n            [0, 1] // 5 = 0% to client\n        ];");
insert VariableDeclarationStatement(9872, 9871, "uint8[2][6] memory rulings = [\n            [1, 1], // 0 = refused to arbitrate\n            [1, 0], // 1 = 100% to client\n            [3, 1], // 2 = 75% to client\n            [1, 1], // 3 = 50% to client\n            [1, 3], // 4 = 25% to client\n            [0, 1] // 5 = 0% to client\n        ];");
insert VariableDeclaration(9873, 9872, "uint8[2][6] memory rulings");
insert TypeName(9874, 9873, "uint8[2][6]");
insert TypeName(9875, 9874, "uint8[2]");
insert TypeName(9876, 9875, "uint8");
insert PrimitiveType(9877, 9876, "uint8");
insert Expression(9878, 9875, "2");
insert NumberLiteral(9879, 9878, "2");
insert Expression(9880, 9874, "6");
insert NumberLiteral(9881, 9880, "6");
insert Identifier(9882, 9873, "rulings");
insert Expression(9883, 9872, "[\n            [1, 1], // 0 = refused to arbitrate\n            [1, 0], // 1 = 100% to client\n            [3, 1], // 2 = 75% to client\n            [1, 1], // 3 = 50% to client\n            [1, 3], // 4 = 25% to client\n            [0, 1] // 5 = 0% to client\n        ]");
insert InlineArrayExpression(9884, 9883, "[\n            [1, 1], // 0 = refused to arbitrate\n            [1, 0], // 1 = 100% to client\n            [3, 1], // 2 = 75% to client\n            [1, 1], // 3 = 50% to client\n            [1, 3], // 4 = 25% to client\n            [0, 1] // 5 = 0% to client\n        ]");
insert Expression(9885, 9884, "[1, 1]");
insert InlineArrayExpression(9886, 9885, "[1, 1]");
insert Expression(9887, 9886, "1");
insert NumberLiteral(9888, 9887, "1");
insert Expression(9889, 9886, "1");
insert NumberLiteral(9890, 9889, "1");
insert Comment(9891, 9884, "// 0 = refused to arbitrate");
insert Expression(9892, 9884, "[1, 0]");
insert InlineArrayExpression(9893, 9892, "[1, 0]");
insert Expression(9894, 9893, "1");
insert NumberLiteral(9895, 9894, "1");
insert Expression(9896, 9893, "0");
insert NumberLiteral(9897, 9896, "0");
insert Comment(9898, 9884, "// 1 = 100% to client");
insert Expression(9899, 9884, "[3, 1]");
insert InlineArrayExpression(9900, 9899, "[3, 1]");
insert Expression(9901, 9900, "3");
insert NumberLiteral(9902, 9901, "3");
insert Expression(9903, 9900, "1");
insert NumberLiteral(9904, 9903, "1");
insert Comment(9905, 9884, "// 2 = 75% to client");
insert Expression(9906, 9884, "[1, 1]");
insert InlineArrayExpression(9907, 9906, "[1, 1]");
insert Expression(9908, 9907, "1");
insert NumberLiteral(9909, 9908, "1");
insert Expression(9910, 9907, "1");
insert NumberLiteral(9911, 9910, "1");
insert Comment(9912, 9884, "// 3 = 50% to client");
insert Expression(9913, 9884, "[1, 3]");
insert InlineArrayExpression(9914, 9913, "[1, 3]");
insert Expression(9915, 9914, "1");
insert NumberLiteral(9916, 9915, "1");
insert Expression(9917, 9914, "3");
insert NumberLiteral(9918, 9917, "3");
insert Comment(9919, 9884, "// 4 = 25% to client");
insert Expression(9920, 9884, "[0, 1]");
insert InlineArrayExpression(9921, 9920, "[0, 1]");
insert Expression(9922, 9921, "0");
insert NumberLiteral(9923, 9922, "0");
insert Expression(9924, 9921, "1");
insert NumberLiteral(9925, 9924, "1");
insert Comment(9926, 9884, "// 5 = 0% to client");
insert Statement(9927, 9870, "ruling = rulings[_ruling];");
insert ExpressionStatement(9928, 9927, "ruling = rulings[_ruling];");
insert Expression(9929, 9928, "ruling = rulings[_ruling]");
insert AssignmentExpression(9930, 9929, "ruling = rulings[_ruling]");
insert Expression(9931, 9930, "ruling");
insert Identifier(9932, 9931, "ruling");
insert Expression(9933, 9930, "rulings[_ruling]");
insert ArrayAccess(9934, 9933, "rulings[_ruling]");
insert Expression(9935, 9934, "rulings");
insert Identifier(9936, 9935, "rulings");
insert Expression(9937, 9934, "_ruling");
insert Identifier(9938, 9937, "_ruling");
insert Comment(9939, 7306, "/**\n     * @dev Internal function to transfer payment to the provider.\n     * @param _token The token to transfer\n     * @param _amount The amount to transfer\n     */");
insert FunctionDefinition(9940, 7306, "function _transferPayment(\n        address _token,\n        uint256 _amount\n    ) internal virtual {\n        IERC20(_token).safeTransfer(provider, _amount);\n    }");
insert Identifier(9941, 9940, "_transferPayment");
insert Parameter(9942, 9940, "address _token");
insert TypeName(9943, 9942, "address");
insert PrimitiveType(9944, 9943, "address");
insert Identifier(9945, 9942, "_token");
insert Parameter(9946, 9940, "uint256 _amount");
insert TypeName(9947, 9946, "uint256");
insert PrimitiveType(9948, 9947, "uint256");
insert Identifier(9949, 9946, "_amount");
insert Visibility(9950, 9940, "internal");
insert Virtual(9951, 9940, "virtual");
insert FunctionBody(9952, 9940, "{\n        IERC20(_token).safeTransfer(provider, _amount);\n    }");
insert Statement(9953, 9952, "IERC20(_token).safeTransfer(provider, _amount);");
insert ExpressionStatement(9954, 9953, "IERC20(_token).safeTransfer(provider, _amount);");
insert Expression(9955, 9954, "IERC20(_token).safeTransfer(provider, _amount)");
insert CallExpression(9956, 9955, "IERC20(_token).safeTransfer(provider, _amount)");
insert Expression(9957, 9956, "IERC20(_token).safeTransfer");
insert MemberExpression(9958, 9957, "IERC20(_token).safeTransfer");
insert Expression(9959, 9958, "IERC20(_token)");
insert CallExpression(9960, 9959, "IERC20(_token)");
insert Expression(9961, 9960, "IERC20");
insert Identifier(9962, 9961, "IERC20");
insert CallArgument(9963, 9960, "_token");
insert Expression(9964, 9963, "_token");
insert Identifier(9965, 9964, "_token");
insert Identifier(9966, 9958, "safeTransfer");
insert CallArgument(9967, 9956, "provider");
insert Expression(9968, 9967, "provider");
insert Identifier(9969, 9968, "provider");
insert CallArgument(9970, 9956, "_amount");
insert Expression(9971, 9970, "_amount");
insert Identifier(9972, 9971, "_amount");
insert Comment(9973, 7306, "/**\n     * @dev Internal function to withdraw deposit to the client.\n     * @param _token The token to withdraw\n     * @param _amount The amount to withdraw\n     */");
insert FunctionDefinition(9974, 7306, "function _withdrawDeposit(\n        address _token,\n        uint256 _amount\n    ) internal virtual {\n        IERC20(_token).safeTransfer(client, _amount);\n    }");
insert Identifier(9975, 9974, "_withdrawDeposit");
insert Parameter(9976, 9974, "address _token");
insert TypeName(9977, 9976, "address");
insert PrimitiveType(9978, 9977, "address");
insert Identifier(9979, 9976, "_token");
insert Parameter(9980, 9974, "uint256 _amount");
insert TypeName(9981, 9980, "uint256");
insert PrimitiveType(9982, 9981, "uint256");
insert Identifier(9983, 9980, "_amount");
insert Visibility(9984, 9974, "internal");
insert Virtual(9985, 9974, "virtual");
insert FunctionBody(9986, 9974, "{\n        IERC20(_token).safeTransfer(client, _amount);\n    }");
insert Statement(9987, 9986, "IERC20(_token).safeTransfer(client, _amount);");
insert ExpressionStatement(9988, 9987, "IERC20(_token).safeTransfer(client, _amount);");
insert Expression(9989, 9988, "IERC20(_token).safeTransfer(client, _amount)");
insert CallExpression(9990, 9989, "IERC20(_token).safeTransfer(client, _amount)");
insert Expression(9991, 9990, "IERC20(_token).safeTransfer");
insert MemberExpression(9992, 9991, "IERC20(_token).safeTransfer");
insert Expression(9993, 9992, "IERC20(_token)");
insert CallExpression(9994, 9993, "IERC20(_token)");
insert Expression(9995, 9994, "IERC20");
insert Identifier(9996, 9995, "IERC20");
insert CallArgument(9997, 9994, "_token");
insert Expression(9998, 9997, "_token");
insert Identifier(9999, 9998, "_token");
insert Identifier(10000, 9992, "safeTransfer");
insert CallArgument(10001, 9990, "client");
insert Expression(10002, 10001, "client");
insert Identifier(10003, 10002, "client");
insert CallArgument(10004, 9990, "_amount");
insert Expression(10005, 10004, "_amount");
insert Identifier(10006, 10005, "_amount");
insert Comment(10007, 7306, "// receive eth transfers");
insert Comment(10008, 7306, "// solhint-disable-next-line no-complex-fallback");
insert FallbackReceiveDefinition(10009, 7306, "receive() external payable {\n        if (locked) revert Locked();\n        if (token != wrappedNativeToken) revert InvalidWrappedNativeToken();\n        IWRAPPED(wrappedNativeToken).deposit{value: msg.value}();\n        emit Deposit(_msgSender(), msg.value);\n    }");
insert Visibility(10010, 10009, "external");
insert StateMutability(10011, 10009, "payable");
insert FunctionBody(10012, 10009, "{\n        if (locked) revert Locked();\n        if (token != wrappedNativeToken) revert InvalidWrappedNativeToken();\n        IWRAPPED(wrappedNativeToken).deposit{value: msg.value}();\n        emit Deposit(_msgSender(), msg.value);\n    }");
insert Statement(10013, 10012, "if (locked) revert Locked();");
insert IfStatement(10014, 10013, "if (locked) revert Locked();");
insert Expression(10015, 10014, "locked");
insert Identifier(10016, 10015, "locked");
insert Statement(10017, 10014, "revert Locked();");
insert RevertStatement(10018, 10017, "revert Locked();");
insert Expression(10019, 10018, "Locked");
insert Identifier(10020, 10019, "Locked");
insert RevertArguments(10021, 10018, "()");
insert Statement(10022, 10012, "if (token != wrappedNativeToken) revert InvalidWrappedNativeToken();");
insert IfStatement(10023, 10022, "if (token != wrappedNativeToken) revert InvalidWrappedNativeToken();");
insert Expression(10024, 10023, "token != wrappedNativeToken");
insert BinaryExpression(10025, 10024, "token != wrappedNativeToken");
insert Expression(10026, 10025, "token");
insert Identifier(10027, 10026, "token");
insert Expression(10028, 10025, "wrappedNativeToken");
insert Identifier(10029, 10028, "wrappedNativeToken");
insert Statement(10030, 10023, "revert InvalidWrappedNativeToken();");
insert RevertStatement(10031, 10030, "revert InvalidWrappedNativeToken();");
insert Expression(10032, 10031, "InvalidWrappedNativeToken");
insert Identifier(10033, 10032, "InvalidWrappedNativeToken");
insert RevertArguments(10034, 10031, "()");
insert Statement(10035, 10012, "IWRAPPED(wrappedNativeToken).deposit{value: msg.value}();");
insert ExpressionStatement(10036, 10035, "IWRAPPED(wrappedNativeToken).deposit{value: msg.value}();");
insert Expression(10037, 10036, "IWRAPPED(wrappedNativeToken).deposit{value: msg.value}()");
insert CallExpression(10038, 10037, "IWRAPPED(wrappedNativeToken).deposit{value: msg.value}()");
insert Expression(10039, 10038, "IWRAPPED(wrappedNativeToken).deposit{value: msg.value}");
insert StructExpression(10040, 10039, "IWRAPPED(wrappedNativeToken).deposit{value: msg.value}");
insert Expression(10041, 10040, "IWRAPPED(wrappedNativeToken).deposit");
insert MemberExpression(10042, 10041, "IWRAPPED(wrappedNativeToken).deposit");
insert Expression(10043, 10042, "IWRAPPED(wrappedNativeToken)");
insert CallExpression(10044, 10043, "IWRAPPED(wrappedNativeToken)");
insert Expression(10045, 10044, "IWRAPPED");
insert Identifier(10046, 10045, "IWRAPPED");
insert CallArgument(10047, 10044, "wrappedNativeToken");
insert Expression(10048, 10047, "wrappedNativeToken");
insert Identifier(10049, 10048, "wrappedNativeToken");
insert Identifier(10050, 10042, "deposit");
insert StructFieldAssignment(10051, 10040, "value: msg.value");
insert Identifier(10052, 10051, "value");
insert Expression(10053, 10051, "msg.value");
insert MemberExpression(10054, 10053, "msg.value");
insert Identifier(10055, 10054, "msg");
insert Identifier(10056, 10054, "value");
insert Statement(10057, 10012, "emit Deposit(_msgSender(), msg.value);");
insert EmitStatement(10058, 10057, "emit Deposit(_msgSender(), msg.value);");
insert Expression(10059, 10058, "Deposit");
insert Identifier(10060, 10059, "Deposit");
insert CallArgument(10061, 10058, "_msgSender()");
insert Expression(10062, 10061, "_msgSender()");
insert CallExpression(10063, 10062, "_msgSender()");
insert Expression(10064, 10063, "_msgSender");
insert Identifier(10065, 10064, "_msgSender");
insert CallArgument(10066, 10058, "msg.value");
insert Expression(10067, 10066, "msg.value");
insert MemberExpression(10068, 10067, "msg.value");
insert Identifier(10069, 10068, "msg");
insert Identifier(10070, 10068, "value");
commit dump_changes;
